"openapi": "3.1.0"
"info": {"title": "Gcore OpenAPI – CDN API", "description": "This OpenAPI is an aggregated OpenAPI specification that unifies all Gcore products into a single file. It covers Cloud, CDN, DNS, WAAP, DDoS Protection, Object Storage, Streaming, and FastEdge services.", "version": "2025-10-06T13:09:25.075510+00:00"}
"servers": ["url": "https://api.gcore.com"]
paths:
  "/cdn/public-ip-list":
    "get": {"operationId": "get-cdn-servers-ip-addresses", "tags": ["IP addresses list"], "summary": "Get CDN servers IP addresses", "description": "Get all IP addresses of CDN servers that can be used to pull content from your origin. \n\nThis list is updated periodically. If you want to use IP from this list to configure IP ACL in your origin, you need to independently monitor its relevance.\nWe recommend using a script to automatically update IP ACL.\n\nThis request does not require authorization.", "responses": {"200": {"description": "Successful.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/GetPublicIPList"}}}}}, "security": [], "x-codeSamples": [{"lang": "Python", "source": "from gcore import Gcore\n\nclient = Gcore()\npublic_ip_list = client.cdn.ip_ranges.list_ips()\nprint(public_ip_list.addresses)"}, {"lang": "Go", "source": "package main\n\nimport (\n  \"context\"\n  \"fmt\"\n\n  \"github.com/G-Core/gcore-go\"\n  \"github.com/G-Core/gcore-go/option\"\n)\n\nfunc main() {\n  client := gcore.NewClient(\n    option.WithAPIKey(\"My API Key\"),\n  )\n  publicIPList, err := client.Cdn.IPRanges.ListIPs(context.TODO())\n  if err != nil {\n    panic(err.Error())\n  }\n  fmt.Printf(\"%+v\\n\", publicIPList.Addresses)\n}\n"}]}
  "/cdn/public-net-list":
    "get": {"operationId": "get-cdn-servers-networks", "tags": ["IP addresses list"], "summary": "Get CDN servers networks", "description": "Get all CDN networks that can be used to pull content from your origin. \n\nThis list is updated periodically. If you want to use network from this list to configure IP ACL on your origin, you need to independently monitor its relevance.\nWe recommend using a script for automatically update IP ACL. \n\nThis request does not require authorization.", "responses": {"200": {"description": "Successful.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/GetPublicNetworkList"}}}}}, "security": [], "x-codeSamples": [{"lang": "Python", "source": "from gcore import Gcore\n\nclient = Gcore()\npublic_network_list = client.cdn.ip_ranges.list()\nprint(public_network_list.addresses)"}, {"lang": "Go", "source": "package main\n\nimport (\n  \"context\"\n  \"fmt\"\n\n  \"github.com/G-Core/gcore-go\"\n  \"github.com/G-Core/gcore-go/option\"\n)\n\nfunc main() {\n  client := gcore.NewClient(\n    option.WithAPIKey(\"My API Key\"),\n  )\n  publicNetworkList, err := client.Cdn.IPRanges.List(context.TODO())\n  if err != nil {\n    panic(err.Error())\n  }\n  fmt.Printf(\"%+v\\n\", publicNetworkList.Addresses)\n}\n"}]}
  "/cdn/clients/me":
    "get": {"operationId": "get-cdn-service-details", "tags": ["CDN service"], "summary": "Get CDN service details", "description": "Get information about CDN service.", "responses": {"200": {"description": "Successful.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CDNServiceResponse"}}}}}, "x-codeSamples": [{"lang": "Python", "source": "from gcore import Gcore\n\nclient = Gcore(\n    api_key=\"My API Key\",\n)\ncdn_account = client.cdn.get_account_overview()\nprint(cdn_account.id)"}, {"lang": "Go", "source": "package main\n\nimport (\n  \"context\"\n  \"fmt\"\n\n  \"github.com/G-Core/gcore-go\"\n  \"github.com/G-Core/gcore-go/option\"\n)\n\nfunc main() {\n  client := gcore.NewClient(\n    option.WithAPIKey(\"My API Key\"),\n  )\n  cdnAccount, err := client.Cdn.GetAccountOverview(context.TODO())\n  if err != nil {\n    panic(err.Error())\n  }\n  fmt.Printf(\"%+v\\n\", cdnAccount.ID)\n}\n"}]}
    "put": {"operationId": "change-cdn-service", "tags": ["CDN service"], "summary": "Change CDN service", "description": "Change information about CDN service.", "requestBody": {"required": true, "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ChangeCDNService"}}}}, "responses": {"200": {"description": "Successful.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CDNServiceResponse"}}}}, "400": {"description": "Invalid value of \"`utilization_level`\" parameter is provided.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/UtilizationLevelCDNServiceError"}}}}}}
    "patch": {"operationId": "patch-cdn-service", "tags": ["CDN service"], "summary": "Change CDN service", "description": "Change information about CDN service.", "requestBody": {"required": true, "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ChangeCDNService"}}}}, "responses": {"200": {"description": "Successful.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CDNServiceResponse"}}}}, "400": {"description": "Invalid value of \"`utilization_level`\" parameter is provided.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/UtilizationLevelCDNServiceError"}}}}}, "x-codeSamples": [{"lang": "Python", "source": "from gcore import Gcore\n\nclient = Gcore(\n    api_key=\"My API Key\",\n)\ncdn_account = client.cdn.update_account()\nprint(cdn_account.id)"}, {"lang": "Go", "source": "package main\n\nimport (\n  \"context\"\n  \"fmt\"\n\n  \"github.com/G-Core/gcore-go\"\n  \"github.com/G-Core/gcore-go/cdn\"\n  \"github.com/G-Core/gcore-go/option\"\n)\n\nfunc main() {\n  client := gcore.NewClient(\n    option.WithAPIKey(\"My API Key\"),\n  )\n  cdnAccount, err := client.Cdn.UpdateAccount(context.TODO(), cdn.CdnUpdateAccountParams{\n\n  })\n  if err != nil {\n    panic(err.Error())\n  }\n  fmt.Printf(\"%+v\\n\", cdnAccount.ID)\n}\n"}]}
  "/cdn/clients/me/features":
    "get": {"operationId": "get-cdn-features-details", "tags": ["CDN service"], "summary": "Get CDN features details", "description": "Get information about available CDN features.", "responses": {"200": {"description": "Successful.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ClientsMeFeaturesResponse"}}}}}, "x-codeSamples": [{"lang": "Python", "source": "from gcore import Gcore\n\nclient = Gcore(\n    api_key=\"My API Key\",\n)\ncdn_available_features = client.cdn.get_available_features()\nprint(cdn_available_features.id)"}, {"lang": "Go", "source": "package main\n\nimport (\n  \"context\"\n  \"fmt\"\n\n  \"github.com/G-Core/gcore-go\"\n  \"github.com/G-Core/gcore-go/option\"\n)\n\nfunc main() {\n  client := gcore.NewClient(\n    option.WithAPIKey(\"My API Key\"),\n  )\n  cdnAvailableFeatures, err := client.Cdn.GetAvailableFeatures(context.TODO())\n  if err != nil {\n    panic(err.Error())\n  }\n  fmt.Printf(\"%+v\\n\", cdnAvailableFeatures.ID)\n}\n"}]}
  "/cdn/clients/me/limits":
    "get": {"operationId": "get-cdn-limits-details", "tags": ["CDN service"], "summary": "Get CDN limits details", "description": "Get information about CDN service limits.", "responses": {"200": {"description": "Successful.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ClientsMeLimitsResponse"}}}}}, "x-codeSamples": [{"lang": "Python", "source": "from gcore import Gcore\n\nclient = Gcore(\n    api_key=\"My API Key\",\n)\ncdn_account_limits = client.cdn.get_account_limits()\nprint(cdn_account_limits.id)"}, {"lang": "Go", "source": "package main\n\nimport (\n  \"context\"\n  \"fmt\"\n\n  \"github.com/G-Core/gcore-go\"\n  \"github.com/G-Core/gcore-go/option\"\n)\n\nfunc main() {\n  client := gcore.NewClient(\n    option.WithAPIKey(\"My API Key\"),\n  )\n  cdnAccountLimits, err := client.Cdn.GetAccountLimits(context.TODO())\n  if err != nil {\n    panic(err.Error())\n  }\n  fmt.Printf(\"%+v\\n\", cdnAccountLimits.ID)\n}\n"}]}
  "/cdn/origin_groups":
    "get": {"operationId": "get-origin-groups-list", "tags": ["Origins"], "summary": "Get origin groups list", "description": "Get all origin groups and related origin sources.", "parameters": [{"in": "query", "name": "name", "schema": {"type": "string"}, "description": "Origin group name."}, {"in": "query", "name": "sources", "schema": {"type": "string"}, "description": "Origin sources (IP addresses or domains) in the origin group."}, {"in": "query", "name": "has_related_resources", "schema": {"type": "boolean"}, "description": "Defines whether the origin group has related CDN resources.\n\nPossible values:\n- **true** – Origin group has related CDN resources.\n- **false** – Origin group does not have related CDN resources."}], "responses": {"200": {"description": "Successful.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OriginGroupsListResponse"}}}}, "403": {"$ref": "#/components/responses/NoPermissions"}}, "x-codeSamples": [{"lang": "Python", "source": "from gcore import Gcore\n\nclient = Gcore(\n    api_key=\"My API Key\",\n)\norigin_groups_list = client.cdn.origin_groups.list()\nprint(origin_groups_list)"}, {"lang": "Go", "source": "package main\n\nimport (\n  \"context\"\n  \"fmt\"\n\n  \"github.com/G-Core/gcore-go\"\n  \"github.com/G-Core/gcore-go/cdn\"\n  \"github.com/G-Core/gcore-go/option\"\n)\n\nfunc main() {\n  client := gcore.NewClient(\n    option.WithAPIKey(\"My API Key\"),\n  )\n  originGroupsList, err := client.Cdn.OriginGroups.List(context.TODO(), cdn.OriginGroupListParams{\n\n  })\n  if err != nil {\n    panic(err.Error())\n  }\n  fmt.Printf(\"%+v\\n\", originGroupsList)\n}\n"}]}
    "post": {"operationId": "create-origin-group", "description": "Create an origin group with one or more origin sources.", "tags": ["Origins"], "summary": "Create origin group", "requestBody": {"required": true, "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CreateOriginGroup"}}}}, "responses": {"201": {"description": "Successful.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OriginGroupsResponse"}}}}, "400": {"description": "Failed to create the origin group.", "content": {"application/json": {"schema": {"anyOf": ["$ref": "#/components/schemas/OriginGroupNameNotUniqueError", "$ref": "#/components/schemas/OriginGroupNameMore255Error", "$ref": "#/components/schemas/OriginGroupIsEmptyError", "$ref": "#/components/schemas/OriginSourceIsRequiredError", "$ref": "#/components/schemas/OriginGroupSourcesLimitCreateError", "$ref": "#/components/schemas/OriginSourceWithoutSchemaError", "$ref": "#/components/schemas/OriginSourceWithoutPathError", "$ref": "#/components/schemas/OriginSourceMustBeUniqueError", "$ref": "#/components/schemas/OriginSourceForbiddenError", "$ref": "#/components/schemas/OriginSourceEqualResourceCnameError", "$ref": "#/components/schemas/OriginSourceShouldNotHavePortError", "$ref": "#/components/schemas/OriginLastSourceNotBackupError", "$ref": "#/components/schemas/SourcesShouldBeEnabledError", "$ref": "#/components/schemas/OriginSourceNotResolvedError", "$ref": "#/components/schemas/OriginSourceWrongPortError", "$ref": "#/components/schemas/OriginSourcePrivateNetworkError", "$ref": "#/components/schemas/OriginSourceForbiddenNetworkError", "$ref": "#/components/schemas/OriginSourceBadIPError", "$ref": "#/components/schemas/OriginSourceInvalidError", "$ref": "#/components/schemas/OriginSourceIPv4Error", "$ref": "#/components/schemas/AuthTypeInvalidValueError", "$ref": "#/components/schemas/AuthInvalidWithNoneAuthTypeValueError", "$ref": "#/components/schemas/OriginGroupOriginsForbiddenForPrivateOriginError", "$ref": "#/components/schemas/AuthRequiredWithAwsSignatureV4ValueError", "$ref": "#/components/schemas/AuthInvalidValueError", "$ref": "#/components/schemas/AuthS3TypeIsRequiredError", "$ref": "#/components/schemas/AuthS3BucketNameIsRequiredError", "$ref": "#/components/schemas/AuthS3AccessKeyIdIsRequiredError", "$ref": "#/components/schemas/AuthS3AccessKeyIdIsInvalidError", "$ref": "#/components/schemas/AuthS3SecretAccessKeyIsRequiredError", "$ref": "#/components/schemas/AuthS3AmazonSecretAccessKeyIsInvalidError", "$ref": "#/components/schemas/AuthS3OtherSecretAccessKeyIsInvalidError", "$ref": "#/components/schemas/AuthS3RegionIsRequiredError", "$ref": "#/components/schemas/AuthS3RegionIsInvalidError", "$ref": "#/components/schemas/AuthS3StorageHostnameIsRequiredError"]}}}}, "403": {"description": "Forbidden to create the origin group.", "content": {"application/json": {"schema": {"anyOf": ["$ref": "#/components/schemas/NoPermissionsWithExample", "$ref": "#/components/schemas/LimitsForCreationOriginsGroup"]}}}}}, "x-codeSamples": [{"lang": "Python", "source": "from gcore import Gcore\n\nclient = Gcore(\n    api_key=\"My API Key\",\n)\norigin_groups = client.cdn.origin_groups.create(\n    name=\"YourOriginGroup\",\n    sources=[{}, {}],\n)\nprint(origin_groups)"}, {"lang": "Go", "source": "package main\n\nimport (\n  \"context\"\n  \"fmt\"\n\n  \"github.com/G-Core/gcore-go\"\n  \"github.com/G-Core/gcore-go/cdn\"\n  \"github.com/G-Core/gcore-go/option\"\n)\n\nfunc main() {\n  client := gcore.NewClient(\n    option.WithAPIKey(\"My API Key\"),\n  )\n  originGroups, err := client.Cdn.OriginGroups.New(context.TODO(), cdn.OriginGroupNewParams{\n    OfNoneAuth: &cdn.OriginGroupNewParamsBodyNoneAuth{\n      Name: \"YourOriginGroup\",\n      Sources: []cdn.OriginGroupNewParamsBodyNoneAuthSource{cdn.OriginGroupNewParamsBodyNoneAuthSource{\n\n      }, cdn.OriginGroupNewParamsBodyNoneAuthSource{\n\n      }},\n    },\n  })\n  if err != nil {\n    panic(err.Error())\n  }\n  fmt.Printf(\"%+v\\n\", originGroups)\n}\n"}]}
  "/cdn/origin_groups/{origin_group_id}":
    "get": {"operationId": "get-origin-group-details", "tags": ["Origins"], "summary": "Get origin group details", "parameters": [{"in": "path", "name": "origin_group_id", "description": "Origin group ID.", "required": true, "schema": {"type": "integer"}}], "responses": {"200": {"description": "Successful.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OriginGroupsResponse"}}}}, "403": {"$ref": "#/components/responses/NoPermissions"}, "404": {"$ref": "#/components/responses/OriginGroupNotFound"}}, "x-codeSamples": [{"lang": "Python", "source": "from gcore import Gcore\n\nclient = Gcore(\n    api_key=\"My API Key\",\n)\norigin_groups = client.cdn.origin_groups.get(\n    0,\n)\nprint(origin_groups)"}, {"lang": "Go", "source": "package main\n\nimport (\n  \"context\"\n  \"fmt\"\n\n  \"github.com/G-Core/gcore-go\"\n  \"github.com/G-Core/gcore-go/option\"\n)\n\nfunc main() {\n  client := gcore.NewClient(\n    option.WithAPIKey(\"My API Key\"),\n  )\n  originGroups, err := client.Cdn.OriginGroups.Get(context.TODO(), 0)\n  if err != nil {\n    panic(err.Error())\n  }\n  fmt.Printf(\"%+v\\n\", originGroups)\n}\n"}]}
    "put": {"operationId": "change-origin-group", "tags": ["Origins"], "summary": "Change origin group", "parameters": [{"in": "path", "name": "origin_group_id", "description": "Origin group ID.", "required": true, "schema": {"type": "integer"}}], "requestBody": {"required": true, "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ChangeOriginGroupPut"}}}}, "responses": {"200": {"description": "Successful.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OriginGroupsResponse"}}}}, "400": {"description": "Failed to change the origin group.", "content": {"application/json": {"schema": {"anyOf": ["$ref": "#/components/schemas/OriginGroupNameNotUniqueError", "$ref": "#/components/schemas/OriginGroupNameMore255Error", "$ref": "#/components/schemas/OriginGroupIsEmptyError", "$ref": "#/components/schemas/OriginSourceIsRequiredError", "$ref": "#/components/schemas/OriginGroupSourcesLimitEditError", "$ref": "#/components/schemas/OriginSourceWithoutSchemaError", "$ref": "#/components/schemas/OriginSourceWithoutPathError", "$ref": "#/components/schemas/OriginSourceMustBeUniqueError", "$ref": "#/components/schemas/OriginSourceForbiddenError", "$ref": "#/components/schemas/OriginSourceEqualResourceCnameError", "$ref": "#/components/schemas/OriginSourceShouldNotHavePortError", "$ref": "#/components/schemas/OriginLastSourceNotBackupError", "$ref": "#/components/schemas/SourcesShouldBeEnabledError", "$ref": "#/components/schemas/OriginSourceNotResolvedError", "$ref": "#/components/schemas/OriginSourceWrongPortError", "$ref": "#/components/schemas/OriginSourcePrivateNetworkError", "$ref": "#/components/schemas/OriginSourceForbiddenNetworkError", "$ref": "#/components/schemas/OriginSourceBadIPError", "$ref": "#/components/schemas/OriginSourceInvalidError", "$ref": "#/components/schemas/OriginSourceIPv4Error", "$ref": "#/components/schemas/AuthTypeInvalidValueError", "$ref": "#/components/schemas/AuthInvalidWithNoneAuthTypeValueError", "$ref": "#/components/schemas/OriginGroupOriginsForbiddenForPrivateOriginError", "$ref": "#/components/schemas/AuthRequiredWithAwsSignatureV4ValueError", "$ref": "#/components/schemas/AuthInvalidValueError", "$ref": "#/components/schemas/AuthS3TypeIsRequiredError", "$ref": "#/components/schemas/AuthS3BucketNameIsRequiredError", "$ref": "#/components/schemas/AuthS3AccessKeyIdIsRequiredError", "$ref": "#/components/schemas/AuthS3AccessKeyIdIsInvalidError", "$ref": "#/components/schemas/AuthS3SecretAccessKeyIsRequiredError", "$ref": "#/components/schemas/AuthS3AmazonSecretAccessKeyIsInvalidError", "$ref": "#/components/schemas/AuthS3OtherSecretAccessKeyIsInvalidError", "$ref": "#/components/schemas/AuthS3RegionIsRequiredError", "$ref": "#/components/schemas/AuthS3RegionIsInvalidError", "$ref": "#/components/schemas/AuthS3StorageHostnameIsRequiredError"]}}}}, "403": {"$ref": "#/components/responses/NoPermissions"}, "404": {"$ref": "#/components/responses/OriginGroupNotFound"}}, "x-codeSamples": [{"lang": "Python", "source": "from gcore import Gcore\n\nclient = Gcore(\n    api_key=\"My API Key\",\n)\norigin_groups = client.cdn.origin_groups.replace(\n    origin_group_id=0,\n    auth_type=\"none\",\n    name=\"YourOriginGroup\",\n    path=\"\",\n    sources=[{}],\n    use_next=True,\n)\nprint(origin_groups)"}, {"lang": "Go", "source": "package main\n\nimport (\n  \"context\"\n  \"fmt\"\n\n  \"github.com/G-Core/gcore-go\"\n  \"github.com/G-Core/gcore-go/cdn\"\n  \"github.com/G-Core/gcore-go/option\"\n)\n\nfunc main() {\n  client := gcore.NewClient(\n    option.WithAPIKey(\"My API Key\"),\n  )\n  originGroups, err := client.Cdn.OriginGroups.Replace(\n    context.TODO(),\n    0,\n    cdn.OriginGroupReplaceParams{\n      OfNoneAuth: &cdn.OriginGroupReplaceParamsBodyNoneAuth{\n        AuthType: \"none\",\n        Name: \"YourOriginGroup\",\n        Path: \"\",\n        Sources: []cdn.OriginGroupReplaceParamsBodyNoneAuthSource{cdn.OriginGroupReplaceParamsBodyNoneAuthSource{\n\n        }},\n        UseNext: true,\n      },\n    },\n  )\n  if err != nil {\n    panic(err.Error())\n\
            \  }\n  fmt.Printf(\"%+v\\n\", originGroups)\n}\n"}]}
    "patch": {"operationId": "patch-origin-group", "tags": ["Origins"], "summary": "Change origin group", "parameters": [{"in": "path", "name": "origin_group_id", "description": "Origin group ID.", "required": true, "schema": {"type": "integer"}}], "requestBody": {"required": true, "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ChangeOriginGroup"}}}}, "responses": {"200": {"description": "Successful.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OriginGroupsResponse"}}}}, "400": {"description": "Failed to change the origin group.", "content": {"application/json": {"schema": {"anyOf": ["$ref": "#/components/schemas/OriginGroupNameNotUniqueError", "$ref": "#/components/schemas/OriginGroupNameMore255Error", "$ref": "#/components/schemas/OriginGroupIsEmptyError", "$ref": "#/components/schemas/OriginSourceIsRequiredError", "$ref": "#/components/schemas/OriginGroupSourcesLimitEditError", "$ref": "#/components/schemas/OriginSourceWithoutSchemaError", "$ref": "#/components/schemas/OriginSourceWithoutPathError", "$ref": "#/components/schemas/OriginSourceMustBeUniqueError", "$ref": "#/components/schemas/OriginSourceForbiddenError", "$ref": "#/components/schemas/OriginSourceEqualResourceCnameError", "$ref": "#/components/schemas/OriginSourceShouldNotHavePortError", "$ref": "#/components/schemas/OriginLastSourceNotBackupError", "$ref": "#/components/schemas/SourcesShouldBeEnabledError", "$ref": "#/components/schemas/OriginSourceNotResolvedError", "$ref": "#/components/schemas/OriginSourceWrongPortError", "$ref": "#/components/schemas/OriginSourcePrivateNetworkError", "$ref": "#/components/schemas/OriginSourceForbiddenNetworkError", "$ref": "#/components/schemas/OriginSourceBadIPError", "$ref": "#/components/schemas/OriginSourceInvalidError", "$ref": "#/components/schemas/OriginSourceIPv4Error", "$ref": "#/components/schemas/AuthTypeInvalidValueError", "$ref": "#/components/schemas/AuthInvalidWithNoneAuthTypeValueError", "$ref": "#/components/schemas/OriginGroupOriginsForbiddenForPrivateOriginError", "$ref": "#/components/schemas/AuthRequiredWithAwsSignatureV4ValueError", "$ref": "#/components/schemas/AuthInvalidValueError", "$ref": "#/components/schemas/AuthS3TypeIsRequiredError", "$ref": "#/components/schemas/AuthS3BucketNameIsRequiredError", "$ref": "#/components/schemas/AuthS3AccessKeyIdIsRequiredError", "$ref": "#/components/schemas/AuthS3AccessKeyIdIsInvalidError", "$ref": "#/components/schemas/AuthS3SecretAccessKeyIsRequiredError", "$ref": "#/components/schemas/AuthS3AmazonSecretAccessKeyIsInvalidError", "$ref": "#/components/schemas/AuthS3OtherSecretAccessKeyIsInvalidError", "$ref": "#/components/schemas/AuthS3RegionIsRequiredError", "$ref": "#/components/schemas/AuthS3RegionIsInvalidError", "$ref": "#/components/schemas/AuthS3StorageHostnameIsRequiredError"]}}}}, "403": {"$ref": "#/components/responses/NoPermissions"}, "404": {"$ref": "#/components/responses/OriginGroupNotFound"}}, "x-codeSamples": [{"lang": "Python", "source": "from gcore import Gcore\n\nclient = Gcore(\n    api_key=\"My API Key\",\n)\norigin_groups = client.cdn.origin_groups.update(\n    origin_group_id=0,\n    name=\"YourOriginGroup\",\n)\nprint(origin_groups)"}, {"lang": "Go", "source": "package main\n\nimport (\n  \"context\"\n  \"fmt\"\n\n  \"github.com/G-Core/gcore-go\"\n  \"github.com/G-Core/gcore-go/cdn\"\n  \"github.com/G-Core/gcore-go/option\"\n)\n\nfunc main() {\n  client := gcore.NewClient(\n    option.WithAPIKey(\"My API Key\"),\n  )\n  originGroups, err := client.Cdn.OriginGroups.Update(\n    context.TODO(),\n    0,\n    cdn.OriginGroupUpdateParams{\n      OfNoneAuth: &cdn.OriginGroupUpdateParamsBodyNoneAuth{\n        Name: \"YourOriginGroup\",\n      },\n    },\n  )\n  if err != nil {\n    panic(err.Error())\n  }\n  fmt.Printf(\"%+v\\n\", originGroups)\n}\n"}]}
    "delete": {"operationId": "delete-origin-group", "tags": ["Origins"], "summary": "Delete origin group", "parameters": [{"in": "path", "name": "origin_group_id", "description": "Origin group ID.", "required": true, "schema": {"type": "integer"}}], "responses": {"204": {"description": "Successful."}, "400": {"description": "Failed to delete the origin group.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OriginGroupIsUsedByResourceError"}}}}, "403": {"$ref": "#/components/responses/NoPermissions"}, "404": {"$ref": "#/components/responses/OriginGroupNotFound"}}, "x-codeSamples": [{"lang": "Python", "source": "from gcore import Gcore\n\nclient = Gcore(\n    api_key=\"My API Key\",\n)\nclient.cdn.origin_groups.delete(\n    0,\n)"}, {"lang": "Go", "source": "package main\n\nimport (\n  \"context\"\n\n  \"github.com/G-Core/gcore-go\"\n  \"github.com/G-Core/gcore-go/option\"\n)\n\nfunc main() {\n  client := gcore.NewClient(\n    option.WithAPIKey(\"My API Key\"),\n  )\n  err := client.Cdn.OriginGroups.Delete(context.TODO(), 0)\n  if err != nil {\n    panic(err.Error())\n  }\n}\n"}]}
  "/cdn/resources":
    "get": {"operationId": "get-cdn-resources-list", "tags": ["CDN resources"], "summary": "Get CDN resources list", "description": "Get information about all CDN resources in your account.", "parameters": ["$ref": "#/components/parameters/deleted", "$ref": "#/components/parameters/enabled", "$ref": "#/components/parameters/originGroup", "$ref": "#/components/parameters/sslEnabled", "$ref": "#/components/parameters/sslData", "$ref": "#/components/parameters/sslData_in", "$ref": "#/components/parameters/min_created", "$ref": "#/components/parameters/max_created", "$ref": "#/components/parameters/cname", "$ref": "#/components/parameters/secondaryHostnames", "$ref": "#/components/parameters/vp_enabled", "$ref": "#/components/parameters/rules", "$ref": "#/components/parameters/shielded", "$ref": "#/components/parameters/shield_dc", "$ref": "#/components/parameters/suspend", "$ref": "#/components/parameters/status"], "responses": {"200": {"description": "Successful.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ResourceListResponse"}}}}}, "x-codeSamples": [{"lang": "Python", "source": "from gcore import Gcore\n\nclient = Gcore(\n    api_key=\"My API Key\",\n)\ncdn_resource_list = client.cdn.resources.list()\nprint(cdn_resource_list)"}, {"lang": "Go", "source": "package main\n\nimport (\n  \"context\"\n  \"fmt\"\n\n  \"github.com/G-Core/gcore-go\"\n  \"github.com/G-Core/gcore-go/cdn\"\n  \"github.com/G-Core/gcore-go/option\"\n)\n\nfunc main() {\n  client := gcore.NewClient(\n    option.WithAPIKey(\"My API Key\"),\n  )\n  cdnResourceList, err := client.Cdn.Resources.List(context.TODO(), cdn.ResourceListParams{\n\n  })\n  if err != nil {\n    panic(err.Error())\n  }\n  fmt.Printf(\"%+v\\n\", cdnResourceList)\n}\n"}]}
    "post": {"operationId": "create-cdn-resource", "tags": ["CDN resources"], "summary": "Create CDN resource", "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/CreateResource"}}}}, "responses": {"201": {"description": "Successful.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ResourceResponse"}}}}, "400": {"description": "Failed to create the CDN resource.", "content": {"application/json": {"schema": {"anyOf": ["$ref": "#/components/schemas/CnameAlreadyExistsError", "$ref": "#/components/schemas/SecondaryCnameAlreadyExistsError", "$ref": "#/components/schemas/JSONParseError", "$ref": "#/components/schemas/CommonValidationError"]}}}}}, "x-codeSamples": [{"lang": "Python", "source": "from gcore import Gcore\n\nclient = Gcore(\n    api_key=\"My API Key\",\n)\ncdn_resource = client.cdn.resources.create(\n    cname=\"cdn.site.com\",\n    origin=\"example.com\",\n    origin_group=132,\n)\nprint(cdn_resource.id)"}, {"lang": "Go", "source": "package main\n\nimport (\n  \"context\"\n  \"fmt\"\n\n  \"github.com/G-Core/gcore-go\"\n  \"github.com/G-Core/gcore-go/cdn\"\n  \"github.com/G-Core/gcore-go/option\"\n)\n\nfunc main() {\n  client := gcore.NewClient(\n    option.WithAPIKey(\"My API Key\"),\n  )\n  cdnResource, err := client.Cdn.Resources.New(context.TODO(), cdn.ResourceNewParams{\n    Cname: \"cdn.site.com\",\n    Origin: \"example.com\",\n    OriginGroup: 132,\n  })\n  if err != nil {\n    panic(err.Error())\n  }\n  fmt.Printf(\"%+v\\n\", cdnResource.ID)\n}\n"}]}
  "/cdn/resources/{resource_id}":
    "get": {"operationId": "get-cdn-resource-details", "tags": ["CDN resources"], "summary": "Get CDN resource details", "parameters": ["$ref": "#/components/parameters/resource_id"], "responses": {"200": {"description": "Successful.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ResourceResponse"}}}}, "404": {"description": "CDN resource is not found."}}, "x-codeSamples": [{"lang": "Python", "source": "from gcore import Gcore\n\nclient = Gcore(\n    api_key=\"My API Key\",\n)\ncdn_resource = client.cdn.resources.get(\n    0,\n)\nprint(cdn_resource.id)"}, {"lang": "Go", "source": "package main\n\nimport (\n  \"context\"\n  \"fmt\"\n\n  \"github.com/G-Core/gcore-go\"\n  \"github.com/G-Core/gcore-go/option\"\n)\n\nfunc main() {\n  client := gcore.NewClient(\n    option.WithAPIKey(\"My API Key\"),\n  )\n  cdnResource, err := client.Cdn.Resources.Get(context.TODO(), 0)\n  if err != nil {\n    panic(err.Error())\n  }\n  fmt.Printf(\"%+v\\n\", cdnResource.ID)\n}\n"}]}
    "put": {"operationId": "change-cdn-resource", "tags": ["CDN resources"], "summary": "Change CDN resource", "parameters": ["$ref": "#/components/parameters/resource_id"], "requestBody": {"required": true, "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ChangeResource"}}}}, "responses": {"200": {"description": "Successful.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ResourceResponse"}}}}, "400": {"description": "Failed to change the CDN resource.", "content": {"application/json": {"schema": {"anyOf": ["$ref": "#/components/schemas/CannotLinkYourSSLCertificate"]}}}}, "404": {"description": "CDN resource is not found."}}, "x-codeSamples": [{"lang": "Python", "source": "from gcore import Gcore\n\nclient = Gcore(\n    api_key=\"My API Key\",\n)\ncdn_resource = client.cdn.resources.replace(\n    resource_id=0,\n    origin_group=132,\n)\nprint(cdn_resource.id)"}, {"lang": "Go", "source": "package main\n\nimport (\n  \"context\"\n  \"fmt\"\n\n  \"github.com/G-Core/gcore-go\"\n  \"github.com/G-Core/gcore-go/cdn\"\n  \"github.com/G-Core/gcore-go/option\"\n)\n\nfunc main() {\n  client := gcore.NewClient(\n    option.WithAPIKey(\"My API Key\"),\n  )\n  cdnResource, err := client.Cdn.Resources.Replace(\n    context.TODO(),\n    0,\n    cdn.ResourceReplaceParams{\n      OriginGroup: 132,\n    },\n  )\n  if err != nil {\n    panic(err.Error())\n  }\n  fmt.Printf(\"%+v\\n\", cdnResource.ID)\n}\n"}]}
    "patch": {"operationId": "patch-cdn-resource", "tags": ["CDN resources"], "summary": "Change CDN resource", "parameters": ["$ref": "#/components/parameters/resource_id"], "requestBody": {"required": true, "content": {"application/json": {"schema": {"$ref": "#/components/schemas/PatchResource"}}}}, "responses": {"200": {"description": "Successful.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ResourceResponse"}}}}, "404": {"description": "CDN resource is not found."}}, "x-codeSamples": [{"lang": "Python", "source": "from gcore import Gcore\n\nclient = Gcore(\n    api_key=\"My API Key\",\n)\ncdn_resource = client.cdn.resources.update(\n    resource_id=0,\n)\nprint(cdn_resource.id)"}, {"lang": "Go", "source": "package main\n\nimport (\n  \"context\"\n  \"fmt\"\n\n  \"github.com/G-Core/gcore-go\"\n  \"github.com/G-Core/gcore-go/cdn\"\n  \"github.com/G-Core/gcore-go/option\"\n)\n\nfunc main() {\n  client := gcore.NewClient(\n    option.WithAPIKey(\"My API Key\"),\n  )\n  cdnResource, err := client.Cdn.Resources.Update(\n    context.TODO(),\n    0,\n    cdn.ResourceUpdateParams{\n\n    },\n  )\n  if err != nil {\n    panic(err.Error())\n  }\n  fmt.Printf(\"%+v\\n\", cdnResource.ID)\n}\n"}]}
    "delete": {"operationId": "delete-cdn-resource", "tags": ["CDN resources"], "summary": "Delete CDN resource", "description": "Delete the CDN resource from the system permanently.\n\nNotes:\n- **Deactivation Requirement**: Set the `active` attribute to `false` before deletion.\n- **Statistics Availability**: Statistics will be available for **365 days** after deletion through the [statistics endpoints](/docs/api-reference/cdn/cdn-statistics/cdn-resource-statistics).\n- **Irreversibility**: This action is irreversible. Once deleted, the CDN resource cannot be recovered.", "parameters": ["$ref": "#/components/parameters/resource_id"], "responses": {"204": {"description": "Successful"}, "400": {"description": "Failed to delete the CDN resource.", "content": {"application/json": {"schema": {"anyOf": ["$ref": "#/components/schemas/PrimaryResourceDeletionFailed", "$ref": "#/components/schemas/StreamingResourceDeletionFailed", "$ref": "#/components/schemas/FullCustomResourceDeletionFailed", "$ref": "#/components/schemas/ActiveInstanceDeletionProhibited"]}}}}, "404": {"$ref": "#/components/responses/ResourceNotFound"}}, "x-codeSamples": [{"lang": "Python", "source": "from gcore import Gcore\n\nclient = Gcore(\n    api_key=\"My API Key\",\n)\nclient.cdn.resources.delete(\n    0,\n)"}, {"lang": "Go", "source": "package main\n\nimport (\n  \"context\"\n\n  \"github.com/G-Core/gcore-go\"\n  \"github.com/G-Core/gcore-go/option\"\n)\n\nfunc main() {\n  client := gcore.NewClient(\n    option.WithAPIKey(\"My API Key\"),\n  )\n  err := client.Cdn.Resources.Delete(context.TODO(), 0)\n  if err != nil {\n    panic(err.Error())\n  }\n}\n"}]}
  "/cdn/activity_log/requests":
    "get": {"operationId": "get-activity-logs", "tags": ["CDN activity logs"], "summary": "Get CDN activity logs", "description": "Get information about all CDN activity logs records.", "parameters": ["$ref": "#/components/parameters/cdn_path", "$ref": "#/components/parameters/user_id", "$ref": "#/components/parameters/token_id", "$ref": "#/components/parameters/client_id", "$ref": "#/components/parameters/method", "$ref": "#/components/parameters/min_requested_at", "$ref": "#/components/parameters/max_requested_at", "$ref": "#/components/parameters/remote_ip_address", "$ref": "#/components/parameters/status_code", "$ref": "#/components/parameters/limit", "$ref": "#/components/parameters/offset"], "responses": {"200": {"$ref": "#/components/responses/List"}, "401": {"description": "Authentication credentials were not provided or the given token is not valid for any token type."}}, "x-codeSamples": [{"lang": "Python", "source": "from gcore import Gcore\n\nclient = Gcore(\n    api_key=\"My API Key\",\n)\npage = client.cdn.audit_log.list()\npage = page.results[0]\nprint(page.id)"}, {"lang": "Go", "source": "package main\n\nimport (\n  \"context\"\n  \"fmt\"\n\n  \"github.com/G-Core/gcore-go\"\n  \"github.com/G-Core/gcore-go/cdn\"\n  \"github.com/G-Core/gcore-go/option\"\n)\n\nfunc main() {\n  client := gcore.NewClient(\n    option.WithAPIKey(\"My API Key\"),\n  )\n  page, err := client.Cdn.AuditLog.List(context.TODO(), cdn.AuditLogListParams{\n\n  })\n  if err != nil {\n    panic(err.Error())\n  }\n  fmt.Printf(\"%+v\\n\", page)\n}\n"}]}
  "/cdn/activity_log/requests/{log_id}":
    "get": {"operationId": "get-activity-logs-details", "tags": ["CDN activity logs"], "summary": "Get CDN activity logs details", "description": "Get information about CDN activity logs record.", "parameters": ["$ref": "#/components/parameters/ID"], "responses": {"200": {"$ref": "#/components/responses/Details"}, "401": {"description": "Authentication credentials were not provided or the given token is not valid for any token type."}, "404": {"description": "Activity logs record is not found."}}, "x-codeSamples": [{"lang": "Python", "source": "from gcore import Gcore\n\nclient = Gcore(\n    api_key=\"My API Key\",\n)\ncdn_audit_log_entry = client.cdn.audit_log.get(\n    0,\n)\nprint(cdn_audit_log_entry.id)"}, {"lang": "Go", "source": "package main\n\nimport (\n  \"context\"\n  \"fmt\"\n\n  \"github.com/G-Core/gcore-go\"\n  \"github.com/G-Core/gcore-go/option\"\n)\n\nfunc main() {\n  client := gcore.NewClient(\n    option.WithAPIKey(\"My API Key\"),\n  )\n  cdnAuditLogEntry, err := client.Cdn.AuditLog.Get(context.TODO(), 0)\n  if err != nil {\n    panic(err.Error())\n  }\n  fmt.Printf(\"%+v\\n\", cdnAuditLogEntry.ID)\n}\n"}]}
  "/cdn/raw_log_settings":
    "get": {"operationId": "get-raw-logs-settings", "tags": ["Log forwarding"], "summary": "Get raw logs settings", "description": "Get information about raw logs feature settings.", "responses": {"200": {"description": "Successful.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/GetRawLogs"}}}}, "403": {"description": "Feature is disabled for your account."}, "404": {"description": "Feature settings do not exist or have been deleted."}}, "x-codeSamples": [{"lang": "Python", "source": "from gcore import Gcore\n\nclient = Gcore(\n    api_key=\"My API Key\",\n)\nlog_settings = client.cdn.logs.settings.get()\nprint(log_settings.s3_access_key_id)"}, {"lang": "Go", "source": "package main\n\nimport (\n  \"context\"\n  \"fmt\"\n\n  \"github.com/G-Core/gcore-go\"\n  \"github.com/G-Core/gcore-go/option\"\n)\n\nfunc main() {\n  client := gcore.NewClient(\n    option.WithAPIKey(\"My API Key\"),\n  )\n  logSettings, err := client.Cdn.Logs.Settings.Get(context.TODO())\n  if err != nil {\n    panic(err.Error())\n  }\n  fmt.Printf(\"%+v\\n\", logSettings.S3AccessKeyID)\n}\n"}]}
    "post": {"operationId": "setup-raw-logs-settings", "tags": ["Log forwarding"], "summary": "Setup raw logs settings", "requestBody": {"required": true, "content": {"application/json": {"schema": {"$ref": "#/components/schemas/SetupRawLogs"}}}}, "responses": {"201": {"description": "Successful."}, "400": {"description": "You will receive an error with the invalid parameter mentioned."}}, "x-codeSamples": [{"lang": "Python", "source": "from gcore import Gcore\n\nclient = Gcore(\n    api_key=\"My API Key\",\n)\nclient.cdn.logs.settings.create(\n    all_resources_bucket=\"all_resources_bucket\",\n    all_resources_folder=\"all_resources_folder\",\n    folders=[{}],\n    for_all_resources=True,\n    ftp_hostname=\"ftp_hostname\",\n    ftp_login=\"ftp_login\",\n    ftp_password=\"ftp_password\",\n    s3_access_key_id=\"s3_access_key_id\",\n    s3_hostname=\"s3_hostname\",\n    s3_secret_key=\"s3_secret_key\",\n    s3_type=\"s3_type\",\n    sftp_hostname=\"sftp_hostname\",\n    sftp_login=\"sftp_login\",\n    sftp_password=\"sftp_password\",\n    storage_type=\"storage_type\",\n)"}, {"lang": "Go", "source": "package main\n\nimport (\n  \"context\"\n\n  \"github.com/G-Core/gcore-go\"\n  \"github.com/G-Core/gcore-go/cdn\"\n  \"github.com/G-Core/gcore-go/option\"\n)\n\nfunc main() {\n  client := gcore.NewClient(\n    option.WithAPIKey(\"My API Key\"),\n  )\n  err := client.Cdn.Logs.Settings.New(context.TODO(), cdn.LogSettingNewParams{\n    AllResourcesBucket: \"all_resources_bucket\",\n    AllResourcesFolder: \"all_resources_folder\",\n    Folders: []cdn.LogSettingNewParamsFolder{cdn.LogSettingNewParamsFolder{\n\n    }},\n    ForAllResources: true,\n    FtpHostname: \"ftp_hostname\",\n    FtpLogin: \"ftp_login\",\n    FtpPassword: \"ftp_password\",\n    S3AccessKeyID: \"s3_access_key_id\",\n    S3Hostname: \"s3_hostname\",\n    S3SecretKey: \"s3_secret_key\",\n    S3Type: \"s3_type\",\n    SftpHostname: \"sftp_hostname\",\n    SftpLogin: \"sftp_login\",\n    SftpPassword: \"sftp_password\",\n    StorageType: \"storage_type\",\n  })\n  if err != nil {\n    panic(err.Error())\n  }\n}\n"}]}
    "put": {"operationId": "change-raw-logs-settings", "tags": ["Log forwarding"], "summary": "Change raw logs settings", "description": "PATCH method is not allowed.", "requestBody": {"required": true, "content": {"application/json": {"schema": {"$ref": "#/components/schemas/SetupRawLogs"}}}}, "responses": {"200": {"description": "Successful."}}, "x-codeSamples": [{"lang": "Python", "source": "from gcore import Gcore\n\nclient = Gcore(\n    api_key=\"My API Key\",\n)\nclient.cdn.logs.settings.update(\n    all_resources_bucket=\"all_resources_bucket\",\n    all_resources_folder=\"all_resources_folder\",\n    folders=[{}],\n    for_all_resources=True,\n    ftp_hostname=\"ftp_hostname\",\n    ftp_login=\"ftp_login\",\n    ftp_password=\"ftp_password\",\n    s3_access_key_id=\"s3_access_key_id\",\n    s3_hostname=\"s3_hostname\",\n    s3_secret_key=\"s3_secret_key\",\n    s3_type=\"s3_type\",\n    sftp_hostname=\"sftp_hostname\",\n    sftp_login=\"sftp_login\",\n    sftp_password=\"sftp_password\",\n    storage_type=\"storage_type\",\n)"}, {"lang": "Go", "source": "package main\n\nimport (\n  \"context\"\n\n  \"github.com/G-Core/gcore-go\"\n  \"github.com/G-Core/gcore-go/cdn\"\n  \"github.com/G-Core/gcore-go/option\"\n)\n\nfunc main() {\n  client := gcore.NewClient(\n    option.WithAPIKey(\"My API Key\"),\n  )\n  err := client.Cdn.Logs.Settings.Update(context.TODO(), cdn.LogSettingUpdateParams{\n    AllResourcesBucket: \"all_resources_bucket\",\n    AllResourcesFolder: \"all_resources_folder\",\n    Folders: []cdn.LogSettingUpdateParamsFolder{cdn.LogSettingUpdateParamsFolder{\n\n    }},\n    ForAllResources: true,\n    FtpHostname: \"ftp_hostname\",\n    FtpLogin: \"ftp_login\",\n    FtpPassword: \"ftp_password\",\n    S3AccessKeyID: \"s3_access_key_id\",\n    S3Hostname: \"s3_hostname\",\n    S3SecretKey: \"s3_secret_key\",\n    S3Type: \"s3_type\",\n    SftpHostname: \"sftp_hostname\",\n    SftpLogin: \"sftp_login\",\n    SftpPassword: \"sftp_password\",\n    StorageType: \"storage_type\",\n  })\n  if err != nil {\n    panic(err.Error())\n  }\n}\n"}]}
    "delete": {"operationId": "delete-raw-logs-settings", "tags": ["Log forwarding"], "summary": "Delete raw logs settings", "description": "Delete the raw logs delivery configuration from the system permanently.\n\nNotes:\n- **Deactivation Requirement**: Set the `enabled` attribute to `false` before deletion.\n- **Irreversibility**: This action is irreversible. Once deleted, the raw logs delivery configuration cannot be recovered.", "responses": {"204": {"description": "Successful."}, "400": {"description": "Failed to delete the log forwarding configuration.", "content": {"application/json": {"schema": {"anyOf": ["$ref": "#/components/schemas/ActiveInstanceDeletionProhibited"]}}}}}, "x-codeSamples": [{"lang": "Python", "source": "from gcore import Gcore\n\nclient = Gcore(\n    api_key=\"My API Key\",\n)\nclient.cdn.logs.settings.delete()"}, {"lang": "Go", "source": "package main\n\nimport (\n  \"context\"\n\n  \"github.com/G-Core/gcore-go\"\n  \"github.com/G-Core/gcore-go/option\"\n)\n\nfunc main() {\n  client := gcore.NewClient(\n    option.WithAPIKey(\"My API Key\"),\n  )\n  err := client.Cdn.Logs.Settings.Delete(context.TODO())\n  if err != nil {\n    panic(err.Error())\n  }\n}\n"}]}
  "/cdn/advanced/v1/logs":
    "get": {"operationId": "get-cdn-logs", "tags": ["Log viewer"], "summary": "Get CDN logs", "description": "Get CDN logs for up to 3 days starting today. \n\nYou can filter logs using query parameters by client IP, CDN resource, date, path and etc.\n\nTo filter the CDN logs by 2xx status codes, use:\n\\* &`status__gte`=200&`status__lt`=300", "parameters": ["$ref": "#/components/parameters/from", "$ref": "#/components/parameters/to", "$ref": "#/components/parameters/query-offset", "$ref": "#/components/parameters/query-limit", "$ref": "#/components/parameters/ordering", "$ref": "#/components/parameters/fields", "$ref": "#/components/parameters/method__eq", "$ref": "#/components/parameters/method__ne", "$ref": "#/components/parameters/method__in", "$ref": "#/components/parameters/method__not_in", "$ref": "#/components/parameters/client_ip__eq", "$ref": "#/components/parameters/client_ip__ne", "$ref": "#/components/parameters/client_ip__in", "$ref": "#/components/parameters/client_ip__not_in", "$ref": "#/components/parameters/status__gt", "$ref": "#/components/parameters/status__gte", "$ref": "#/components/parameters/status__lt", "$ref": "#/components/parameters/status__lte", "$ref": "#/components/parameters/status__eq", "$ref": "#/components/parameters/status__ne", "$ref": "#/components/parameters/status__in", "$ref": "#/components/parameters/status__not_in", "$ref": "#/components/parameters/size__gt", "$ref": "#/components/parameters/size__gte", "$ref": "#/components/parameters/size__lt", "$ref": "#/components/parameters/size__lte", "$ref": "#/components/parameters/size__eq", "$ref": "#/components/parameters/size__ne", "$ref": "#/components/parameters/size__in", "$ref": "#/components/parameters/size__not_in", "$ref": "#/components/parameters/cname__eq", "$ref": "#/components/parameters/cname__ne", "$ref": "#/components/parameters/cname__in", "$ref": "#/components/parameters/cname__not_in", "$ref": "#/components/parameters/cname__contains", "$ref": "#/components/parameters/resource_id__gt", "$ref": "#/components/parameters/resource_id__gte", "$ref": "#/components/parameters/resource_id__lt", "$ref": "#/components/parameters/resource_id__lte", "$ref": "#/components/parameters/resource_id__eq", "$ref": "#/components/parameters/resource_id__ne", "$ref": "#/components/parameters/resource_id__in", "$ref": "#/components/parameters/resource_id__not_in", "$ref": "#/components/parameters/cache_status__eq", "$ref": "#/components/parameters/cache_status__ne", "$ref": "#/components/parameters/cache_status__in", "$ref": "#/components/parameters/cache_status__not_in", "$ref": "#/components/parameters/datacenter__eq", "$ref": "#/components/parameters/datacenter__ne", "$ref": "#/components/parameters/datacenter__in", "$ref": "#/components/parameters/datacenter__not_in"], "responses": {"200": {"description": "Successful.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/GetLogsResponse"}}}}}, "x-codeSamples": [{"lang": "Python", "source": "from gcore import Gcore\n\nclient = Gcore(\n    api_key=\"My API Key\",\n)\npage = client.cdn.logs.list(\n    from_=\"from\",\n    to=\"to\",\n)\npage = page.data[0]\nprint(page.resource_id)"}, {"lang": "Go", "source": "package main\n\nimport (\n  \"context\"\n  \"fmt\"\n\n  \"github.com/G-Core/gcore-go\"\n  \"github.com/G-Core/gcore-go/cdn\"\n  \"github.com/G-Core/gcore-go/option\"\n)\n\nfunc main() {\n  client := gcore.NewClient(\n    option.WithAPIKey(\"My API Key\"),\n  )\n  page, err := client.Cdn.Logs.List(context.TODO(), cdn.LogListParams{\n    From: \"from\",\n    To: \"to\",\n  })\n  if err != nil {\n    panic(err.Error())\n  }\n  fmt.Printf(\"%+v\\n\", page)\n}\n"}]}
  "/cdn/advanced/v1/logs/download":
    "get": {"operationId": "download-cdn-logs", "tags": ["Log viewer"], "summary": "Download CDN logs", "description": "Download CDN logs for up to 3 days starting today. \n\nYou can filter logs using query params by client IP, CDN resource, date, path and etc.", "parameters": ["$ref": "#/components/parameters/from", "$ref": "#/components/parameters/to", "$ref": "#/components/parameters/query-offset", {"in": "query", "name": "limit", "schema": {"type": "integer", "default": 10000, "maximum": 10000, "x-stainless-skip": ["terraform"]}, "description": "Maximum number of log records in the response."}, "$ref": "#/components/parameters/method__eq", "$ref": "#/components/parameters/method__ne", "$ref": "#/components/parameters/method__in", "$ref": "#/components/parameters/method__not_in", "$ref": "#/components/parameters/client_ip__eq", "$ref": "#/components/parameters/client_ip__ne", "$ref": "#/components/parameters/client_ip__in", "$ref": "#/components/parameters/client_ip__not_in", "$ref": "#/components/parameters/status__gt", "$ref": "#/components/parameters/status__gte", "$ref": "#/components/parameters/status__lt", "$ref": "#/components/parameters/status__lte", "$ref": "#/components/parameters/status__eq", "$ref": "#/components/parameters/status__ne", "$ref": "#/components/parameters/status__in", "$ref": "#/components/parameters/status__not_in", "$ref": "#/components/parameters/size__gt", "$ref": "#/components/parameters/size__gte", "$ref": "#/components/parameters/size__lt", "$ref": "#/components/parameters/size__lte", "$ref": "#/components/parameters/size__eq", "$ref": "#/components/parameters/size__ne", "$ref": "#/components/parameters/size__in", "$ref": "#/components/parameters/size__not_in", "$ref": "#/components/parameters/cname__eq", "$ref": "#/components/parameters/cname__ne", "$ref": "#/components/parameters/cname__in", "$ref": "#/components/parameters/cname__not_in", "$ref": "#/components/parameters/cname__contains", "$ref": "#/components/parameters/resource_id__gt", "$ref": "#/components/parameters/resource_id__gte", "$ref": "#/components/parameters/resource_id__lt", "$ref": "#/components/parameters/resource_id__lte", "$ref": "#/components/parameters/resource_id__eq", "$ref": "#/components/parameters/resource_id__ne", "$ref": "#/components/parameters/resource_id__in", "$ref": "#/components/parameters/resource_id__not_in", "$ref": "#/components/parameters/cache_status__eq", "$ref": "#/components/parameters/cache_status__ne", "$ref": "#/components/parameters/cache_status__in", "$ref": "#/components/parameters/cache_status__not_in", "$ref": "#/components/parameters/datacenter__eq", "$ref": "#/components/parameters/datacenter__ne", "$ref": "#/components/parameters/datacenter__in", "$ref": "#/components/parameters/datacenter__not_in", {"in": "query", "name": "sort", "schema": {"type": "string"}, "description": "Sorting rules. \n\nPossible values:\n- **method** - Request HTTP method.\n- **`client_ip`** - IP address of the client who sent the request.\n- **status** - Status code in the response.\n- **size** - Response size in bytes.\n- **cname** - Custom domain of the requested resource.\n- **`resource_id`** - ID of the requested CDN resource.\n- **`cache_status`** - Caching status.\n- **datacenter** - Data center where request was processed.\n- **timestamp** - Date and time when the request was made.\n\nMay include multiple values separated by a comma.\n\nExample:\n\\* &sort=-timestamp,status"}, {"in": "query", "name": "fields", "schema": {"type": "string", "default": "timestamp,path,method,referer,user_agent,client_ip,status,size,cname,resource_id,cache_status,datacenter"}, "description": "A comma-separated list of returned fields. \n\nSupported fields are presented in the responses section.\n\nExample:\n\\* &fields=timestamp,path,status"}, {"in": "query", "name": "format", "schema": {"type": "string"}, "required": true, "description": "Output format. \n\nPossible values:\n- csv\n- tsv"}], "responses": {"200": {"content": {"application/zip": {"schema": {"type": "string", "format": "binary"}}}, "description": "Successful.",
          "headers": {"content-disposition": {"schema": {"type": "string", "format": "attachment; filename=<from>_<to>_<format>.zip"}, "description": "Result file name. \n\n\"From\" and \"to\" will be formatted according to RFC 5545.\n\nExample:\n\\* `20210614T000000_20210615T000000_tsv`.zip"}}}}, "x-codeSamples": [{"lang": "Python", "source": "from gcore import Gcore\n\nclient = Gcore(\n    api_key=\"My API Key\",\n)\nresponse = client.cdn.logs.download(\n    format=\"format\",\n    from_=\"from\",\n    to=\"to\",\n)\nprint(response)\ncontent = response.read()\nprint(content)"}, {"lang": "Go", "source": "package main\n\nimport (\n  \"context\"\n  \"fmt\"\n\n  \"github.com/G-Core/gcore-go\"\n  \"github.com/G-Core/gcore-go/cdn\"\n  \"github.com/G-Core/gcore-go/option\"\n)\n\nfunc main() {\n  client := gcore.NewClient(\n    option.WithAPIKey(\"My API Key\"),\n  )\n  response, err := client.Cdn.Logs.Download(context.TODO(), cdn.LogDownloadParams{\n    Format: \"format\",\n    From: \"from\",\n    To: \"to\",\n  })\n  if err != nil {\n    panic(err.Error())\n  }\n  fmt.Printf(\"%+v\\n\", response)\n}\n"}]}
  "/cdn/logs_uploader/policies":
    "get": {"operationId": "get-policies-list", "tags": ["Logs uploader"], "summary": "Get policies list", "description": "Get list of logs uploader policies.", "parameters": [{"in": "query", "name": "search", "schema": {"type": "string"}, "description": "Search by policy name or id."}, {"in": "query", "name": "config_ids", "schema": {"type": "array", "items": {"type": "integer"}}, "description": "Filter by ids of related logs uploader configs that use given policy."}], "responses": {"200": {"description": "Successful.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/LogsUploaderPolicyListResponse"}}}}, "403": {"description": "Feature is disabled for your account."}}, "x-codeSamples": [{"lang": "Python", "source": "from gcore import Gcore\n\nclient = Gcore(\n    api_key=\"My API Key\",\n)\nlogs_uploader_policy_list = client.cdn.logs_uploader.policies.list()\nprint(logs_uploader_policy_list)"}, {"lang": "Go", "source": "package main\n\nimport (\n  \"context\"\n  \"fmt\"\n\n  \"github.com/G-Core/gcore-go\"\n  \"github.com/G-Core/gcore-go/cdn\"\n  \"github.com/G-Core/gcore-go/option\"\n)\n\nfunc main() {\n  client := gcore.NewClient(\n    option.WithAPIKey(\"My API Key\"),\n  )\n  logsUploaderPolicyList, err := client.Cdn.LogsUploader.Policies.List(context.TODO(), cdn.LogsUploaderPolicyListParams{\n\n  })\n  if err != nil {\n    panic(err.Error())\n  }\n  fmt.Printf(\"%+v\\n\", logsUploaderPolicyList)\n}\n"}]}
    "post": {"operationId": "create-policy", "tags": ["Logs uploader"], "summary": "Create policy", "description": "Create logs uploader policy.", "requestBody": {"required": true, "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CreateLogsUploaderPolicy"}}}}, "responses": {"201": {"description": "Successful.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/LogsUploaderPolicyResponse"}}}}, "400": {"description": "You will receive an error with the invalid parameter mentioned."}, "403": {"description": "Feature is disabled for your account."}}, "x-codeSamples": [{"lang": "Python", "source": "from gcore import Gcore\n\nclient = Gcore(\n    api_key=\"My API Key\",\n)\nlogs_uploader_policy = client.cdn.logs_uploader.policies.create()\nprint(logs_uploader_policy.id)"}, {"lang": "Go", "source": "package main\n\nimport (\n  \"context\"\n  \"fmt\"\n\n  \"github.com/G-Core/gcore-go\"\n  \"github.com/G-Core/gcore-go/cdn\"\n  \"github.com/G-Core/gcore-go/option\"\n)\n\nfunc main() {\n  client := gcore.NewClient(\n    option.WithAPIKey(\"My API Key\"),\n  )\n  logsUploaderPolicy, err := client.Cdn.LogsUploader.Policies.New(context.TODO(), cdn.LogsUploaderPolicyNewParams{\n\n  })\n  if err != nil {\n    panic(err.Error())\n  }\n  fmt.Printf(\"%+v\\n\", logsUploaderPolicy.ID)\n}\n"}]}
  "/cdn/logs_uploader/policies/{id}":
    "get": {"operationId": "get-policy-details", "tags": ["Logs uploader"], "summary": "Get policy details", "description": "Get information about logs uploader policy.", "parameters": [{"name": "id", "in": "path", "required": true, "schema": {"type": "integer"}}], "responses": {"200": {"description": "Successful.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/LogsUploaderPolicyResponse"}}}}, "403": {"description": "Feature is disabled for your account."}, "404": {"description": "Policy do not exist or has been deleted."}}, "x-codeSamples": [{"lang": "Python", "source": "from gcore import Gcore\n\nclient = Gcore(\n    api_key=\"My API Key\",\n)\nlogs_uploader_policy = client.cdn.logs_uploader.policies.get(\n    0,\n)\nprint(logs_uploader_policy.id)"}, {"lang": "Go", "source": "package main\n\nimport (\n  \"context\"\n  \"fmt\"\n\n  \"github.com/G-Core/gcore-go\"\n  \"github.com/G-Core/gcore-go/option\"\n)\n\nfunc main() {\n  client := gcore.NewClient(\n    option.WithAPIKey(\"My API Key\"),\n  )\n  logsUploaderPolicy, err := client.Cdn.LogsUploader.Policies.Get(context.TODO(), 0)\n  if err != nil {\n    panic(err.Error())\n  }\n  fmt.Printf(\"%+v\\n\", logsUploaderPolicy.ID)\n}\n"}]}
    "put": {"operationId": "change-policy", "tags": ["Logs uploader"], "summary": "Change policy", "description": "Change logs uploader policy.", "parameters": [{"name": "id", "in": "path", "required": true, "schema": {"type": "integer"}}], "requestBody": {"required": true, "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CreateLogsUploaderPolicy"}}}}, "responses": {"200": {"description": "Successful.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/LogsUploaderPolicyResponse"}}}}, "400": {"description": "You will receive an error with the invalid parameter mentioned."}, "403": {"description": "Feature is disabled for your account."}, "404": {"description": "Policy do not exist or has been deleted."}}, "x-codeSamples": [{"lang": "Python", "source": "from gcore import Gcore\n\nclient = Gcore(\n    api_key=\"My API Key\",\n)\nlogs_uploader_policy = client.cdn.logs_uploader.policies.replace(\n    id=0,\n)\nprint(logs_uploader_policy.id)"}, {"lang": "Go", "source": "package main\n\nimport (\n  \"context\"\n  \"fmt\"\n\n  \"github.com/G-Core/gcore-go\"\n  \"github.com/G-Core/gcore-go/cdn\"\n  \"github.com/G-Core/gcore-go/option\"\n)\n\nfunc main() {\n  client := gcore.NewClient(\n    option.WithAPIKey(\"My API Key\"),\n  )\n  logsUploaderPolicy, err := client.Cdn.LogsUploader.Policies.Replace(\n    context.TODO(),\n    0,\n    cdn.LogsUploaderPolicyReplaceParams{\n\n    },\n  )\n  if err != nil {\n    panic(err.Error())\n  }\n  fmt.Printf(\"%+v\\n\", logsUploaderPolicy.ID)\n}\n"}]}
    "patch": {"operationId": "patch-policy", "tags": ["Logs uploader"], "summary": "Change policy", "description": "Change logs uploader policy partially.", "parameters": [{"name": "id", "in": "path", "required": true, "schema": {"type": "integer"}}], "requestBody": {"required": true, "content": {"application/json": {"schema": {"$ref": "#/components/schemas/PatchLogsUploaderPolicy"}}}}, "responses": {"200": {"description": "Successful.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/LogsUploaderPolicyResponse"}}}}, "400": {"description": "You will receive an error with the invalid parameter mentioned."}, "403": {"description": "Feature is disabled for your account."}, "404": {"description": "Policy do not exist or has been deleted."}}, "x-codeSamples": [{"lang": "Python", "source": "from gcore import Gcore\n\nclient = Gcore(\n    api_key=\"My API Key\",\n)\nlogs_uploader_policy = client.cdn.logs_uploader.policies.update(\n    id=0,\n)\nprint(logs_uploader_policy.id)"}, {"lang": "Go", "source": "package main\n\nimport (\n  \"context\"\n  \"fmt\"\n\n  \"github.com/G-Core/gcore-go\"\n  \"github.com/G-Core/gcore-go/cdn\"\n  \"github.com/G-Core/gcore-go/option\"\n)\n\nfunc main() {\n  client := gcore.NewClient(\n    option.WithAPIKey(\"My API Key\"),\n  )\n  logsUploaderPolicy, err := client.Cdn.LogsUploader.Policies.Update(\n    context.TODO(),\n    0,\n    cdn.LogsUploaderPolicyUpdateParams{\n\n    },\n  )\n  if err != nil {\n    panic(err.Error())\n  }\n  fmt.Printf(\"%+v\\n\", logsUploaderPolicy.ID)\n}\n"}]}
    "delete": {"operationId": "delete-policy", "tags": ["Logs uploader"], "summary": "Delete policy", "description": "Delete the logs uploader policy from the system permanently.\n\nNotes:\n- **Irreversibility**: This action is irreversible. Once deleted, the logs uploader policy cannot be recovered.", "parameters": [{"name": "id", "in": "path", "required": true, "schema": {"type": "integer"}}], "responses": {"204": {"description": "Successful."}, "400": {"description": "Policy cannot be deleted if it's assigned to any logs uploader config."}, "403": {"description": "Feature is disabled for your account."}, "404": {"description": "Policy do not exist or has been deleted."}}, "x-codeSamples": [{"lang": "Python", "source": "from gcore import Gcore\n\nclient = Gcore(\n    api_key=\"My API Key\",\n)\nclient.cdn.logs_uploader.policies.delete(\n    0,\n)"}, {"lang": "Go", "source": "package main\n\nimport (\n  \"context\"\n\n  \"github.com/G-Core/gcore-go\"\n  \"github.com/G-Core/gcore-go/option\"\n)\n\nfunc main() {\n  client := gcore.NewClient(\n    option.WithAPIKey(\"My API Key\"),\n  )\n  err := client.Cdn.LogsUploader.Policies.Delete(context.TODO(), 0)\n  if err != nil {\n    panic(err.Error())\n  }\n}\n"}]}
  "/cdn/logs_uploader/policies/fields":
    "get": {"operationId": "get-policy-fields", "tags": ["Logs uploader"], "summary": "Get policy fields", "description": "Get list of available fields for logs uploader policy.", "responses": {"200": {"description": "Successful.", "content": {"application/json": {"schema": {"type": "array", "items": {"type": "string"}}}}}, "403": {"description": "Feature is disabled for your account."}}, "x-codeSamples": [{"lang": "Python", "source": "from gcore import Gcore\n\nclient = Gcore(\n    api_key=\"My API Key\",\n)\nresponse = client.cdn.logs_uploader.policies.list_fields()\nprint(response)"}, {"lang": "Go", "source": "package main\n\nimport (\n  \"context\"\n  \"fmt\"\n\n  \"github.com/G-Core/gcore-go\"\n  \"github.com/G-Core/gcore-go/option\"\n)\n\nfunc main() {\n  client := gcore.NewClient(\n    option.WithAPIKey(\"My API Key\"),\n  )\n  response, err := client.Cdn.LogsUploader.Policies.ListFields(context.TODO())\n  if err != nil {\n    panic(err.Error())\n  }\n  fmt.Printf(\"%+v\\n\", response)\n}\n"}]}
  "/cdn/logs_uploader/targets":
    "get": {"operationId": "get-targets-list", "tags": ["Logs uploader"], "summary": "Get targets list", "description": "Get list of logs uploader targets.", "parameters": [{"in": "query", "name": "search", "schema": {"type": "string"}, "description": "Search by target name or id."}, {"in": "query", "name": "config_ids", "schema": {"type": "array", "items": {"type": "integer"}}, "description": "Filter by ids of related logs uploader configs that use given target."}], "responses": {"200": {"description": "Successful.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/LogsUploaderTargetListResponse"}}}}, "403": {"description": "Feature is disabled for your account."}}, "x-codeSamples": [{"lang": "Python", "source": "from gcore import Gcore\n\nclient = Gcore(\n    api_key=\"My API Key\",\n)\nlogs_uploader_target_list = client.cdn.logs_uploader.targets.list()\nprint(logs_uploader_target_list)"}, {"lang": "Go", "source": "package main\n\nimport (\n  \"context\"\n  \"fmt\"\n\n  \"github.com/G-Core/gcore-go\"\n  \"github.com/G-Core/gcore-go/cdn\"\n  \"github.com/G-Core/gcore-go/option\"\n)\n\nfunc main() {\n  client := gcore.NewClient(\n    option.WithAPIKey(\"My API Key\"),\n  )\n  logsUploaderTargetList, err := client.Cdn.LogsUploader.Targets.List(context.TODO(), cdn.LogsUploaderTargetListParams{\n\n  })\n  if err != nil {\n    panic(err.Error())\n  }\n  fmt.Printf(\"%+v\\n\", logsUploaderTargetList)\n}\n"}]}
    "post": {"operationId": "create-target", "tags": ["Logs uploader"], "summary": "Create target", "description": "Create logs uploader target.", "requestBody": {"required": true, "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CreateLogsUploaderTarget"}}}}, "responses": {"201": {"description": "Successful.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/LogsUploaderTargetResponse"}}}}, "400": {"description": "You will receive an error with the invalid parameter mentioned."}, "403": {"description": "Feature is disabled for your account."}}, "x-codeSamples": [{"lang": "Python", "source": "from gcore import Gcore\n\nclient = Gcore(\n    api_key=\"My API Key\",\n)\nlogs_uploader_target = client.cdn.logs_uploader.targets.create(\n    config={\n        \"access_key_id\": \"access_key_id\",\n        \"bucket_name\": \"bucket_name\",\n        \"endpoint\": \"endpoint\",\n        \"region\": \"region\",\n        \"secret_access_key\": \"secret_access_key\",\n    },\n    storage_type=\"s3_gcore\",\n)\nprint(logs_uploader_target.id)"}, {"lang": "Go", "source": "package main\n\nimport (\n  \"context\"\n  \"fmt\"\n\n  \"github.com/G-Core/gcore-go\"\n  \"github.com/G-Core/gcore-go/cdn\"\n  \"github.com/G-Core/gcore-go/option\"\n)\n\nfunc main() {\n  client := gcore.NewClient(\n    option.WithAPIKey(\"My API Key\"),\n  )\n  logsUploaderTarget, err := client.Cdn.LogsUploader.Targets.New(context.TODO(), cdn.LogsUploaderTargetNewParams{\n    Config: cdn.LogsUploaderTargetNewParamsConfigUnion{\n      OfS3GcoreConfig: &cdn.LogsUploaderTargetNewParamsConfigS3GcoreConfig{\n        AccessKeyID: \"access_key_id\",\n        BucketName: \"bucket_name\",\n        Endpoint: \"endpoint\",\n        Region: \"region\",\n        SecretAccessKey: \"secret_access_key\",\n      },\n    },\n    StorageType: cdn.LogsUploaderTargetNewParamsStorageTypeS3Gcore,\n  })\n  if err != nil {\n    panic(err.Error())\n  }\n  fmt.Printf(\"%+v\\n\", logsUploaderTarget.ID)\n}\n"}]}
  "/cdn/logs_uploader/targets/{id}":
    "get": {"operationId": "get-target-details", "tags": ["Logs uploader"], "summary": "Get target details", "description": "Get information about logs uploader target.", "parameters": [{"name": "id", "in": "path", "required": true, "schema": {"type": "integer"}}], "responses": {"200": {"description": "Successful.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/LogsUploaderTargetResponse"}}}}, "403": {"description": "Feature is disabled for your account."}, "404": {"description": "Logs uploader target do not exist or has been deleted."}}, "x-codeSamples": [{"lang": "Python", "source": "from gcore import Gcore\n\nclient = Gcore(\n    api_key=\"My API Key\",\n)\nlogs_uploader_target = client.cdn.logs_uploader.targets.get(\n    0,\n)\nprint(logs_uploader_target.id)"}, {"lang": "Go", "source": "package main\n\nimport (\n  \"context\"\n  \"fmt\"\n\n  \"github.com/G-Core/gcore-go\"\n  \"github.com/G-Core/gcore-go/option\"\n)\n\nfunc main() {\n  client := gcore.NewClient(\n    option.WithAPIKey(\"My API Key\"),\n  )\n  logsUploaderTarget, err := client.Cdn.LogsUploader.Targets.Get(context.TODO(), 0)\n  if err != nil {\n    panic(err.Error())\n  }\n  fmt.Printf(\"%+v\\n\", logsUploaderTarget.ID)\n}\n"}]}
    "put": {"operationId": "change-target", "tags": ["Logs uploader"], "summary": "Change target", "description": "Change logs uploader target.", "parameters": [{"name": "id", "in": "path", "required": true, "schema": {"type": "integer"}}], "requestBody": {"required": true, "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CreateLogsUploaderTarget"}}}}, "responses": {"200": {"description": "Successful.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/LogsUploaderTargetResponse"}}}}, "400": {"description": "You will receive an error with the invalid parameter mentioned."}, "403": {"description": "Feature is disabled for your account."}, "404": {"description": "Logs uploader target do not exist or has been deleted."}}, "x-codeSamples": [{"lang": "Python", "source": "from gcore import Gcore\n\nclient = Gcore(\n    api_key=\"My API Key\",\n)\nlogs_uploader_target = client.cdn.logs_uploader.targets.replace(\n    id=0,\n    config={\n        \"access_key_id\": \"access_key_id\",\n        \"bucket_name\": \"bucket_name\",\n        \"endpoint\": \"endpoint\",\n        \"region\": \"region\",\n        \"secret_access_key\": \"secret_access_key\",\n    },\n    storage_type=\"s3_gcore\",\n)\nprint(logs_uploader_target.id)"}, {"lang": "Go", "source": "package main\n\nimport (\n  \"context\"\n  \"fmt\"\n\n  \"github.com/G-Core/gcore-go\"\n  \"github.com/G-Core/gcore-go/cdn\"\n  \"github.com/G-Core/gcore-go/option\"\n)\n\nfunc main() {\n  client := gcore.NewClient(\n    option.WithAPIKey(\"My API Key\"),\n  )\n  logsUploaderTarget, err := client.Cdn.LogsUploader.Targets.Replace(\n    context.TODO(),\n    0,\n    cdn.LogsUploaderTargetReplaceParams{\n      Config: cdn.LogsUploaderTargetReplaceParamsConfigUnion{\n        OfS3GcoreConfig: &cdn.LogsUploaderTargetReplaceParamsConfigS3GcoreConfig{\n          AccessKeyID: \"access_key_id\",\n          BucketName: \"bucket_name\",\n          Endpoint: \"endpoint\",\n          Region: \"region\",\n          SecretAccessKey: \"secret_access_key\",\n        },\n      },\n      StorageType: cdn.LogsUploaderTargetReplaceParamsStorageTypeS3Gcore,\n    },\n  )\n  if err != nil {\n    panic(err.Error())\n  }\n  fmt.Printf(\"%+v\\n\", logsUploaderTarget.ID)\n}\n"}]}
    "patch": {"operationId": "patch-target", "tags": ["Logs uploader"], "summary": "Change target", "description": "Change logs uploader target partially.", "parameters": [{"name": "id", "in": "path", "required": true, "schema": {"type": "integer"}}], "requestBody": {"required": true, "content": {"application/json": {"schema": {"$ref": "#/components/schemas/PatchLogsUploaderTarget"}}}}, "responses": {"200": {"description": "Successful.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/LogsUploaderTargetResponse"}}}}, "400": {"description": "You will receive an error with the invalid parameter mentioned."}, "403": {"description": "Feature is disabled for your account."}, "404": {"description": "Logs uploader target do not exist or has been deleted."}}, "x-codeSamples": [{"lang": "Python", "source": "from gcore import Gcore\n\nclient = Gcore(\n    api_key=\"My API Key\",\n)\nlogs_uploader_target = client.cdn.logs_uploader.targets.update(\n    id=0,\n)\nprint(logs_uploader_target.id)"}, {"lang": "Go", "source": "package main\n\nimport (\n  \"context\"\n  \"fmt\"\n\n  \"github.com/G-Core/gcore-go\"\n  \"github.com/G-Core/gcore-go/cdn\"\n  \"github.com/G-Core/gcore-go/option\"\n)\n\nfunc main() {\n  client := gcore.NewClient(\n    option.WithAPIKey(\"My API Key\"),\n  )\n  logsUploaderTarget, err := client.Cdn.LogsUploader.Targets.Update(\n    context.TODO(),\n    0,\n    cdn.LogsUploaderTargetUpdateParams{\n\n    },\n  )\n  if err != nil {\n    panic(err.Error())\n  }\n  fmt.Printf(\"%+v\\n\", logsUploaderTarget.ID)\n}\n"}]}
    "delete": {"operationId": "delete-target", "tags": ["Logs uploader"], "summary": "Delete target", "description": "Delete the logs uploader target from the system permanently.\n\nNotes:\n- **Irreversibility**: This action is irreversible. Once deleted, the logs uploader target cannot be recovered.", "parameters": [{"name": "id", "in": "path", "required": true, "schema": {"type": "integer"}}], "responses": {"204": {"description": "Successful."}, "400": {"description": "Target cannot be deleted if it's assigned to any logs uploader config."}, "403": {"description": "Feature is disabled for your account."}, "404": {"description": "Logs uploader target do not exist or has been deleted."}}, "x-codeSamples": [{"lang": "Python", "source": "from gcore import Gcore\n\nclient = Gcore(\n    api_key=\"My API Key\",\n)\nclient.cdn.logs_uploader.targets.delete(\n    0,\n)"}, {"lang": "Go", "source": "package main\n\nimport (\n  \"context\"\n\n  \"github.com/G-Core/gcore-go\"\n  \"github.com/G-Core/gcore-go/option\"\n)\n\nfunc main() {\n  client := gcore.NewClient(\n    option.WithAPIKey(\"My API Key\"),\n  )\n  err := client.Cdn.LogsUploader.Targets.Delete(context.TODO(), 0)\n  if err != nil {\n    panic(err.Error())\n  }\n}\n"}]}
  "/cdn/logs_uploader/targets/{id}/validate":
    "post": {"operationId": "validate-target", "tags": ["Logs uploader"], "summary": "Validate target", "description": "Validate logs uploader target.", "parameters": [{"name": "id", "in": "path", "required": true, "schema": {"type": "integer"}}], "responses": {"200": {"description": "Successful.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/LogsUploaderValidationResponse"}}}}, "403": {"description": "Feature is disabled for your account."}, "404": {"description": "Logs uploader target do not exist or has been deleted."}}, "x-codeSamples": [{"lang": "Python", "source": "from gcore import Gcore\n\nclient = Gcore(\n    api_key=\"My API Key\",\n)\nlogs_uploader_validation = client.cdn.logs_uploader.targets.validate(\n    0,\n)\nprint(logs_uploader_validation.code)"}, {"lang": "Go", "source": "package main\n\nimport (\n  \"context\"\n  \"fmt\"\n\n  \"github.com/G-Core/gcore-go\"\n  \"github.com/G-Core/gcore-go/option\"\n)\n\nfunc main() {\n  client := gcore.NewClient(\n    option.WithAPIKey(\"My API Key\"),\n  )\n  logsUploaderValidation, err := client.Cdn.LogsUploader.Targets.Validate(context.TODO(), 0)\n  if err != nil {\n    panic(err.Error())\n  }\n  fmt.Printf(\"%+v\\n\", logsUploaderValidation.Code)\n}\n"}]}
  "/cdn/logs_uploader/configs":
    "get": {"operationId": "get-configs-list", "tags": ["Logs uploader"], "summary": "Get configs list", "description": "Get list of logs uploader configs.", "parameters": [{"in": "query", "name": "search", "schema": {"type": "string"}, "description": "Search by config name or id."}, {"in": "query", "name": "resource_ids", "schema": {"type": "array", "items": {"type": "integer"}}, "description": "Filter by ids of CDN resources that are assigned to given config."}], "responses": {"200": {"description": "Successful.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/LogsUploaderConfigListResponse"}}}}, "403": {"description": "Feature is disabled for your account."}}, "x-codeSamples": [{"lang": "Python", "source": "from gcore import Gcore\n\nclient = Gcore(\n    api_key=\"My API Key\",\n)\nlogs_uploader_config_list = client.cdn.logs_uploader.configs.list()\nprint(logs_uploader_config_list)"}, {"lang": "Go", "source": "package main\n\nimport (\n  \"context\"\n  \"fmt\"\n\n  \"github.com/G-Core/gcore-go\"\n  \"github.com/G-Core/gcore-go/cdn\"\n  \"github.com/G-Core/gcore-go/option\"\n)\n\nfunc main() {\n  client := gcore.NewClient(\n    option.WithAPIKey(\"My API Key\"),\n  )\n  logsUploaderConfigList, err := client.Cdn.LogsUploader.Configs.List(context.TODO(), cdn.LogsUploaderConfigListParams{\n\n  })\n  if err != nil {\n    panic(err.Error())\n  }\n  fmt.Printf(\"%+v\\n\", logsUploaderConfigList)\n}\n"}]}
    "post": {"operationId": "create-config", "tags": ["Logs uploader"], "summary": "Create config", "description": "Create logs uploader config.", "requestBody": {"required": true, "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CreateLogsUploaderConfig"}}}}, "responses": {"201": {"description": "Successful.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/LogsUploaderConfigResponse"}}}}, "400": {"description": "You will receive an error with the invalid parameter mentioned."}, "403": {"description": "Feature is disabled for your account."}}, "x-codeSamples": [{"lang": "Python", "source": "from gcore import Gcore\n\nclient = Gcore(\n    api_key=\"My API Key\",\n)\nlogs_uploader_config = client.cdn.logs_uploader.configs.create(\n    name=\"name\",\n    policy=0,\n    target=0,\n)\nprint(logs_uploader_config.id)"}, {"lang": "Go", "source": "package main\n\nimport (\n  \"context\"\n  \"fmt\"\n\n  \"github.com/G-Core/gcore-go\"\n  \"github.com/G-Core/gcore-go/cdn\"\n  \"github.com/G-Core/gcore-go/option\"\n)\n\nfunc main() {\n  client := gcore.NewClient(\n    option.WithAPIKey(\"My API Key\"),\n  )\n  logsUploaderConfig, err := client.Cdn.LogsUploader.Configs.New(context.TODO(), cdn.LogsUploaderConfigNewParams{\n    Name: \"name\",\n    Policy: 0,\n    Target: 0,\n  })\n  if err != nil {\n    panic(err.Error())\n  }\n  fmt.Printf(\"%+v\\n\", logsUploaderConfig.ID)\n}\n"}]}
  "/cdn/logs_uploader/configs/{id}":
    "get": {"operationId": "get-config-details", "tags": ["Logs uploader"], "summary": "Get config details", "description": "Get information about logs uploader config.", "parameters": [{"name": "id", "in": "path", "required": true, "schema": {"type": "integer"}}], "responses": {"200": {"description": "Successful.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/LogsUploaderConfigResponse"}}}}, "403": {"description": "Feature is disabled for your account."}, "404": {"description": "Logs uploader config do not exist or has been deleted."}}, "x-codeSamples": [{"lang": "Python", "source": "from gcore import Gcore\n\nclient = Gcore(\n    api_key=\"My API Key\",\n)\nlogs_uploader_config = client.cdn.logs_uploader.configs.get(\n    0,\n)\nprint(logs_uploader_config.id)"}, {"lang": "Go", "source": "package main\n\nimport (\n  \"context\"\n  \"fmt\"\n\n  \"github.com/G-Core/gcore-go\"\n  \"github.com/G-Core/gcore-go/option\"\n)\n\nfunc main() {\n  client := gcore.NewClient(\n    option.WithAPIKey(\"My API Key\"),\n  )\n  logsUploaderConfig, err := client.Cdn.LogsUploader.Configs.Get(context.TODO(), 0)\n  if err != nil {\n    panic(err.Error())\n  }\n  fmt.Printf(\"%+v\\n\", logsUploaderConfig.ID)\n}\n"}]}
    "put": {"operationId": "change-config", "tags": ["Logs uploader"], "summary": "Change config", "description": "Change logs uploader config.", "parameters": [{"name": "id", "in": "path", "required": true, "schema": {"type": "integer"}}], "requestBody": {"required": true, "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CreateLogsUploaderConfig"}}}}, "responses": {"200": {"description": "Successful.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/LogsUploaderConfigResponse"}}}}, "400": {"description": "You will receive an error with the invalid parameter mentioned."}, "403": {"description": "Feature is disabled for your account."}, "404": {"description": "Logs uploader config do not exist or has been deleted."}}, "x-codeSamples": [{"lang": "Python", "source": "from gcore import Gcore\n\nclient = Gcore(\n    api_key=\"My API Key\",\n)\nlogs_uploader_config = client.cdn.logs_uploader.configs.replace(\n    id=0,\n    name=\"name\",\n    policy=0,\n    target=0,\n)\nprint(logs_uploader_config.id)"}, {"lang": "Go", "source": "package main\n\nimport (\n  \"context\"\n  \"fmt\"\n\n  \"github.com/G-Core/gcore-go\"\n  \"github.com/G-Core/gcore-go/cdn\"\n  \"github.com/G-Core/gcore-go/option\"\n)\n\nfunc main() {\n  client := gcore.NewClient(\n    option.WithAPIKey(\"My API Key\"),\n  )\n  logsUploaderConfig, err := client.Cdn.LogsUploader.Configs.Replace(\n    context.TODO(),\n    0,\n    cdn.LogsUploaderConfigReplaceParams{\n      Name: \"name\",\n      Policy: 0,\n      Target: 0,\n    },\n  )\n  if err != nil {\n    panic(err.Error())\n  }\n  fmt.Printf(\"%+v\\n\", logsUploaderConfig.ID)\n}\n"}]}
    "patch": {"operationId": "patch-config", "tags": ["Logs uploader"], "summary": "Change config", "description": "Change logs uploader config partially.", "parameters": [{"name": "id", "in": "path", "required": true, "schema": {"type": "integer"}}], "requestBody": {"required": true, "content": {"application/json": {"schema": {"$ref": "#/components/schemas/PatchLogsUploaderConfig"}}}}, "responses": {"200": {"description": "Successful.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/LogsUploaderConfigResponse"}}}}, "400": {"description": "You will receive an error with the invalid parameter mentioned."}, "403": {"description": "Feature is disabled for your account."}, "404": {"description": "Logs uploader config do not exist or has been deleted."}}, "x-codeSamples": [{"lang": "Python", "source": "from gcore import Gcore\n\nclient = Gcore(\n    api_key=\"My API Key\",\n)\nlogs_uploader_config = client.cdn.logs_uploader.configs.update(\n    id=0,\n)\nprint(logs_uploader_config.id)"}, {"lang": "Go", "source": "package main\n\nimport (\n  \"context\"\n  \"fmt\"\n\n  \"github.com/G-Core/gcore-go\"\n  \"github.com/G-Core/gcore-go/cdn\"\n  \"github.com/G-Core/gcore-go/option\"\n)\n\nfunc main() {\n  client := gcore.NewClient(\n    option.WithAPIKey(\"My API Key\"),\n  )\n  logsUploaderConfig, err := client.Cdn.LogsUploader.Configs.Update(\n    context.TODO(),\n    0,\n    cdn.LogsUploaderConfigUpdateParams{\n\n    },\n  )\n  if err != nil {\n    panic(err.Error())\n  }\n  fmt.Printf(\"%+v\\n\", logsUploaderConfig.ID)\n}\n"}]}
    "delete": {"operationId": "delete-config", "tags": ["Logs uploader"], "summary": "Delete config", "description": "Delete the logs uploader config from the system permanently.\n\nNotes:\n- **Irreversibility**: This action is irreversible. Once deleted, the logs uploader config cannot be recovered.", "parameters": [{"name": "id", "in": "path", "required": true, "schema": {"type": "integer"}}], "responses": {"204": {"description": "Successful."}, "403": {"description": "Feature is disabled for your account."}, "404": {"description": "Logs uploader config do not exist or has been deleted."}}, "x-codeSamples": [{"lang": "Python", "source": "from gcore import Gcore\n\nclient = Gcore(\n    api_key=\"My API Key\",\n)\nclient.cdn.logs_uploader.configs.delete(\n    0,\n)"}, {"lang": "Go", "source": "package main\n\nimport (\n  \"context\"\n\n  \"github.com/G-Core/gcore-go\"\n  \"github.com/G-Core/gcore-go/option\"\n)\n\nfunc main() {\n  client := gcore.NewClient(\n    option.WithAPIKey(\"My API Key\"),\n  )\n  err := client.Cdn.LogsUploader.Configs.Delete(context.TODO(), 0)\n  if err != nil {\n    panic(err.Error())\n  }\n}\n"}]}
  "/cdn/logs_uploader/configs/{id}/validate":
    "post": {"operationId": "validate-config", "tags": ["Logs uploader"], "summary": "Validate config", "description": "Validate logs uploader config.", "parameters": [{"name": "id", "in": "path", "required": true, "schema": {"type": "integer"}}], "responses": {"200": {"description": "Successful.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/LogsUploaderValidationResponse"}}}}, "403": {"description": "Feature is disabled for your account."}, "404": {"description": "Logs uploader config do not exist or has been deleted."}}, "x-codeSamples": [{"lang": "Python", "source": "from gcore import Gcore\n\nclient = Gcore(\n    api_key=\"My API Key\",\n)\nlogs_uploader_validation = client.cdn.logs_uploader.configs.validate(\n    0,\n)\nprint(logs_uploader_validation.code)"}, {"lang": "Go", "source": "package main\n\nimport (\n  \"context\"\n  \"fmt\"\n\n  \"github.com/G-Core/gcore-go\"\n  \"github.com/G-Core/gcore-go/option\"\n)\n\nfunc main() {\n  client := gcore.NewClient(\n    option.WithAPIKey(\"My API Key\"),\n  )\n  logsUploaderValidation, err := client.Cdn.LogsUploader.Configs.Validate(context.TODO(), 0)\n  if err != nil {\n    panic(err.Error())\n  }\n  fmt.Printf(\"%+v\\n\", logsUploaderValidation.Code)\n}\n"}]}
  "/cdn/aws_regions":
    "get": {"operationId": "get-aws-regions-list", "tags": ["Logs uploader", "Log forwarding"], "summary": "Get AWS regions list", "description": "Get the list of Amazon AWS regions.", "responses": {"200": {"description": "Successful.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/GetAwsRegionsResponse"}}}}}}
  "/cdn/alibaba_regions":
    "get": {"operationId": "get-alibaba-regions-list", "tags": ["Logs uploader"], "summary": "Get Alibaba regions list", "description": "Get the list of Alibaba Cloud regions.", "responses": {"200": {"description": "Successful.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/GetAlibabaRegionsResponse"}}}}}}
  "/cdn/resources/{resource_id}/prefetch":
    "post": {"operationId": "prefetch-content", "tags": ["Tools"], "summary": "Prefetch content", "description": "Pre-populate files to a CDN cache before users requests. Prefetch is recommended only for files that **more than 200 MB** and **less than 5 GB**.\n\nYou can make one prefetch request for a CDN resource per minute. One request for prefetch may content only up to 100 paths to files.\n\nThe time of procedure depends on the number and size of the files.\n\nIf you need to update files stored in the CDN, first purge these files and then prefetch.", "parameters": ["$ref": "#/components/parameters/resource_id"], "requestBody": {"required": true, "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ResourcePrefetch"}}}}, "responses": {"201": {"description": "Successful."}, "400": {"description": "Prefetch request validation is failed.", "content": {"application/json": {"schema": {"anyOf": ["$ref": "#/components/schemas/IncorrectPathsItemsPurgeOrPrefetchError", "$ref": "#/components/schemas/JSONParseError"]}}}}, "429": {"description": "You have exceeded number of allowed prefetch requests for your CDN resource."}}, "x-codeSamples": [{"lang": "Python", "source": "from gcore import Gcore\n\nclient = Gcore(\n    api_key=\"My API Key\",\n)\nclient.cdn.resources.prefetch(\n    resource_id=0,\n    paths=[\"/test.jpg\", \"test1.jpg\"],\n)"}, {"lang": "Go", "source": "package main\n\nimport (\n  \"context\"\n\n  \"github.com/G-Core/gcore-go\"\n  \"github.com/G-Core/gcore-go/cdn\"\n  \"github.com/G-Core/gcore-go/option\"\n)\n\nfunc main() {\n  client := gcore.NewClient(\n    option.WithAPIKey(\"My API Key\"),\n  )\n  err := client.Cdn.Resources.Prefetch(\n    context.TODO(),\n    0,\n    cdn.ResourcePrefetchParams{\n      Paths: []string{\"/test.jpg\", \"test1.jpg\"},\n    },\n  )\n  if err != nil {\n    panic(err.Error())\n  }\n}\n"}]}
  "/cdn/resources/{resource_id}/purge":
    "post": {"operationId": "purge-cache", "tags": ["Tools"], "summary": "Purge cache", "description": "Delete cache from CDN servers. This is necessary to update CDN content.\n\nWe have different limits for different purge types:\n- **Purge all cache** - One purge request for a CDN resource per minute.\n- **Purge by URL** - Two purge requests for a CDN resource per minute. One purge request is limited to 100 URLs.\n- **Purge by pattern** - One purge request for a CDN resource per minute. One purge request is limited to 10 patterns.", "parameters": ["$ref": "#/components/parameters/resource_id"], "requestBody": {"required": true, "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ResourcePurge"}}}}, "responses": {"201": {"description": "Successful."}, "400": {"description": "Failed to purge the CDN resource cache.", "content": {"application/json": {"schema": {"anyOf": ["$ref": "#/components/schemas/PathsNotProvidedPurgeError", "$ref": "#/components/schemas/IncorrectPathsTypePurgeError", "$ref": "#/components/schemas/IncorrectPathsFormatPurgeError", "$ref": "#/components/schemas/IncorrectPathsItemsPurgeOrPrefetchError", "$ref": "#/components/schemas/JSONParseError"]}}}}, "429": {"description": "You have exceeded number of allowed purge requests for your CDN resource."}}, "x-codeSamples": [{"lang": "Python", "source": "from gcore import Gcore\n\nclient = Gcore(\n    api_key=\"My API Key\",\n)\nclient.cdn.resources.purge(\n    resource_id=0,\n)"}, {"lang": "Go", "source": "package main\n\nimport (\n  \"context\"\n\n  \"github.com/G-Core/gcore-go\"\n  \"github.com/G-Core/gcore-go/cdn\"\n  \"github.com/G-Core/gcore-go/option\"\n)\n\nfunc main() {\n  client := gcore.NewClient(\n    option.WithAPIKey(\"My API Key\"),\n  )\n  err := client.Cdn.Resources.Purge(\n    context.TODO(),\n    0,\n    cdn.ResourcePurgeParams{\n      OfPurgeByURL: &cdn.ResourcePurgeParamsBodyPurgeByURL{\n\n      },\n    },\n  )\n  if err != nil {\n    panic(err.Error())\n  }\n}\n"}]}
  "/cdn/resources/{resource_id}/rules":
    "get": {"operationId": "get-rules-list", "tags": ["Rules"], "summary": "Get rules list", "parameters": ["$ref": "#/components/parameters/resource_id"], "responses": {"200": {"description": "Successful.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/RuleListResponse"}}}}}, "x-codeSamples": [{"lang": "Python", "source": "from gcore import Gcore\n\nclient = Gcore(\n    api_key=\"My API Key\",\n)\ncdn_resource_rules = client.cdn.resources.rules.list(\n    0,\n)\nprint(cdn_resource_rules)"}, {"lang": "Go", "source": "package main\n\nimport (\n  \"context\"\n  \"fmt\"\n\n  \"github.com/G-Core/gcore-go\"\n  \"github.com/G-Core/gcore-go/option\"\n)\n\nfunc main() {\n  client := gcore.NewClient(\n    option.WithAPIKey(\"My API Key\"),\n  )\n  cdnResourceRules, err := client.Cdn.Resources.Rules.List(context.TODO(), 0)\n  if err != nil {\n    panic(err.Error())\n  }\n  fmt.Printf(\"%+v\\n\", cdnResourceRules)\n}\n"}]}
    "post": {"operationId": "create-rule", "tags": ["Rules"], "summary": "Create rule", "parameters": ["$ref": "#/components/parameters/resource_id"], "requestBody": {"required": true, "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CreateRule"}}}}, "responses": {"201": {"description": "Created.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/RuleResponse"}}}}, "400": {"description": "Failed to create the rule.", "content": {"application/json": {"schema": {"anyOf": ["$ref": "#/components/schemas/RuleNameAlreadyExistsError", "$ref": "#/components/schemas/RulePatternError", "$ref": "#/components/schemas/RulePatternAlreadyExistsError", "$ref": "#/components/schemas/JSONParseError", "$ref": "#/components/schemas/CommonValidationError"]}}}}}, "x-codeSamples": [{"lang": "Python", "source": "from gcore import Gcore\n\nclient = Gcore(\n    api_key=\"My API Key\",\n)\ncdn_resource_rule = client.cdn.resources.rules.create(\n    resource_id=0,\n    name=\"My first rule\",\n    rule=\"/folder/images/*.png\",\n    rule_type=0,\n)\nprint(cdn_resource_rule.id)"}, {"lang": "Go", "source": "package main\n\nimport (\n  \"context\"\n  \"fmt\"\n\n  \"github.com/G-Core/gcore-go\"\n  \"github.com/G-Core/gcore-go/cdn\"\n  \"github.com/G-Core/gcore-go/option\"\n)\n\nfunc main() {\n  client := gcore.NewClient(\n    option.WithAPIKey(\"My API Key\"),\n  )\n  cdnResourceRule, err := client.Cdn.Resources.Rules.New(\n    context.TODO(),\n    0,\n    cdn.ResourceRuleNewParams{\n      Name: \"My first rule\",\n      Rule: \"/folder/images/*.png\",\n      RuleType: 0,\n    },\n  )\n  if err != nil {\n    panic(err.Error())\n  }\n  fmt.Printf(\"%+v\\n\", cdnResourceRule.ID)\n}\n"}]}
  "/cdn/resources/{resource_id}/rules/{rule_id}":
    "get": {"operationId": "get-rule-details", "tags": ["Rules"], "summary": "Get rule details", "parameters": ["$ref": "#/components/parameters/resource_id", "$ref": "#/components/parameters/rule_id"], "responses": {"200": {"description": "Successful.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/RuleResponse"}}}}, "404": {"description": "Rule is not found."}}, "x-codeSamples": [{"lang": "Python", "source": "from gcore import Gcore\n\nclient = Gcore(\n    api_key=\"My API Key\",\n)\ncdn_resource_rule = client.cdn.resources.rules.get(\n    rule_id=0,\n    resource_id=0,\n)\nprint(cdn_resource_rule.id)"}, {"lang": "Go", "source": "package main\n\nimport (\n  \"context\"\n  \"fmt\"\n\n  \"github.com/G-Core/gcore-go\"\n  \"github.com/G-Core/gcore-go/cdn\"\n  \"github.com/G-Core/gcore-go/option\"\n)\n\nfunc main() {\n  client := gcore.NewClient(\n    option.WithAPIKey(\"My API Key\"),\n  )\n  cdnResourceRule, err := client.Cdn.Resources.Rules.Get(\n    context.TODO(),\n    0,\n    cdn.ResourceRuleGetParams{\n      ResourceID: 0,\n    },\n  )\n  if err != nil {\n    panic(err.Error())\n  }\n  fmt.Printf(\"%+v\\n\", cdnResourceRule.ID)\n}\n"}]}
    "put": {"operationId": "change-rule", "tags": ["Rules"], "summary": "Change rule", "parameters": ["$ref": "#/components/parameters/resource_id", "$ref": "#/components/parameters/rule_id"], "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/ChangeRule"}}}}, "responses": {"200": {"description": "Successful.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/RuleResponse"}}}}, "400": {"description": "Filed to change the rule.", "content": {"application/json": {"schema": {"anyOf": ["$ref": "#/components/schemas/RuleNameAlreadyExistsError", "$ref": "#/components/schemas/RulePatternError", "$ref": "#/components/schemas/RulePatternAlreadyExistsError", "$ref": "#/components/schemas/JSONParseError", "$ref": "#/components/schemas/CommonValidationError"]}}}}, "404": {"description": "Rule is not found."}}, "x-codeSamples": [{"lang": "Python", "source": "from gcore import Gcore\n\nclient = Gcore(\n    api_key=\"My API Key\",\n)\ncdn_resource_rule = client.cdn.resources.rules.replace(\n    rule_id=0,\n    resource_id=0,\n    rule=\"/folder/images/*.png\",\n    rule_type=0,\n)\nprint(cdn_resource_rule.id)"}, {"lang": "Go", "source": "package main\n\nimport (\n  \"context\"\n  \"fmt\"\n\n  \"github.com/G-Core/gcore-go\"\n  \"github.com/G-Core/gcore-go/cdn\"\n  \"github.com/G-Core/gcore-go/option\"\n)\n\nfunc main() {\n  client := gcore.NewClient(\n    option.WithAPIKey(\"My API Key\"),\n  )\n  cdnResourceRule, err := client.Cdn.Resources.Rules.Replace(\n    context.TODO(),\n    0,\n    cdn.ResourceRuleReplaceParams{\n      ResourceID: 0,\n      Rule: \"/folder/images/*.png\",\n      RuleType: 0,\n    },\n  )\n  if err != nil {\n    panic(err.Error())\n  }\n  fmt.Printf(\"%+v\\n\", cdnResourceRule.ID)\n}\n"}]}
    "patch": {"operationId": "patch-rule", "tags": ["Rules"], "summary": "Change rule", "parameters": ["$ref": "#/components/parameters/resource_id", "$ref": "#/components/parameters/rule_id"], "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/PatchRule"}}}}, "responses": {"200": {"description": "Successful.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/RuleResponse"}}}}, "400": {"description": "Filed to change the rule.", "content": {"application/json": {"schema": {"anyOf": ["$ref": "#/components/schemas/RuleNameAlreadyExistsError", "$ref": "#/components/schemas/RulePatternError", "$ref": "#/components/schemas/RulePatternAlreadyExistsError", "$ref": "#/components/schemas/JSONParseError", "$ref": "#/components/schemas/CommonValidationError"]}}}}, "404": {"description": "Rule is not found."}}, "x-codeSamples": [{"lang": "Python", "source": "from gcore import Gcore\n\nclient = Gcore(\n    api_key=\"My API Key\",\n)\ncdn_resource_rule = client.cdn.resources.rules.update(\n    rule_id=0,\n    resource_id=0,\n)\nprint(cdn_resource_rule.id)"}, {"lang": "Go", "source": "package main\n\nimport (\n  \"context\"\n  \"fmt\"\n\n  \"github.com/G-Core/gcore-go\"\n  \"github.com/G-Core/gcore-go/cdn\"\n  \"github.com/G-Core/gcore-go/option\"\n)\n\nfunc main() {\n  client := gcore.NewClient(\n    option.WithAPIKey(\"My API Key\"),\n  )\n  cdnResourceRule, err := client.Cdn.Resources.Rules.Update(\n    context.TODO(),\n    0,\n    cdn.ResourceRuleUpdateParams{\n      ResourceID: 0,\n    },\n  )\n  if err != nil {\n    panic(err.Error())\n  }\n  fmt.Printf(\"%+v\\n\", cdnResourceRule.ID)\n}\n"}]}
    "delete": {"operationId": "delete-rule", "tags": ["Rules"], "summary": "Delete rule", "description": "Delete the rule from the system permanently.\n\nNotes:\n- **Deactivation Requirement**: Set the `active` attribute to `false` before deletion.\n- **Irreversibility**: This action is irreversible. Once deleted, the rule cannot be recovered.", "parameters": ["$ref": "#/components/parameters/resource_id", "$ref": "#/components/parameters/rule_id"], "responses": {"204": {"description": "Successful."}, "400": {"description": "Failed to delete the rule.", "content": {"application/json": {"schema": {"anyOf": ["$ref": "#/components/schemas/ActiveInstanceDeletionProhibited"]}}}}, "404": {"description": "Rule is not found."}}, "x-codeSamples": [{"lang": "Python", "source": "from gcore import Gcore\n\nclient = Gcore(\n    api_key=\"My API Key\",\n)\nclient.cdn.resources.rules.delete(\n    rule_id=0,\n    resource_id=0,\n)"}, {"lang": "Go", "source": "package main\n\nimport (\n  \"context\"\n\n  \"github.com/G-Core/gcore-go\"\n  \"github.com/G-Core/gcore-go/cdn\"\n  \"github.com/G-Core/gcore-go/option\"\n)\n\nfunc main() {\n  client := gcore.NewClient(\n    option.WithAPIKey(\"My API Key\"),\n  )\n  err := client.Cdn.Resources.Rules.Delete(\n    context.TODO(),\n    0,\n    cdn.ResourceRuleDeleteParams{\n      ResourceID: 0,\n    },\n  )\n  if err != nil {\n    panic(err.Error())\n  }\n}\n"}]}
  "/cdn/resources/rule_templates":
    "get": {"operationId": "get-rule-templates-list", "tags": ["Rule templates"], "summary": "Get rule templates list", "responses": {"200": {"description": "Successful.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/RuleTemplateListResponse"}}}}}, "x-codeSamples": [{"lang": "Python", "source": "from gcore import Gcore\n\nclient = Gcore(\n    api_key=\"My API Key\",\n)\nrule_template_list = client.cdn.rule_templates.list()\nprint(rule_template_list)"}, {"lang": "Go", "source": "package main\n\nimport (\n  \"context\"\n  \"fmt\"\n\n  \"github.com/G-Core/gcore-go\"\n  \"github.com/G-Core/gcore-go/option\"\n)\n\nfunc main() {\n  client := gcore.NewClient(\n    option.WithAPIKey(\"My API Key\"),\n  )\n  ruleTemplateList, err := client.Cdn.RuleTemplates.List(context.TODO())\n  if err != nil {\n    panic(err.Error())\n  }\n  fmt.Printf(\"%+v\\n\", ruleTemplateList)\n}\n"}]}
    "post": {"operationId": "create-rule-template", "tags": ["Rule templates"], "summary": "Create rule template", "requestBody": {"required": true, "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CreateRuleTemplate"}}}}, "responses": {"201": {"description": "Created.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/RuleTemplateResponse"}}}}}, "x-codeSamples": [{"lang": "Python", "source": "from gcore import Gcore\n\nclient = Gcore(\n    api_key=\"My API Key\",\n)\nrule_template = client.cdn.rule_templates.create(\n    rule=\"/folder/images/*.png\",\n    rule_type=0,\n)\nprint(rule_template.id)"}, {"lang": "Go", "source": "package main\n\nimport (\n  \"context\"\n  \"fmt\"\n\n  \"github.com/G-Core/gcore-go\"\n  \"github.com/G-Core/gcore-go/cdn\"\n  \"github.com/G-Core/gcore-go/option\"\n)\n\nfunc main() {\n  client := gcore.NewClient(\n    option.WithAPIKey(\"My API Key\"),\n  )\n  ruleTemplate, err := client.Cdn.RuleTemplates.New(context.TODO(), cdn.RuleTemplateNewParams{\n    Rule: \"/folder/images/*.png\",\n    RuleType: 0,\n  })\n  if err != nil {\n    panic(err.Error())\n  }\n  fmt.Printf(\"%+v\\n\", ruleTemplate.ID)\n}\n"}]}
  "/cdn/resources/rule_templates/{rule_template_id}":
    "get": {"operationId": "get-rule-template-details", "tags": ["Rule templates"], "summary": "Get rule template details", "parameters": ["$ref": "#/components/parameters/rule_template_id"], "responses": {"200": {"description": "Successful.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/RuleTemplateResponse"}}}}}, "x-codeSamples": [{"lang": "Python", "source": "from gcore import Gcore\n\nclient = Gcore(\n    api_key=\"My API Key\",\n)\nrule_template = client.cdn.rule_templates.get(\n    0,\n)\nprint(rule_template.id)"}, {"lang": "Go", "source": "package main\n\nimport (\n  \"context\"\n  \"fmt\"\n\n  \"github.com/G-Core/gcore-go\"\n  \"github.com/G-Core/gcore-go/option\"\n)\n\nfunc main() {\n  client := gcore.NewClient(\n    option.WithAPIKey(\"My API Key\"),\n  )\n  ruleTemplate, err := client.Cdn.RuleTemplates.Get(context.TODO(), 0)\n  if err != nil {\n    panic(err.Error())\n  }\n  fmt.Printf(\"%+v\\n\", ruleTemplate.ID)\n}\n"}]}
    "put": {"operationId": "change-rule-template", "tags": ["Rule templates"], "summary": "Change rule template", "parameters": ["$ref": "#/components/parameters/rule_template_id"], "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/ChangeRuleTemplate"}}}}, "responses": {"200": {"description": "Successful.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/RuleTemplateResponse"}}}}}, "x-codeSamples": [{"lang": "Python", "source": "from gcore import Gcore\n\nclient = Gcore(\n    api_key=\"My API Key\",\n)\nrule_template = client.cdn.rule_templates.replace(\n    rule_template_id=0,\n    rule=\"/folder/images/*.png\",\n    rule_type=0,\n)\nprint(rule_template.id)"}, {"lang": "Go", "source": "package main\n\nimport (\n  \"context\"\n  \"fmt\"\n\n  \"github.com/G-Core/gcore-go\"\n  \"github.com/G-Core/gcore-go/cdn\"\n  \"github.com/G-Core/gcore-go/option\"\n)\n\nfunc main() {\n  client := gcore.NewClient(\n    option.WithAPIKey(\"My API Key\"),\n  )\n  ruleTemplate, err := client.Cdn.RuleTemplates.Replace(\n    context.TODO(),\n    0,\n    cdn.RuleTemplateReplaceParams{\n      Rule: \"/folder/images/*.png\",\n      RuleType: 0,\n    },\n  )\n  if err != nil {\n    panic(err.Error())\n  }\n  fmt.Printf(\"%+v\\n\", ruleTemplate.ID)\n}\n"}]}
    "patch": {"operationId": "patch-rule-template", "tags": ["Rule templates"], "summary": "Change rule template", "parameters": ["$ref": "#/components/parameters/rule_template_id"], "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/PatchRuleTemplate"}}}}, "responses": {"200": {"description": "Successful.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/RuleTemplateResponse"}}}}}, "x-codeSamples": [{"lang": "Python", "source": "from gcore import Gcore\n\nclient = Gcore(\n    api_key=\"My API Key\",\n)\nrule_template = client.cdn.rule_templates.update(\n    rule_template_id=0,\n)\nprint(rule_template.id)"}, {"lang": "Go", "source": "package main\n\nimport (\n  \"context\"\n  \"fmt\"\n\n  \"github.com/G-Core/gcore-go\"\n  \"github.com/G-Core/gcore-go/cdn\"\n  \"github.com/G-Core/gcore-go/option\"\n)\n\nfunc main() {\n  client := gcore.NewClient(\n    option.WithAPIKey(\"My API Key\"),\n  )\n  ruleTemplate, err := client.Cdn.RuleTemplates.Update(\n    context.TODO(),\n    0,\n    cdn.RuleTemplateUpdateParams{\n\n    },\n  )\n  if err != nil {\n    panic(err.Error())\n  }\n  fmt.Printf(\"%+v\\n\", ruleTemplate.ID)\n}\n"}]}
    "delete": {"operationId": "delete-rule-template", "tags": ["Rule templates"], "summary": "Delete rule template", "parameters": ["$ref": "#/components/parameters/rule_template_id"], "responses": {"204": {"description": "Successful."}}, "x-codeSamples": [{"lang": "Python", "source": "from gcore import Gcore\n\nclient = Gcore(\n    api_key=\"My API Key\",\n)\nclient.cdn.rule_templates.delete(\n    0,\n)"}, {"lang": "Go", "source": "package main\n\nimport (\n  \"context\"\n\n  \"github.com/G-Core/gcore-go\"\n  \"github.com/G-Core/gcore-go/option\"\n)\n\nfunc main() {\n  client := gcore.NewClient(\n    option.WithAPIKey(\"My API Key\"),\n  )\n  err := client.Cdn.RuleTemplates.Delete(context.TODO(), 0)\n  if err != nil {\n    panic(err.Error())\n  }\n}\n"}]}
  "/cdn/purge_statuses":
    "get": {"tags": ["Purge history"], "operationId": "get-purge-status-list", "summary": "Get purges history list", "description": "Get purges history.", "parameters": [{"in": "query", "name": "cname", "schema": {"type": "string"}, "description": "Purges associated with a specific resource CNAME.\n\nExample:\n\\* &cname=example.com"}, {"in": "query", "name": "status", "schema": {"type": "string", "description": "Purge with a certain status.\n\nPossible values:\n- **In progress**\n- **Successful**\n- **Failed**\n- **Status report disabled**"}}, {"in": "query", "name": "purge_type", "schema": {"type": "string", "description": "Purge requests with a certain purge type.\n\nPossible values:\n- **`purge_by_pattern`** - Purge by Pattern.\n- **`purge_by_url`** - Purge by URL.\n- **`purge_all`** - Purge All."}}, {"in": "query", "name": "from_created", "schema": {"type": "string"}, "description": "Start date and time of the requested time period (ISO 8601/RFC 3339 format, UTC.)\n\nExamples:\n\\* &`from_created`=2021-06-14T00:00:00Z\n\\* &`from_created`=2021-06-14T00:00:00.000Z"}, {"in": "query", "name": "to_created", "schema": {"type": "string"}, "description": "End date and time of the requested time period (ISO 8601/RFC 3339 format, UTC.)\n\nExamples:\n\\* &`to_created`=2021-06-15T00:00:00Z\n\\* &`to_created`=2021-06-15T00:00:00.000Z"}, {"in": "query", "name": "offset", "schema": {"type": "integer", "default": 0}, "description": "Number of purge requests in the response to skip starting from the beginning of the requested period."}, {"in": "query", "name": "limit", "schema": {"type": "integer", "default": 100, "maximum": 100, "x-stainless-skip": ["terraform"]}, "description": "Maximum number of purges in the response."}], "responses": {"200": {"description": "Successful.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/PurgeStatusesListResponse"}}}}}, "x-codeSamples": [{"lang": "Python", "source": "from gcore import Gcore\n\nclient = Gcore(\n    api_key=\"My API Key\",\n)\npage = client.cdn.list_purge_statuses()\npage = page.items[0]\nprint(page.purge_id)"}, {"lang": "Go", "source": "package main\n\nimport (\n  \"context\"\n  \"fmt\"\n\n  \"github.com/G-Core/gcore-go\"\n  \"github.com/G-Core/gcore-go/cdn\"\n  \"github.com/G-Core/gcore-go/option\"\n)\n\nfunc main() {\n  client := gcore.NewClient(\n    option.WithAPIKey(\"My API Key\"),\n  )\n  page, err := client.Cdn.ListPurgeStatuses(context.TODO(), cdn.CdnListPurgeStatusesParams{\n\n  })\n  if err != nil {\n    panic(err.Error())\n  }\n  fmt.Printf(\"%+v\\n\", page)\n}\n"}]}
  "/cdn/sslData":
    "get": {"operationId": "get-ssl-certificates-list", "tags": ["SSL certificates"], "summary": "Get SSL certificates list", "description": "Get information about SSL certificates.", "parameters": [{"in": "query", "name": "automated", "schema": {"type": "boolean"}, "description": "How the SSL certificate was issued.\n\nPossible values:\n- **true** – Certificate was issued automatically.\n- **false** – Certificate was added by a user."}, {"in": "query", "name": "validity_not_after_lte", "schema": {"type": "string"}, "description": "Date and time when the certificate become untrusted (ISO 8601/RFC 3339 format, UTC.)\n\nResponse will contain only certificates valid until the specified time."}, {"in": "query", "name": "resource_id", "schema": {"type": "integer"}, "description": "CDN resource ID for which certificates are requested."}], "responses": {"200": {"description": "Successful.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/GetSSLAnswerList"}}}}}, "x-codeSamples": [{"lang": "Python", "source": "from gcore import Gcore\n\nclient = Gcore(\n    api_key=\"My API Key\",\n)\nssl_detail_list = client.cdn.certificates.list()\nprint(ssl_detail_list)"}, {"lang": "Go", "source": "package main\n\nimport (\n  \"context\"\n  \"fmt\"\n\n  \"github.com/G-Core/gcore-go\"\n  \"github.com/G-Core/gcore-go/cdn\"\n  \"github.com/G-Core/gcore-go/option\"\n)\n\nfunc main() {\n  client := gcore.NewClient(\n    option.WithAPIKey(\"My API Key\"),\n  )\n  sslDetailList, err := client.Cdn.Certificates.List(context.TODO(), cdn.CertificateListParams{\n\n  })\n  if err != nil {\n    panic(err.Error())\n  }\n  fmt.Printf(\"%+v\\n\", sslDetailList)\n}\n"}]}
    "post": {"operationId": "add-ssl-certificate", "tags": ["SSL certificates"], "summary": "Add SSL certificate", "description": "Add an SSL certificate for content delivery over HTTPS protocol.\n\nEnter all strings of the certificate(s) and the private key into one string parameter.\nEach certificate and the private key in chain should be separated by the \"\\n\" symbol, as shown in the example.\n\nAdditionally, you can add a Let's Encrypt certificate. In this case, certificate and private key will be generated automatically after attaching this certificate to your CDN resource.", "requestBody": {"required": true, "content": {"application/json": {"schema": {"$ref": "#/components/schemas/AddSSL"}}}}, "responses": {"201": {"description": "Successful."}}, "x-codeSamples": [{"lang": "Python", "source": "from gcore import Gcore\n\nclient = Gcore(\n    api_key=\"My API Key\",\n)\nclient.cdn.certificates.create(\n    name=\"New certificate\",\n    ssl_certificate=\"-----BEGIN CERTIFICATE-----\\nMIIFWzCCBEOgAwIBAgISBK6qoNitg//89H/YJamujpWlMA0GCSqGSIb3DQEBCwUA\\nMEoxCzAJBgNVBAYTAlVTMRYwFAYDVQQKEw1MZXQncyBFbmNyeXB0MSMwIQYDVQQD\\nExpMZXQncyBFbmNyeXB0IEF1dGhvcml0eSBYMzAeFw0xODExMTMxMjQwMDJaFw0x\\nOTAyMTExMjQwMDJaMBwxGjAYBgNVBAMTEWNkbjIudG50LWNsdWIuY29tMIIBIjAN\\nBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAzaHExDEXNSf6ELS0WUR7qq8gs9cc\\nxx99sM2zs3Jld0twPmuldkVNe5xte/Hj03r4SesfOBczR7pn+t60YujPvUQDN8lx\\nWYpvRuetOneyf4gNPatwzR/W1GWGlahet1xPVYGrttqL4gCJeShIXvU4aCyzW941\\nPt0wCs+bg9u+59fXFkigWrWJPkwbR7bJ14XTStYynMbYLfCg+VPeGWj3d8wOhQcf\\nAD86o8TLTbVfK2BDXwS5S8Dgf5u8g+WvmVHYDIkYKCxcLj0jP61Y7uHoFbSg41oN\\nA9yPOa+0cYxA7U702V2WjxbfIeATYtNLZvH17lk+DYlQl8q3MLwguqZdgwIDAQAB\\niIqI2xquGONtHFDOKJvy1O2qYTVRtNRVZqhc1ol+mw==\\n-----END CERTIFICATE-----\\n-----BEGIN CERTIFICATE-----\\nMIIEkjCCA3qgAwIBAgIQCgFBQgAAAVOFc2oLheynCDANBgkqhkiG9w0BAQsFADA/\\nMSQwIgYDVQQKExtEaWdpdGFsIFNpZ25hdHVyZSBUcnVzdCBDby4xFzAVBgNVBAMT\\nDkRTVCBSb290IENBIFgzMB4XDTE2MDMxNzE2NDA0NloXDTIxMDMxNzE2NDA0Nlow\\nSjELMAkGA1UEBhMCVVMxFjAUBgNVBAoTDUxldCdzIEVuY3J5cHQxIzAhBgNVBAMT\\nGkxldCdzIEVuY3J5cHQgQXV0aG9yaXR5IFgzMIIBIjANBgkqhkiG9w0BAQEFAAOC\\nAQ8AMIIBCgKCAQEAnNMM8FrlLke3cl03g7NoYzDq1zUmGSXhvb418XCSL7e4S0EF\\nq6meNQhY7LEqxGiHC6PjdeTm86dicbp5gWAf15Gan/PQeGdxyGkOlZHP/uaZ6WA8\\nSMx+yk13EiSdRxta67nsHjcAHJyse6cF6s5K671B5TaYucv9bTyWaN8jKkKQDIZ0\\nKOqkqm57TH2H3eDJAkSnh6/DNFu0Qg==\\n-----END CERTIFICATE-----\\n\",\n    ssl_private_key=\"-----BEGIN PRIVATE KEY-----\\nMIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQDZcNCZiNNHfX2O\\ndZpf12mv2rAZwqGZBAdpox0wntEPK3JciQ7ZRloLJeHuCNIJs9MidnH7Xk8zveju\\nmab6HmfIzvMJAAm88OYWMFQRiYe1ggJEHMe7yYPQbtXwTqWDYdWmjPPma3Ujqqmb\\nhmVX2rsYILD7cUjS+e0Ucfqx3QODQj/aujTt1rS0gFhJ0soY5m+C6VimPCx4Bjyw\\n5rhtskJDRrfXxrIhVXOvSPFRyxDSfjt3win8vjhhZ3oFPWgrl9lVhn0zaB5hjDsd\\n-----END PRIVATE KEY-----\\n\",\n)"}, {"lang": "Go", "source": "package main\n\nimport (\n  \"context\"\n\n  \"github.com/G-Core/gcore-go\"\n  \"github.com/G-Core/gcore-go/cdn\"\n  \"github.com/G-Core/gcore-go/option\"\n)\n\nfunc main() {\n  client := gcore.NewClient(\n    option.WithAPIKey(\"My API Key\"),\n  )\n  err := client.Cdn.Certificates.New(context.TODO(), cdn.CertificateNewParams{\n    OfOwnCertificate: &cdn.CertificateNewParamsBodyOwnCertificate{\n      Name: \"New certificate\",\n      SslCertificate: \"-----BEGIN CERTIFICATE-----\\nMIIFWzCCBEOgAwIBAgISBK6qoNitg//89H/YJamujpWlMA0GCSqGSIb3DQEBCwUA\\nMEoxCzAJBgNVBAYTAlVTMRYwFAYDVQQKEw1MZXQncyBFbmNyeXB0MSMwIQYDVQQD\\nExpMZXQncyBFbmNyeXB0IEF1dGhvcml0eSBYMzAeFw0xODExMTMxMjQwMDJaFw0x\\nOTAyMTExMjQwMDJaMBwxGjAYBgNVBAMTEWNkbjIudG50LWNsdWIuY29tMIIBIjAN\\nBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAzaHExDEXNSf6ELS0WUR7qq8gs9cc\\nxx99sM2zs3Jld0twPmuldkVNe5xte/Hj03r4SesfOBczR7pn+t60YujPvUQDN8lx\\nWYpvRuetOneyf4gNPatwzR/W1GWGlahet1xPVYGrttqL4gCJeShIXvU4aCyzW941\\nPt0wCs+bg9u+59fXFkigWrWJPkwbR7bJ14XTStYynMbYLfCg+VPeGWj3d8wOhQcf\\nAD86o8TLTbVfK2BDXwS5S8Dgf5u8g+WvmVHYDIkYKCxcLj0jP61Y7uHoFbSg41oN\\nA9yPOa+0cYxA7U702V2WjxbfIeATYtNLZvH17lk+DYlQl8q3MLwguqZdgwIDAQAB\\niIqI2xquGONtHFDOKJvy1O2qYTVRtNRVZqhc1ol+mw==\\n-----END CERTIFICATE-----\\n-----BEGIN CERTIFICATE-----\\nMIIEkjCCA3qgAwIBAgIQCgFBQgAAAVOFc2oLheynCDANBgkqhkiG9w0BAQsFADA/\\
            nMSQwIgYDVQQKExtEaWdpdGFsIFNpZ25hdHVyZSBUcnVzdCBDby4xFzAVBgNVBAMT\\nDkRTVCBSb290IENBIFgzMB4XDTE2MDMxNzE2NDA0NloXDTIxMDMxNzE2NDA0Nlow\\nSjELMAkGA1UEBhMCVVMxFjAUBgNVBAoTDUxldCdzIEVuY3J5cHQxIzAhBgNVBAMT\\nGkxldCdzIEVuY3J5cHQgQXV0aG9yaXR5IFgzMIIBIjANBgkqhkiG9w0BAQEFAAOC\\nAQ8AMIIBCgKCAQEAnNMM8FrlLke3cl03g7NoYzDq1zUmGSXhvb418XCSL7e4S0EF\\nq6meNQhY7LEqxGiHC6PjdeTm86dicbp5gWAf15Gan/PQeGdxyGkOlZHP/uaZ6WA8\\nSMx+yk13EiSdRxta67nsHjcAHJyse6cF6s5K671B5TaYucv9bTyWaN8jKkKQDIZ0\\nKOqkqm57TH2H3eDJAkSnh6/DNFu0Qg==\\n-----END CERTIFICATE-----\\n\",\n      SslPrivateKey: \"-----BEGIN PRIVATE KEY-----\\nMIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQDZcNCZiNNHfX2O\\ndZpf12mv2rAZwqGZBAdpox0wntEPK3JciQ7ZRloLJeHuCNIJs9MidnH7Xk8zveju\\nmab6HmfIzvMJAAm88OYWMFQRiYe1ggJEHMe7yYPQbtXwTqWDYdWmjPPma3Ujqqmb\\nhmVX2rsYILD7cUjS+e0Ucfqx3QODQj/aujTt1rS0gFhJ0soY5m+C6VimPCx4Bjyw\\n5rhtskJDRrfXxrIhVXOvSPFRyxDSfjt3win8vjhhZ3oFPWgrl9lVhn0zaB5hjDsd\\n-----END PRIVATE KEY-----\\n\",\n    },\n  })\n  if err != nil {\n    panic(err.Error())\n  }\n}\n"}]}
  "/cdn/sslData/{ssl_id}":
    "get": {"operationId": "get-ssl-certificate-details", "tags": ["SSL certificates"], "summary": "Get SSL certificate details", "parameters": [{"in": "path", "name": "ssl_id", "description": "SSL certificate ID.", "required": true, "schema": {"type": "integer"}}], "responses": {"200": {"description": "Successful.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/GetSSLAnswer"}}}}}, "x-codeSamples": [{"lang": "Python", "source": "from gcore import Gcore\n\nclient = Gcore(\n    api_key=\"My API Key\",\n)\nssl_detail = client.cdn.certificates.get(\n    0,\n)\nprint(ssl_detail.id)"}, {"lang": "Go", "source": "package main\n\nimport (\n  \"context\"\n  \"fmt\"\n\n  \"github.com/G-Core/gcore-go\"\n  \"github.com/G-Core/gcore-go/option\"\n)\n\nfunc main() {\n  client := gcore.NewClient(\n    option.WithAPIKey(\"My API Key\"),\n  )\n  sslDetail, err := client.Cdn.Certificates.Get(context.TODO(), 0)\n  if err != nil {\n    panic(err.Error())\n  }\n  fmt.Printf(\"%+v\\n\", sslDetail.ID)\n}\n"}]}
    "put": {"operationId": "change-ssl-certificate", "tags": ["SSL certificates"], "summary": "Change SSL certificate", "parameters": [{"in": "path", "name": "ssl_id", "description": "SSL certificate ID.", "required": true, "schema": {"type": "integer"}}], "requestBody": {"required": true, "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CreateSSlPayload"}}}}, "responses": {"200": {"description": "Successful.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/GetSSLAnswer"}}}}}, "x-codeSamples": [{"lang": "Python", "source": "from gcore import Gcore\n\nclient = Gcore(\n    api_key=\"My API Key\",\n)\nssl_detail = client.cdn.certificates.replace(\n    ssl_id=0,\n    name=\"New certificate\",\n    ssl_certificate=\"-----BEGIN CERTIFICATE-----\\nMIIFWzCCBEOgAwIBAgISBK6qoNitg//89H/YJamujpWlMA0GCSqGSIb3DQEBCwUA\\nMEoxCzAJBgNVBAYTAlVTMRYwFAYDVQQKEw1MZXQncyBFbmNyeXB0MSMwIQYDVQQD\\nExpMZXQncyBFbmNyeXB0IEF1dGhvcml0eSBYMzAeFw0xODExMTMxMjQwMDJaFw0x\\nOTAyMTExMjQwMDJaMBwxGjAYBgNVBAMTEWNkbjIudG50LWNsdWIuY29tMIIBIjAN\\nBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAzaHExDEXNSf6ELS0WUR7qq8gs9cc\\nxx99sM2zs3Jld0twPmuldkVNe5xte/Hj03r4SesfOBczR7pn+t60YujPvUQDN8lx\\nWYpvRuetOneyf4gNPatwzR/W1GWGlahet1xPVYGrttqL4gCJeShIXvU4aCyzW941\\nPt0wCs+bg9u+59fXFkigWrWJPkwbR7bJ14XTStYynMbYLfCg+VPeGWj3d8wOhQcf\\nAD86o8TLTbVfK2BDXwS5S8Dgf5u8g+WvmVHYDIkYKCxcLj0jP61Y7uHoFbSg41oN\\nA9yPOa+0cYxA7U702V2WjxbfIeATYtNLZvH17lk+DYlQl8q3MLwguqZdgwIDAQAB\\niIqI2xquGONtHFDOKJvy1O2qYTVRtNRVZqhc1ol+mw==\\n-----END CERTIFICATE-----\\n-----BEGIN CERTIFICATE-----\\nMIIEkjCCA3qgAwIBAgIQCgFBQgAAAVOFc2oLheynCDANBgkqhkiG9w0BAQsFADA/\\nMSQwIgYDVQQKExtEaWdpdGFsIFNpZ25hdHVyZSBUcnVzdCBDby4xFzAVBgNVBAMT\\nDkRTVCBSb290IENBIFgzMB4XDTE2MDMxNzE2NDA0NloXDTIxMDMxNzE2NDA0Nlow\\nSjELMAkGA1UEBhMCVVMxFjAUBgNVBAoTDUxldCdzIEVuY3J5cHQxIzAhBgNVBAMT\\nGkxldCdzIEVuY3J5cHQgQXV0aG9yaXR5IFgzMIIBIjANBgkqhkiG9w0BAQEFAAOC\\nAQ8AMIIBCgKCAQEAnNMM8FrlLke3cl03g7NoYzDq1zUmGSXhvb418XCSL7e4S0EF\\nq6meNQhY7LEqxGiHC6PjdeTm86dicbp5gWAf15Gan/PQeGdxyGkOlZHP/uaZ6WA8\\nSMx+yk13EiSdRxta67nsHjcAHJyse6cF6s5K671B5TaYucv9bTyWaN8jKkKQDIZ0\\nKOqkqm57TH2H3eDJAkSnh6/DNFu0Qg==\\n-----END CERTIFICATE-----\\n\",\n    ssl_private_key=\"-----BEGIN PRIVATE KEY-----\\nMIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQDZcNCZiNNHfX2O\\ndZpf12mv2rAZwqGZBAdpox0wntEPK3JciQ7ZRloLJeHuCNIJs9MidnH7Xk8zveju\\nmab6HmfIzvMJAAm88OYWMFQRiYe1ggJEHMe7yYPQbtXwTqWDYdWmjPPma3Ujqqmb\\nhmVX2rsYILD7cUjS+e0Ucfqx3QODQj/aujTt1rS0gFhJ0soY5m+C6VimPCx4Bjyw\\n5rhtskJDRrfXxrIhVXOvSPFRyxDSfjt3win8vjhhZ3oFPWgrl9lVhn0zaB5hjDsd\\n-----END PRIVATE KEY-----\\n\",\n)\nprint(ssl_detail.id)"}, {"lang": "Go", "source": "package main\n\nimport (\n  \"context\"\n  \"fmt\"\n\n  \"github.com/G-Core/gcore-go\"\n  \"github.com/G-Core/gcore-go/cdn\"\n  \"github.com/G-Core/gcore-go/option\"\n)\n\nfunc main() {\n  client := gcore.NewClient(\n    option.WithAPIKey(\"My API Key\"),\n  )\n  sslDetail, err := client.Cdn.Certificates.Replace(\n    context.TODO(),\n    0,\n    cdn.CertificateReplaceParams{\n      Name: \"New certificate\",\n      SslCertificate: \"-----BEGIN CERTIFICATE-----\\nMIIFWzCCBEOgAwIBAgISBK6qoNitg//89H/YJamujpWlMA0GCSqGSIb3DQEBCwUA\\nMEoxCzAJBgNVBAYTAlVTMRYwFAYDVQQKEw1MZXQncyBFbmNyeXB0MSMwIQYDVQQD\\nExpMZXQncyBFbmNyeXB0IEF1dGhvcml0eSBYMzAeFw0xODExMTMxMjQwMDJaFw0x\\nOTAyMTExMjQwMDJaMBwxGjAYBgNVBAMTEWNkbjIudG50LWNsdWIuY29tMIIBIjAN\\nBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAzaHExDEXNSf6ELS0WUR7qq8gs9cc\\nxx99sM2zs3Jld0twPmuldkVNe5xte/Hj03r4SesfOBczR7pn+t60YujPvUQDN8lx\\nWYpvRuetOneyf4gNPatwzR/W1GWGlahet1xPVYGrttqL4gCJeShIXvU4aCyzW941\\nPt0wCs+bg9u+59fXFkigWrWJPkwbR7bJ14XTStYynMbYLfCg+VPeGWj3d8wOhQcf\\nAD86o8TLTbVfK2BDXwS5S8Dgf5u8g+WvmVHYDIkYKCxcLj0jP61Y7uHoFbSg41oN\\nA9yPOa+0cYxA7U702V2WjxbfIeATYtNLZvH17lk+DYlQl8q3MLwguqZdgwIDAQAB\\niIqI2xquGONtHFDOKJvy1O2qYTVRtNRVZqhc1ol+mw==\\n-----END CERTIFICATE-----\\n-----BEGIN CERTIFICATE-----\\nMIIEkjCCA3qgAwIBAgIQCgFBQgAAAVOFc2oLheynCDANBgkqhkiG9w0BAQsFADA/\\nMSQwIgYDVQQKExtEaWdpdGFsIFNpZ25hdHVyZSBUcnVzdCBDby4xFzAVBgNVBAMT\\nDkRTVCBSb290IENBIFgzMB4XDTE2MDMxNzE2NDA0NloXDTIxMDMxNzE2NDA0Nlow\\
            nSjELMAkGA1UEBhMCVVMxFjAUBgNVBAoTDUxldCdzIEVuY3J5cHQxIzAhBgNVBAMT\\nGkxldCdzIEVuY3J5cHQgQXV0aG9yaXR5IFgzMIIBIjANBgkqhkiG9w0BAQEFAAOC\\nAQ8AMIIBCgKCAQEAnNMM8FrlLke3cl03g7NoYzDq1zUmGSXhvb418XCSL7e4S0EF\\nq6meNQhY7LEqxGiHC6PjdeTm86dicbp5gWAf15Gan/PQeGdxyGkOlZHP/uaZ6WA8\\nSMx+yk13EiSdRxta67nsHjcAHJyse6cF6s5K671B5TaYucv9bTyWaN8jKkKQDIZ0\\nKOqkqm57TH2H3eDJAkSnh6/DNFu0Qg==\\n-----END CERTIFICATE-----\\n\",\n      SslPrivateKey: \"-----BEGIN PRIVATE KEY-----\\nMIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQDZcNCZiNNHfX2O\\ndZpf12mv2rAZwqGZBAdpox0wntEPK3JciQ7ZRloLJeHuCNIJs9MidnH7Xk8zveju\\nmab6HmfIzvMJAAm88OYWMFQRiYe1ggJEHMe7yYPQbtXwTqWDYdWmjPPma3Ujqqmb\\nhmVX2rsYILD7cUjS+e0Ucfqx3QODQj/aujTt1rS0gFhJ0soY5m+C6VimPCx4Bjyw\\n5rhtskJDRrfXxrIhVXOvSPFRyxDSfjt3win8vjhhZ3oFPWgrl9lVhn0zaB5hjDsd\\n-----END PRIVATE KEY-----\\n\",\n    },\n  )\n  if err != nil {\n    panic(err.Error())\n  }\n  fmt.Printf(\"%+v\\n\", sslDetail.ID)\n}\n"}]}
    "delete": {"operationId": "delete-ssl-certificate", "tags": ["SSL certificates"], "summary": "Delete SSL certificate", "parameters": [{"in": "path", "name": "ssl_id", "description": "SSL certificate ID", "required": true, "schema": {"type": "integer"}}], "responses": {"204": {"description": "Successful."}}, "x-codeSamples": [{"lang": "Python", "source": "from gcore import Gcore\n\nclient = Gcore(\n    api_key=\"My API Key\",\n)\nclient.cdn.certificates.delete(\n    0,\n)"}, {"lang": "Go", "source": "package main\n\nimport (\n  \"context\"\n\n  \"github.com/G-Core/gcore-go\"\n  \"github.com/G-Core/gcore-go/option\"\n)\n\nfunc main() {\n  client := gcore.NewClient(\n    option.WithAPIKey(\"My API Key\"),\n  )\n  err := client.Cdn.Certificates.Delete(context.TODO(), 0)\n  if err != nil {\n    panic(err.Error())\n  }\n}\n"}]}
  "/cdn/sslCertificates":
    "get": {"operationId": "get-trusted-ca-certificates-list", "tags": ["CA certificates"], "summary": "Get trusted CA certificates list", "description": "Get list of trusted CA certificates used to verify an origin.", "parameters": [{"in": "query", "name": "automated", "schema": {"type": "boolean"}, "description": "How the certificate was issued.\n\nPossible values:\n- **true** – Certificate was issued automatically.\n- **false** – Certificate was added by a user."}, {"in": "query", "name": "validity_not_after_lte", "schema": {"type": "string"}, "description": "Date and time when the certificate become untrusted (ISO 8601/RFC 3339 format, UTC.)\n\nResponse will contain certificates valid until the specified time."}, {"in": "query", "name": "resource_id", "schema": {"type": "integer"}, "description": "CDN resource ID for which the certificates are requested."}], "responses": {"200": {"description": "Successful.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ssl_ca_list_response"}}}}}, "x-codeSamples": [{"lang": "Python", "source": "from gcore import Gcore\n\nclient = Gcore(\n    api_key=\"My API Key\",\n)\nca_certificate_list = client.cdn.trusted_ca_certificates.list()\nprint(ca_certificate_list)"}, {"lang": "Go", "source": "package main\n\nimport (\n  \"context\"\n  \"fmt\"\n\n  \"github.com/G-Core/gcore-go\"\n  \"github.com/G-Core/gcore-go/cdn\"\n  \"github.com/G-Core/gcore-go/option\"\n)\n\nfunc main() {\n  client := gcore.NewClient(\n    option.WithAPIKey(\"My API Key\"),\n  )\n  caCertificateList, err := client.Cdn.TrustedCaCertificates.List(context.TODO(), cdn.TrustedCaCertificateListParams{\n\n  })\n  if err != nil {\n    panic(err.Error())\n  }\n  fmt.Printf(\"%+v\\n\", caCertificateList)\n}\n"}]}
    "post": {"operationId": "add-trusted-ca-certificate", "tags": ["CA certificates"], "summary": "Add trusted CA certificate", "description": "Add a trusted CA certificate to verify an origin.\n\nEnter all strings of the certificate in one string parameter. Each string should be separated by the \"\\n\" symbol.", "requestBody": {"required": true, "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ssl_ca_add"}}}}, "responses": {"201": {"description": "Successful.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ssl_ca_response"}}}}}, "x-codeSamples": [{"lang": "Python", "source": "from gcore import Gcore\n\nclient = Gcore(\n    api_key=\"My API Key\",\n)\nca_certificate = client.cdn.trusted_ca_certificates.create(\n    name=\"Example CA cert\",\n    ssl_certificate=\"-----BEGIN CERTIFICATE-----\\nMIIC0zCCAbugAwIBAgICA+gwDQYJKoZIhvcNAQELBQAwFjEUMBIGA1UEAwwLZXhh\\nbXBsZS5jb20wHhcNMjAwNjI2MTIwMzUzWhcNMjEwNjI2MTIwMzUzWjAWMRQwEgYD\\nVQQDDAtleGFtcGxlLmNvbTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEB\\nAN4nnSfTsMEnfPgL7rkbImxZAQoND+bpPoX8q16iXZz3fFfqdRk+uEIpU3Brleeg\\np0zrrT2eI3+c2h/PRod0Fam4TO6EcfwuboUFzV3j6yw6aWdfBjWZsWBR/FoqWLYq\\nb3UejN7yiTYNSiIy3zVpi9pnFM8N8qT+VGBrRDGef2v9JCzhsSSU7wAYM5HKZTp+\\nWHojjiyB2hOYqft7A2WlTEDmHFa5UcPHMRZKATUYI1T2TRVqLlSiE2mJ3dFRXGM2\\nZAS33J0NVUjkx3w8RmJ7DNflEFJt/6IXdfaokVgfza7LFarrQFQP/YURXEeJT7jm\\nDvKpZ/a8wu3ve6N4ykC+CBsCAwEAAaMrMCkwDwYDVR0TBAgwBgEB/wIBADAWBgNV\\nHREEDzANggtleGFtcGxlLmNvbTANBgkqhkiG9w0BAQsFAAOCAQEAovxY5lm89Eod\\nL8CH3dZzIH7nv8MXtwgpv2vth4PDq2btLS8xrqm2SsA/cV+DsbDjh5CxQLoDX+8V\\ng8NtY+ipOE0hdJAUo7UVlsxuAY4frkmLL1/RwpjZg+Z2NAxpR7xGWgoMn7CH481w\\nAOBypAuCxcfcyyAOttdS+YMRJnpL6z8/C3W0LGkNOs26Qhu1/U8lfz1f9F4XummD\\nu2SCmJsAd1PrL1shsyh4HtmFjuY698aTjYUDUleAnx7ytrGlZuLOIeoQi7tcsLJJ\\nTPMbxTLgGN2HEkdJerFRBNViuWvqioEyYlzZ3MshOCR2wsL4wrXrCF0Y3cNOYcIh\\nZ8z+wUAP2g==\\n-----END CERTIFICATE-----\\n\",\n)\nprint(ca_certificate.id)"}, {"lang": "Go", "source": "package main\n\nimport (\n  \"context\"\n  \"fmt\"\n\n  \"github.com/G-Core/gcore-go\"\n  \"github.com/G-Core/gcore-go/cdn\"\n  \"github.com/G-Core/gcore-go/option\"\n)\n\nfunc main() {\n  client := gcore.NewClient(\n    option.WithAPIKey(\"My API Key\"),\n  )\n  caCertificate, err := client.Cdn.TrustedCaCertificates.New(context.TODO(), cdn.TrustedCaCertificateNewParams{\n    Name: \"Example CA cert\",\n    SslCertificate: \"-----BEGIN CERTIFICATE-----\\nMIIC0zCCAbugAwIBAgICA+gwDQYJKoZIhvcNAQELBQAwFjEUMBIGA1UEAwwLZXhh\\nbXBsZS5jb20wHhcNMjAwNjI2MTIwMzUzWhcNMjEwNjI2MTIwMzUzWjAWMRQwEgYD\\nVQQDDAtleGFtcGxlLmNvbTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEB\\nAN4nnSfTsMEnfPgL7rkbImxZAQoND+bpPoX8q16iXZz3fFfqdRk+uEIpU3Brleeg\\np0zrrT2eI3+c2h/PRod0Fam4TO6EcfwuboUFzV3j6yw6aWdfBjWZsWBR/FoqWLYq\\nb3UejN7yiTYNSiIy3zVpi9pnFM8N8qT+VGBrRDGef2v9JCzhsSSU7wAYM5HKZTp+\\nWHojjiyB2hOYqft7A2WlTEDmHFa5UcPHMRZKATUYI1T2TRVqLlSiE2mJ3dFRXGM2\\nZAS33J0NVUjkx3w8RmJ7DNflEFJt/6IXdfaokVgfza7LFarrQFQP/YURXEeJT7jm\\nDvKpZ/a8wu3ve6N4ykC+CBsCAwEAAaMrMCkwDwYDVR0TBAgwBgEB/wIBADAWBgNV\\nHREEDzANggtleGFtcGxlLmNvbTANBgkqhkiG9w0BAQsFAAOCAQEAovxY5lm89Eod\\nL8CH3dZzIH7nv8MXtwgpv2vth4PDq2btLS8xrqm2SsA/cV+DsbDjh5CxQLoDX+8V\\ng8NtY+ipOE0hdJAUo7UVlsxuAY4frkmLL1/RwpjZg+Z2NAxpR7xGWgoMn7CH481w\\nAOBypAuCxcfcyyAOttdS+YMRJnpL6z8/C3W0LGkNOs26Qhu1/U8lfz1f9F4XummD\\nu2SCmJsAd1PrL1shsyh4HtmFjuY698aTjYUDUleAnx7ytrGlZuLOIeoQi7tcsLJJ\\nTPMbxTLgGN2HEkdJerFRBNViuWvqioEyYlzZ3MshOCR2wsL4wrXrCF0Y3cNOYcIh\\nZ8z+wUAP2g==\\n-----END CERTIFICATE-----\\n\",\n  })\n  if err != nil {\n    panic(err.Error())\n  }\n  fmt.Printf(\"%+v\\n\", caCertificate.ID)\n}\n"}]}
  "/cdn/sslCertificates/{id}":
    "get": {"operationId": "get-trusted-ca-certificate-details", "tags": ["CA certificates"], "summary": "Get trusted CA certificate details", "parameters": [{"name": "id", "in": "path", "description": "CA certificate ID.", "required": true, "schema": {"type": "integer"}}], "responses": {"200": {"description": "Successful.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ssl_ca_response"}}}}}, "x-codeSamples": [{"lang": "Python", "source": "from gcore import Gcore\n\nclient = Gcore(\n    api_key=\"My API Key\",\n)\nca_certificate = client.cdn.trusted_ca_certificates.get(\n    0,\n)\nprint(ca_certificate.id)"}, {"lang": "Go", "source": "package main\n\nimport (\n  \"context\"\n  \"fmt\"\n\n  \"github.com/G-Core/gcore-go\"\n  \"github.com/G-Core/gcore-go/option\"\n)\n\nfunc main() {\n  client := gcore.NewClient(\n    option.WithAPIKey(\"My API Key\"),\n  )\n  caCertificate, err := client.Cdn.TrustedCaCertificates.Get(context.TODO(), 0)\n  if err != nil {\n    panic(err.Error())\n  }\n  fmt.Printf(\"%+v\\n\", caCertificate.ID)\n}\n"}]}
    "put": {"operationId": "change-trusted-ca-certificate", "tags": ["CA certificates"], "summary": "Change trusted CA certificate", "parameters": [{"name": "id", "in": "path", "description": "CA certificate ID.", "required": true, "schema": {"type": "integer"}}], "requestBody": {"required": true, "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ssl_ca_change"}}}}, "responses": {"200": {"description": "Successful.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ssl_ca_response"}}}}}, "x-codeSamples": [{"lang": "Python", "source": "from gcore import Gcore\n\nclient = Gcore(\n    api_key=\"My API Key\",\n)\nca_certificate = client.cdn.trusted_ca_certificates.replace(\n    id=0,\n    name=\"Example CA cert 2\",\n)\nprint(ca_certificate.id)"}, {"lang": "Go", "source": "package main\n\nimport (\n  \"context\"\n  \"fmt\"\n\n  \"github.com/G-Core/gcore-go\"\n  \"github.com/G-Core/gcore-go/cdn\"\n  \"github.com/G-Core/gcore-go/option\"\n)\n\nfunc main() {\n  client := gcore.NewClient(\n    option.WithAPIKey(\"My API Key\"),\n  )\n  caCertificate, err := client.Cdn.TrustedCaCertificates.Replace(\n    context.TODO(),\n    0,\n    cdn.TrustedCaCertificateReplaceParams{\n      Name: \"Example CA cert 2\",\n    },\n  )\n  if err != nil {\n    panic(err.Error())\n  }\n  fmt.Printf(\"%+v\\n\", caCertificate.ID)\n}\n"}]}
    "delete": {"operationId": "delete-trusted-ca-certificate", "tags": ["CA certificates"], "summary": "Delete trusted CA certificate", "parameters": [{"name": "id", "in": "path", "description": "CA certificate ID.", "required": true, "schema": {"type": "integer"}}], "responses": {"204": {"description": "Successful."}}, "x-codeSamples": [{"lang": "Python", "source": "from gcore import Gcore\n\nclient = Gcore(\n    api_key=\"My API Key\",\n)\nclient.cdn.trusted_ca_certificates.delete(\n    0,\n)"}, {"lang": "Go", "source": "package main\n\nimport (\n  \"context\"\n\n  \"github.com/G-Core/gcore-go\"\n  \"github.com/G-Core/gcore-go/option\"\n)\n\nfunc main() {\n  client := gcore.NewClient(\n    option.WithAPIKey(\"My API Key\"),\n  )\n  err := client.Cdn.TrustedCaCertificates.Delete(context.TODO(), 0)\n  if err != nil {\n    panic(err.Error())\n  }\n}\n"}]}
  "/cdn/statistics/series":
    "get": {"operationId": "cdn-resource-statistics", "tags": ["CDN Statistics"], "summary": "CDN resource statistics", "description": "Get CDN resources statistics for up to 365 days starting today.", "parameters": [{"in": "query", "name": "service", "schema": {"type": "string"}, "required": true, "description": "Service name.\n\nPossible value:\n- CDN"}, {"in": "query", "name": "from", "schema": {"type": "string"}, "required": true, "description": "Beginning of the requested time period (ISO 8601/RFC 3339 format, UTC.)"}, {"in": "query", "name": "to", "schema": {"type": "string"}, "required": true, "description": "End of the requested time period (ISO 8601/RFC 3339 format, UTC.)"}, {"in": "query", "name": "granularity", "schema": {"type": "string"}, "required": true, "description": "Duration of the time blocks into which the data will be divided.\n\nPossible values:\n- **1m** - available only for up to 1 month in the past.\n- **5m**\n- **15m**\n- **1h**\n- **1d**"}, {"in": "query", "name": "metrics", "schema": {"type": "string"}, "required": true, "description": "Types of statistics data.\n\nPossible values:\n- **`upstream_bytes`** – Traffic in bytes from an origin server to CDN servers or to origin shielding when used.\n- **`sent_bytes`** – Traffic in bytes from CDN servers to clients.\n- **`shield_bytes`** – Traffic in bytes from origin shielding to CDN servers.\n- **`backblaze_bytes`** - Traffic in bytes from Backblaze origin.\n- **`total_bytes`** – `shield_bytes`, `upstream_bytes` and `sent_bytes` combined.\n- **`cdn_bytes`** – `sent_bytes` and `shield_bytes` combined.\n- **requests** – Number of requests to edge servers.\n- **`responses_2xx`** – Number of 2xx response codes.\n- **`responses_3xx`** – Number of 3xx response codes.\n- **`responses_4xx`** – Number of 4xx response codes.\n- **`responses_5xx`** – Number of 5xx response codes.\n- **`responses_hit`** – Number of responses with the header Cache: HIT.\n- **`responses_miss`** – Number of responses with the header Cache: MISS.\n- **`response_types`** – Statistics by content type. It returns a number of responses for content with different MIME types.\n- **`cache_hit_traffic_ratio`** – Formula: 1 - `upstream_bytes` / `sent_bytes`. We deduct the non-cached traffic from the total traffic amount.\n- **`cache_hit_requests_ratio`** – Formula: `responses_hit` / requests. The share of sending cached content.\n- **`shield_traffic_ratio`** – Formula: (`shield_bytes` - `upstream_bytes`) / `shield_bytes`. The efficiency of the Origin Shielding: how much more traffic is sent from the Origin Shielding than from the origin.\n- **`image_processed`** - Number of images transformed on the Image optimization service.\n- **`request_time`** - Time elapsed between the first bytes of a request were processed and logging after the last bytes were sent to a user.\n- **`upstream_response_time`** - Number of milliseconds it took to receive a response from an origin. If upstream `response_time_` contains several indications for one request (in case of more than 1 origin), we summarize them. In case of aggregating several queries, the average of this amount is calculated.\n\nMetrics **`upstream_response_time`** and **`request_time`** should be requested separately from other metrics"}, {"in": "query", "name": "group_by", "schema": {"type": "string"}, "description": "Output data grouping. \n\nPossible values:\n- **resource** – Data is grouped by CDN resources IDs.\n- **region** – Data is grouped by regions of CDN edge servers.\n- **country** – Data is grouped by countries of CDN edge servers.\n- **vhost** – Data is grouped by resources CNAMEs.\n\nTo request multiple values, use:\n\\* &`group_by`=region&`group_by`=resource"}, {"in": "query", "name": "countries", "schema": {"type": "string"}, "description": "Names of countries for which data should be displayed.\nEnglish short name from [ISO 3166 standard][1] without the definite article (\"the\") should be used.\n\n [1]: https://www.iso.org/obp/ui/#search/code/\n\nTo request multiple values, use:\n\\* &countries=france&countries=denmark"}, {
          "in": "query", "name": "regions", "schema": {"type": "string"}, "description": "Regions for which data is displayed.\n\nPossible values:\n- **na** – North America\n- **eu** – Europe\n- **cis** – Commonwealth of Independent States\n- **asia** – Asia\n- **au** – Australia\n- **latam** – Latin America\n- **me** – Middle East\n- **africa** - Africa\n- **sa** - South America"}, {"in": "query", "name": "resource", "schema": {"type": "integer"}, "description": "CDN resource IDs.\n\nTo request multiple values, use:\n\\* &resource=1&resource=2"}], "responses": {"200": {"description": "Successful.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/GetSeriesResponse"}}}}, "204": {"description": "There is no data for the requested time period."}, "400": {"description": "Bad Request. Required parameter is missing."}, "401": {"description": "Unauthorized. Provided credentials are invalid or your API token has expired."}, "403": {"description": "Forbidden. Access denied. You do not have enough rights."}, "500": {"description": "Server errors. Something is wrong on our side."}}, "x-codeSamples": [{"lang": "Python", "source": "from gcore import Gcore\n\nclient = Gcore(\n    api_key=\"My API Key\",\n)\nresource_usage_stats = client.cdn.statistics.get_resource_usage_series(\n    from_=\"from\",\n    granularity=\"granularity\",\n    metrics=\"metrics\",\n    service=\"service\",\n    to=\"to\",\n)\nprint(resource_usage_stats._1_example)"}, {"lang": "Go", "source": "package main\n\nimport (\n  \"context\"\n  \"fmt\"\n\n  \"github.com/G-Core/gcore-go\"\n  \"github.com/G-Core/gcore-go/cdn\"\n  \"github.com/G-Core/gcore-go/option\"\n)\n\nfunc main() {\n  client := gcore.NewClient(\n    option.WithAPIKey(\"My API Key\"),\n  )\n  resourceUsageStats, err := client.Cdn.Statistics.GetResourceUsageSeries(context.TODO(), cdn.StatisticGetResourceUsageSeriesParams{\n    From: \"from\",\n    Granularity: \"granularity\",\n    Metrics: \"metrics\",\n    Service: \"service\",\n    To: \"to\",\n  })\n  if err != nil {\n    panic(err.Error())\n  }\n  fmt.Printf(\"%+v\\n\", resourceUsageStats.Number1Example)\n}\n"}]}
  "/cdn/statistics/aggregate/stats":
    "get": {"operationId": "aggregated-statistics", "tags": ["CDN Statistics"], "summary": "Aggregated statistics", "description": "Get aggregated CDN resources statistics.\n\nRequest URL parameters should be added as a query string after the endpoint.\n\nAggregated data does not include data for the last two hours.", "parameters": [{"in": "query", "name": "service", "schema": {"type": "string"}, "required": true, "description": "Service name.\n\nPossible value:\n- CDN"}, {"in": "query", "name": "from", "schema": {"type": "string"}, "required": true, "description": "Beginning of the requested time period (ISO 8601/RFC 3339 format, UTC.)\n\nExamples:\n\\* &from=2018-11-01T00:00:00.000\n\\* &from=2018-11-01"}, {"in": "query", "name": "to", "schema": {"type": "string"}, "required": true, "description": "End of the requested time period (ISO 8601/RFC 3339 format, UTC.)\n\nExamples:\n\\* &to=2018-11-01T00:00:00.000\n\\* &to=2018-11-01"}, {"in": "query", "name": "metrics", "schema": {"type": "string"}, "required": true, "description": "Types of statistics data.\n\nPossible values:\n- **`upstream_bytes`** – Traffic in bytes from an origin server to CDN servers or to origin shielding when used.\n- **`sent_bytes`** – Traffic in bytes from CDN servers to clients.\n- **`shield_bytes`** – Traffic in bytes from origin shielding to CDN servers.\n- **`backblaze_bytes`** - Traffic in bytes from Backblaze origin.\n- **`total_bytes`** – `shield_bytes`, `upstream_bytes` and `sent_bytes` combined.\n- **`cdn_bytes`** – `sent_bytes` and `shield_bytes` combined.\n- **requests** – Number of requests to edge servers.\n- **`responses_2xx`** – Number of 2xx response codes.\n- **`responses_3xx`** – Number of 3xx response codes.\n- **`responses_4xx`** – Number of 4xx response codes.\n- **`responses_5xx`** – Number of 5xx response codes.\n- **`responses_hit`** – Number of responses with the header Cache: HIT.\n- **`responses_miss`** – Number of responses with the header Cache: MISS.\n- **`response_types`** – Statistics by content type. It returns a number of responses for content with different MIME types.\n- **`cache_hit_traffic_ratio`** – Formula: 1 - `upstream_bytes` / `sent_bytes`. We deduct the non-cached traffic from the total traffic amount.\n- **`cache_hit_requests_ratio`** – Formula: `responses_hit` / requests. The share of sending cached content.\n- **`shield_traffic_ratio`** – Formula: (`shield_bytes` - `upstream_bytes`) / `shield_bytes`. The efficiency of the Origin Shielding: how much more traffic is sent from the Origin Shielding than from the origin.\n- **`image_processed`** - Number of images transformed on the Image optimization service.\n- **`request_time`** - Time elapsed between the first bytes of a request were processed and logging after the last bytes were sent to a user.\n- **`upstream_response_time`** - Number of milliseconds it took to receive a response from an origin. If upstream `response_time_` contains several indications for one request (in case of more than 1 origin), we summarize them. In case of aggregating several queries, the average of this amount is calculated.\n- **`95_percentile`** - Represents the 95th percentile of network bandwidth usage in bytes per second. This means that 95% of the time, the network resource usage was below this value.\n- **`max_bandwidth`** - The maximum network bandwidth that was used during the selected time represented in bytes per second.\n- **`min_bandwidth`** - The minimum network bandwidth that was used during the selected time represented in bytes per second.\n\nMetrics **`upstream_response_time`** and **`request_time`** should be requested separately from other metrics"}, {"in": "query", "name": "group_by", "schema": {"type": "string"}, "description": "Output data grouping. \n\nPossible values:\n- **resource** – Data is grouped by CDN resources IDs.\n- **region** – Data is grouped by regions of CDN edge servers.\n- **country** – Data is grouped by countries of CDN edge servers.\n- **vhost** – Data is grouped by resources CNAME.\n\nTo request multiple values, use:\n\\* &`group_by`=region&`group_by`=resource"},
        {"in": "query", "name": "regions", "schema": {"type": "string"}, "description": "Regions for which data is displayed.\n\nPossible values:\n- **na** – North America\n- **eu** – Europe\n- **cis** – Commonwealth of Independent States\n- **asia** – Asia\n- **au** – Australia\n- **latam** – Latin America\n- **me** – Middle East\n- **africa** - Africa\n- **sa** - South America"}, {"in": "query", "name": "countries", "schema": {"type": "string"}, "description": "Names of countries for which data is displayed.\n\nEnglish short name from [ISO 3166 standard][1] without the definite article \"the\" should be used.\n\n [1]: https://www.iso.org/obp/ui/#search/code/\n\nTo request multiple values, use:\n\\* &countries=france&countries=denmark"}, {"in": "query", "name": "resource", "schema": {"type": "integer"}, "description": "CDN resources IDs by which statistics data is grouped.\n\nTo request multiple values, use:\n\\* &resource=1&resource=2\n\nIf CDN resource ID is not specified, data related to all CDN resources is returned."}, {"in": "query", "name": "flat", "schema": {"type": "boolean"}, "description": "The waу the parameters are arranged in the response.\n\nPossible values:\n- **true** – Flat structure is used.\n- **false** – Embedded structure is used (default.)"}], "responses": {"200": {"description": "Successful.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/GetAggregatedCDNStatisticsResponse"}}}}, "204": {"description": "There is no data for the requested time period."}, "400": {"description": "Bad Request. Required parameter is missing."}, "401": {"description": "Unauthorized. Provided credentials are invalid or your API token has expired."}, "403": {"description": "Forbidden. Access denied. You do not have enough rights."}, "500": {"description": "Server errors. Something is wrong on our side."}}, "x-codeSamples": [{"lang": "Python", "source": "from gcore import Gcore\n\nclient = Gcore(\n    api_key=\"My API Key\",\n)\nresource_aggregated_stats = client.cdn.statistics.get_resource_usage_aggregated(\n    from_=\"from\",\n    metrics=\"metrics\",\n    service=\"service\",\n    to=\"to\",\n)\nprint(resource_aggregated_stats.max_bandwidth)"}, {"lang": "Go", "source": "package main\n\nimport (\n  \"context\"\n  \"fmt\"\n\n  \"github.com/G-Core/gcore-go\"\n  \"github.com/G-Core/gcore-go/cdn\"\n  \"github.com/G-Core/gcore-go/option\"\n)\n\nfunc main() {\n  client := gcore.NewClient(\n    option.WithAPIKey(\"My API Key\"),\n  )\n  resourceAggregatedStats, err := client.Cdn.Statistics.GetResourceUsageAggregated(context.TODO(), cdn.StatisticGetResourceUsageAggregatedParams{\n    From: \"from\",\n    Metrics: \"metrics\",\n    Service: \"service\",\n    To: \"to\",\n  })\n  if err != nil {\n    panic(err.Error())\n  }\n  fmt.Printf(\"%+v\\n\", resourceAggregatedStats.MaxBandwidth)\n}\n"}]}
  "/cdn/statistics/shield_usage/series":
    "get": {"operationId": "origin-shielding-usage-statistics", "tags": ["CDN Statistics"], "summary": "Origin shielding usage statistics", "description": "Get origin shielding usage statistics for up to 365 days starting from today.\n\nRequest URL parameters should be added as a query string after the endpoint.", "parameters": [{"in": "query", "name": "from", "required": true, "schema": {"type": "string"}, "description": "Beginning of the requested time period (ISO 8601/RFC 3339 format, UTC.)"}, {"in": "query", "name": "to", "required": true, "schema": {"type": "string"}, "description": "End of the requested time period (ISO 8601/RFC 3339 format, UTC.)"}, {"in": "query", "name": "resource", "schema": {"type": "integer"}, "description": "CDN resources IDs by that statistics data is grouped.\n\nTo request multiple values, use:\n\\* &resource=1&resource=2"}], "responses": {"200": {"description": "Successful.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/GetPaidFeaturesSeriesStat"}}}}}, "x-codeSamples": [{"lang": "Python", "source": "from gcore import Gcore\n\nclient = Gcore(\n    api_key=\"My API Key\",\n)\nusage_series_stats = client.cdn.statistics.get_shield_usage_series(\n    from_=\"from\",\n    to=\"to\",\n)\nprint(usage_series_stats)"}, {"lang": "Go", "source": "package main\n\nimport (\n  \"context\"\n  \"fmt\"\n\n  \"github.com/G-Core/gcore-go\"\n  \"github.com/G-Core/gcore-go/cdn\"\n  \"github.com/G-Core/gcore-go/option\"\n)\n\nfunc main() {\n  client := gcore.NewClient(\n    option.WithAPIKey(\"My API Key\"),\n  )\n  usageSeriesStats, err := client.Cdn.Statistics.GetShieldUsageSeries(context.TODO(), cdn.StatisticGetShieldUsageSeriesParams{\n    From: \"from\",\n    To: \"to\",\n  })\n  if err != nil {\n    panic(err.Error())\n  }\n  fmt.Printf(\"%+v\\n\", usageSeriesStats)\n}\n"}]}
  "/cdn/statistics/shield_usage/aggregated":
    "get": {"operationId": "aggregated-origin-shielding-usage-statistics", "tags": ["CDN Statistics"], "summary": "Aggregated origin shielding usage statistics", "description": "The number of CDN resources that use origin shielding.\n\nRequest URL parameters should be added as a query string after the endpoint.", "parameters": [{"in": "query", "name": "from", "required": true, "schema": {"type": "string"}, "description": "Beginning of the requested time period (ISO 8601/RFC 3339 format, UTC.)"}, {"in": "query", "name": "to", "required": true, "schema": {"type": "string"}, "description": "End of the requested time period (ISO 8601/RFC 3339 format, UTC.)"}, {"in": "query", "name": "group_by", "schema": {"type": "string"}, "description": "Output data grouping. \n\nPossible value:\n- **resource** - Data is grouped by CDN resource."}, {"in": "query", "name": "resource", "schema": {"type": "integer"}, "description": "CDN resources IDs by that statistics data is grouped.\n\nTo request multiple values, use:\n\\* &resource=1&resource=2"}, {"in": "query", "name": "flat", "schema": {"type": "boolean"}, "description": "The waу parameters are arranged in the response.\n\nPossible values:\n- **true** – Flat structure is used.\n- **false** – Embedded structure is used (default.)"}], "responses": {"200": {"description": "Successful.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/GetShieldUsageAggregatedStat"}}}}, "204": {"description": "There is no data for the requested time period."}}, "x-codeSamples": [{"lang": "Python", "source": "from gcore import Gcore\n\nclient = Gcore(\n    api_key=\"My API Key\",\n)\nshield_aggregated_stats = client.cdn.statistics.get_shield_usage_aggregated(\n    from_=\"from\",\n    to=\"to\",\n)\nprint(shield_aggregated_stats._1_example)"}, {"lang": "Go", "source": "package main\n\nimport (\n  \"context\"\n  \"fmt\"\n\n  \"github.com/G-Core/gcore-go\"\n  \"github.com/G-Core/gcore-go/cdn\"\n  \"github.com/G-Core/gcore-go/option\"\n)\n\nfunc main() {\n  client := gcore.NewClient(\n    option.WithAPIKey(\"My API Key\"),\n  )\n  shieldAggregatedStats, err := client.Cdn.Statistics.GetShieldUsageAggregated(context.TODO(), cdn.StatisticGetShieldUsageAggregatedParams{\n    From: \"from\",\n    To: \"to\",\n  })\n  if err != nil {\n    panic(err.Error())\n  }\n  fmt.Printf(\"%+v\\n\", shieldAggregatedStats.Number1Example)\n}\n"}]}
  "/cdn/statistics/raw_logs_usage/series":
    "get": {"operationId": "raw-logs-usage-statistics", "tags": ["CDN Statistics"], "summary": "Raw logs usage statistics", "description": "Get raw logs usage statistics for up to 90 days starting today.\n\nRequest URL parameters should be added as a query string after the endpoint.", "parameters": [{"in": "query", "name": "from", "required": true, "schema": {"type": "string"}, "description": "Beginning of the requested time period (ISO 8601/RFC 3339 format, UTC.)\n\nExample:\n\\* &from=2020-01-01T00:00:00.000"}, {"in": "query", "name": "to", "required": true, "schema": {"type": "string"}, "description": "End of the requested time period (ISO 8601/RFC 3339 format, UTC.)\n\nExample:\n\\* &from=2020-01-01T00:00:00.000"}, {"in": "query", "name": "resource", "schema": {"type": "integer"}, "description": "CDN resources IDs by that statistics data is grouped.\n\nTo request multiple values, use:\n\\* &resource=1&resource=2"}], "responses": {"200": {"description": "Successful.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/GetPaidFeaturesSeriesStat"}}}}}, "x-codeSamples": [{"lang": "Python", "source": "from gcore import Gcore\n\nclient = Gcore(\n    api_key=\"My API Key\",\n)\nusage_series_stats = client.cdn.statistics.get_logs_usage_series(\n    from_=\"from\",\n    to=\"to\",\n)\nprint(usage_series_stats)"}, {"lang": "Go", "source": "package main\n\nimport (\n  \"context\"\n  \"fmt\"\n\n  \"github.com/G-Core/gcore-go\"\n  \"github.com/G-Core/gcore-go/cdn\"\n  \"github.com/G-Core/gcore-go/option\"\n)\n\nfunc main() {\n  client := gcore.NewClient(\n    option.WithAPIKey(\"My API Key\"),\n  )\n  usageSeriesStats, err := client.Cdn.Statistics.GetLogsUsageSeries(context.TODO(), cdn.StatisticGetLogsUsageSeriesParams{\n    From: \"from\",\n    To: \"to\",\n  })\n  if err != nil {\n    panic(err.Error())\n  }\n  fmt.Printf(\"%+v\\n\", usageSeriesStats)\n}\n"}]}
  "/cdn/statistics/raw_logs_usage/aggregated":
    "get": {"operationId": "aggregated-raw-logs-usage-statistics", "tags": ["CDN Statistics"], "summary": "Aggregated raw logs usage statistics", "description": "Get the number of CDN resources that used raw logs.\n\nRequest URL parameters should be added as a query string after the endpoint.", "parameters": [{"in": "query", "name": "from", "required": true, "schema": {"type": "string"}, "description": "Beginning of the requested time period (ISO 8601/RFC 3339 format, UTC.)"}, {"in": "query", "name": "to", "required": true, "schema": {"type": "string"}, "description": "End of the requested time period (ISO 8601/RFC 3339 format, UTC.)"}, {"in": "query", "name": "group_by", "schema": {"type": "string"}, "description": "Output data grouping. \n\nPossible value:\n- **resource** - Data is grouped by CDN resources."}, {"in": "query", "name": "resource", "schema": {"type": "integer"}, "description": "CDN resources IDs by that statistics data is grouped.\n\nTo request multiple values, use:\n\\* &resource=1&resource=2"}, {"in": "query", "name": "flat", "schema": {"type": "boolean"}, "description": "The waу parameters are arranged in the response.\n\nPossible values:\n- **true** – Flat structure is used.\n- **false** – Embedded structure is used (default.)"}], "responses": {"200": {"description": "Successful.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/GetRawLogsAggregatedStat"}}}}, "204": {"description": "There is no data for the requested time period."}}, "x-codeSamples": [{"lang": "Python", "source": "from gcore import Gcore\n\nclient = Gcore(\n    api_key=\"My API Key\",\n)\nlogs_aggregated_stats = client.cdn.statistics.get_logs_usage_aggregated(\n    from_=\"from\",\n    to=\"to\",\n)\nprint(logs_aggregated_stats._1_example)"}, {"lang": "Go", "source": "package main\n\nimport (\n  \"context\"\n  \"fmt\"\n\n  \"github.com/G-Core/gcore-go\"\n  \"github.com/G-Core/gcore-go/cdn\"\n  \"github.com/G-Core/gcore-go/option\"\n)\n\nfunc main() {\n  client := gcore.NewClient(\n    option.WithAPIKey(\"My API Key\"),\n  )\n  logsAggregatedStats, err := client.Cdn.Statistics.GetLogsUsageAggregated(context.TODO(), cdn.StatisticGetLogsUsageAggregatedParams{\n    From: \"from\",\n    To: \"to\",\n  })\n  if err != nil {\n    panic(err.Error())\n  }\n  fmt.Printf(\"%+v\\n\", logsAggregatedStats.Number1Example)\n}\n"}]}
  "/cdn/advanced/v1/capacity":
    "get": {"operationId": "get-network-capacity", "tags": ["CDN Statistics"], "summary": "Get network capacity", "description": "Get network capacity per country.", "responses": {"200": {"description": "Successful.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/GetNetworkCapacity"}}}}}, "x-codeSamples": [{"lang": "Python", "source": "from gcore import Gcore\n\nclient = Gcore(\n    api_key=\"My API Key\",\n)\nnetwork_capacity = client.cdn.network_capacity.list()\nprint(network_capacity)"}, {"lang": "Go", "source": "package main\n\nimport (\n  \"context\"\n  \"fmt\"\n\n  \"github.com/G-Core/gcore-go\"\n  \"github.com/G-Core/gcore-go/option\"\n)\n\nfunc main() {\n  client := gcore.NewClient(\n    option.WithAPIKey(\"My API Key\"),\n  )\n  networkCapacity, err := client.Cdn.NetworkCapacity.List(context.TODO())\n  if err != nil {\n    panic(err.Error())\n  }\n  fmt.Printf(\"%+v\\n\", networkCapacity)\n}\n"}]}
  "/cdn/advanced/v1/metrics":
    "post": {"operationId": "get-cdn-metrics", "tags": ["CDN Statistics"], "summary": "Get CDN metrics", "requestBody": {"required": true, "content": {"application/json": {"schema": {"$ref": "#/components/schemas/AdvancedMetricsRequest"}}}}, "responses": {"200": {"description": "Successful.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/AdvancedMetricsResponse"}}}}, "400": {"description": "Request body contains invalid parameters or values.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/AdvancedMetricsErrBadResponse"}}}}, "500": {"description": "Failed to get CDN metrics.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/AdvancedMetricsErrResponse"}}}}}, "x-codeSamples": [{"lang": "Python", "source": "from gcore import Gcore\n\nclient = Gcore(\n    api_key=\"My API Key\",\n)\ncdn_metrics = client.cdn.metrics.list(\n    from_=\"2021-06-14T00:00:00Z\",\n    metrics=[\"edge_status_2xx\", \"edge_status_3xx\", \"edge_status_4xx\", \"edge_status_5xx\"],\n    to=\"2021-06-15T00:00:00Z\",\n)\nprint(cdn_metrics.data)"}, {"lang": "Go", "source": "package main\n\nimport (\n  \"context\"\n  \"fmt\"\n\n  \"github.com/G-Core/gcore-go\"\n  \"github.com/G-Core/gcore-go/cdn\"\n  \"github.com/G-Core/gcore-go/option\"\n)\n\nfunc main() {\n  client := gcore.NewClient(\n    option.WithAPIKey(\"My API Key\"),\n  )\n  cdnMetrics, err := client.Cdn.Metrics.List(context.TODO(), cdn.MetricListParams{\n    From: \"2021-06-14T00:00:00Z\",\n    Metrics: []string{\"edge_status_2xx\", \"edge_status_3xx\", \"edge_status_4xx\", \"edge_status_5xx\"},\n    To: \"2021-06-15T00:00:00Z\",\n  })\n  if err != nil {\n    panic(err.Error())\n  }\n  fmt.Printf(\"%+v\\n\", cdnMetrics.Data)\n}\n"}]}
  "/cdn/advanced/v2/query":
    "post": {"operationId": "playground", "tags": ["Advanced analytics"], "summary": "Playground", "description": "You can explore the advanced analytics API via playground available at https://api.gcore.com/cdn/advanced/v2.\n\nWith the playground you can:\n- Test your queries.\n- Check API schema (by expanding the Documentation Explorer in the left sidebar).\n\nBefore using the playground, make sure that you are authenticated correctly by providing the Authorization\nheader with a valid token into the Headers section of the playground.\nFor more information about authentication, see the [Authentication](/docs/api-reference/overview#authentication) section.", "responses": {"200": {"description": "Successful.", "content": {"text/html": {"schema": {"type": "string"}}}}}}
  "/cdn/resources/{resource_id}/shielding_v2":
    "get": {"operationId": "get-origin-shielding-details", "tags": ["Origin shielding"], "summary": "Get origin shielding details", "description": "Get information about origin shielding.", "parameters": [{"in": "path", "name": "resource_id", "description": "CDN resource ID.", "required": true, "schema": {"type": "integer"}}], "responses": {"200": {"description": "Successful.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OriginShielding"}}}}}, "x-codeSamples": [{"lang": "Python", "source": "from gcore import Gcore\n\nclient = Gcore(\n    api_key=\"My API Key\",\n)\norigin_shielding = client.cdn.resources.shield.get(\n    0,\n)\nprint(origin_shielding.shielding_pop)"}, {"lang": "Go", "source": "package main\n\nimport (\n  \"context\"\n  \"fmt\"\n\n  \"github.com/G-Core/gcore-go\"\n  \"github.com/G-Core/gcore-go/option\"\n)\n\nfunc main() {\n  client := gcore.NewClient(\n    option.WithAPIKey(\"My API Key\"),\n  )\n  originShielding, err := client.Cdn.Resources.Shield.Get(context.TODO(), 0)\n  if err != nil {\n    panic(err.Error())\n  }\n  fmt.Printf(\"%+v\\n\", originShielding.ShieldingPop)\n}\n"}]}
    "put": {"operationId": "change-origin-shielding", "tags": ["Origin shielding"], "summary": "Change origin shielding", "description": "Change origin shielding settings or disabled origin shielding.", "parameters": [{"in": "path", "name": "resource_id", "description": "CDN resource ID.", "required": true, "schema": {"type": "integer"}}], "requestBody": {"required": true, "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OriginShielding"}}}}, "responses": {"200": {"description": "Successful.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ChangeOriginShieldingResponse"}}}}, "400": {"description": "Failed to change the origin shielding.", "content": {"application/json": {"schema": {"anyOf": ["$ref": "#/components/schemas/ShieldingPopNotExistsError", "$ref": "#/components/schemas/JSONParseError"]}}}}}, "x-codeSamples": [{"lang": "Python", "source": "from gcore import Gcore\n\nclient = Gcore(\n    api_key=\"My API Key\",\n)\norigin_shielding_updated = client.cdn.resources.shield.replace(\n    resource_id=0,\n)\nprint(origin_shielding_updated)"}, {"lang": "Go", "source": "package main\n\nimport (\n  \"context\"\n  \"fmt\"\n\n  \"github.com/G-Core/gcore-go\"\n  \"github.com/G-Core/gcore-go/cdn\"\n  \"github.com/G-Core/gcore-go/option\"\n)\n\nfunc main() {\n  client := gcore.NewClient(\n    option.WithAPIKey(\"My API Key\"),\n  )\n  originShieldingUpdated, err := client.Cdn.Resources.Shield.Replace(\n    context.TODO(),\n    0,\n    cdn.ResourceShieldReplaceParams{\n      OriginShielding: cdn.OriginShieldingParam{\n\n      },\n    },\n  )\n  if err != nil {\n    panic(err.Error())\n  }\n  fmt.Printf(\"%+v\\n\", originShieldingUpdated)\n}\n"}]}
  "/cdn/shieldingpop_v2":
    "get": {"operationId": "get-origin-shielding-locations", "tags": ["Origin shielding"], "summary": "Get origin shielding locations", "description": "Get information about all origin shielding locations available in the account.", "responses": {"200": {"description": "Successful.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/GetShieldingPOPV2"}}}}}, "x-codeSamples": [{"lang": "Python", "source": "from gcore import Gcore\n\nclient = Gcore(\n    api_key=\"My API Key\",\n)\nshields = client.cdn.shields.list()\nprint(shields)"}, {"lang": "Go", "source": "package main\n\nimport (\n  \"context\"\n  \"fmt\"\n\n  \"github.com/G-Core/gcore-go\"\n  \"github.com/G-Core/gcore-go/option\"\n)\n\nfunc main() {\n  client := gcore.NewClient(\n    option.WithAPIKey(\"My API Key\"),\n  )\n  shields, err := client.Cdn.Shields.List(context.TODO())\n  if err != nil {\n    panic(err.Error())\n  }\n  fmt.Printf(\"%+v\\n\", shields)\n}\n"}]}
  "/cdn/resources/{resource_id}/ssl/le/pre-validate":
    "post": {"operationId": "pre-validate-cdn-resources-before-issuing-lets-encrypt-certificate", "tags": ["Let's Encrypt certificates"], "summary": "Pre-validate CDN resource before issuing Let's Encrypt certificate", "description": "Check whether a Let's Encrypt certificate can be issued for the CDN resource.", "parameters": [{"in": "path", "name": "resource_id", "description": "CDN resource ID.", "required": true, "schema": {"type": "integer"}}], "responses": {"201": {"description": "Successful."}, "400": {"description": "Failed to validate the CDN resource.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/LECertificatePreValidationError"}}}}}, "x-codeSamples": [{"lang": "Python", "source": "from gcore import Gcore\n\nclient = Gcore(\n    api_key=\"My API Key\",\n)\nclient.cdn.resources.prevalidate_ssl_le_certificate(\n    0,\n)"}, {"lang": "Go", "source": "package main\n\nimport (\n  \"context\"\n\n  \"github.com/G-Core/gcore-go\"\n  \"github.com/G-Core/gcore-go/option\"\n)\n\nfunc main() {\n  client := gcore.NewClient(\n    option.WithAPIKey(\"My API Key\"),\n  )\n  err := client.Cdn.Resources.PrevalidateSslLeCertificate(context.TODO(), 0)\n  if err != nil {\n    panic(err.Error())\n  }\n}\n"}]}
  "/cdn/sslData/{cert_id}/force-retry":
    "post": {"operationId": "force-retry-issuance-of-lets-encrypt-certificate", "tags": ["Let's Encrypt certificates"], "summary": "Force retry issuance of Let's Encrypt certificate", "description": "Force retry issuance of Let's Encrypt certificate if the previous attempt was failed.", "parameters": [{"in": "path", "name": "cert_id", "description": "Let's Encrypt certificate ID.", "required": true, "schema": {"type": "integer"}}], "responses": {"201": {"description": "Successful. Issuing process has been started."}, "400": {"description": "Failed to start issuance process.", "content": {"application/json": {"schema": {"anyOf": ["$ref": "#/components/schemas/LECertificateIsNotAttachedToResourceError", "$ref": "#/components/schemas/NotLECertificateForceRetryError", "$ref": "#/components/schemas/LECertificateIssuingInProgressForceRetryError", "$ref": "#/components/schemas/NotActiveLECertificateIssueRequestForceRetryError"]}}}}, "429": {"description": "You have exceeded number of allowed force retry requests for your certificate."}}, "x-codeSamples": [{"lang": "Python", "source": "from gcore import Gcore\n\nclient = Gcore(\n    api_key=\"My API Key\",\n)\nclient.cdn.certificates.force_retry(\n    0,\n)"}, {"lang": "Go", "source": "package main\n\nimport (\n  \"context\"\n\n  \"github.com/G-Core/gcore-go\"\n  \"github.com/G-Core/gcore-go/option\"\n)\n\nfunc main() {\n  client := gcore.NewClient(\n    option.WithAPIKey(\"My API Key\"),\n  )\n  err := client.Cdn.Certificates.ForceRetry(context.TODO(), 0)\n  if err != nil {\n    panic(err.Error())\n  }\n}\n"}]}
  "/cdn/sslData/{cert_id}/renew":
    "post": {"operationId": "renew-lets-encrypt-certificate", "tags": ["Let's Encrypt certificates"], "summary": "Renew Let's Encrypt certificate", "description": "Renew free Let's Encrypt certificate for the CDN resource. It can take up to fifteen minutes.", "parameters": [{"in": "path", "name": "cert_id", "description": "Let's Encrypt certificate ID.", "required": true, "schema": {"type": "integer"}}], "responses": {"201": {"description": "Successful. Renewal process has been started."}, "400": {"description": "Failed to renew Let's Encrypt certificate.", "content": {"application/json": {"schema": {"anyOf": ["$ref": "#/components/schemas/LECertificateIsNotAttachedToResourceError", "$ref": "#/components/schemas/NotLECertificateSelectedError", "$ref": "#/components/schemas/LECertificateIsIssuingError"]}}}}}, "x-codeSamples": [{"lang": "Python", "source": "from gcore import Gcore\n\nclient = Gcore(\n    api_key=\"My API Key\",\n)\nclient.cdn.certificates.renew(\n    0,\n)"}, {"lang": "Go", "source": "package main\n\nimport (\n  \"context\"\n\n  \"github.com/G-Core/gcore-go\"\n  \"github.com/G-Core/gcore-go/option\"\n)\n\nfunc main() {\n  client := gcore.NewClient(\n    option.WithAPIKey(\"My API Key\"),\n  )\n  err := client.Cdn.Certificates.Renew(context.TODO(), 0)\n  if err != nil {\n    panic(err.Error())\n  }\n}\n"}]}
  "/cdn/sslData/{cert_id}/status":
    "get": {"operationId": "get-lets-encrypt-certificate-issuing-details", "tags": ["Let's Encrypt certificates"], "summary": "Get Let's Encrypt certificate issuing details", "description": "Get details about the latest Let's Encrypt certificate issuing attempt for the CDN resource. Returns attempts in all statuses.", "parameters": [{"in": "path", "name": "cert_id", "description": "Let's Encrypt certificate ID.", "required": true, "schema": {"type": "integer"}}, {"in": "query", "name": "exclude", "description": "Listed fields will be excluded from the response.", "required": false, "schema": {"type": "array", "items": {"type": "string"}}}], "responses": {"200": {"description": "Successful.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/LERequestStatusV2"}}}}, "400": {"description": "Failed to provide Let's encrypt certificate issuing details.", "content": {"application/json": {"schema": {"anyOf": ["$ref": "#/components/schemas/LECertificateIsNotAttachedToResourceError", "$ref": "#/components/schemas/LECertificateIssuingNotStartedYetError", "$ref": "#/components/schemas/NotLECertificateStatusError"]}}}}}, "x-codeSamples": [{"lang": "Python", "source": "from gcore import Gcore\n\nclient = Gcore(\n    api_key=\"My API Key\",\n)\nssl_request_status = client.cdn.certificates.get_status(\n    cert_id=0,\n)\nprint(ssl_request_status.id)"}, {"lang": "Go", "source": "package main\n\nimport (\n  \"context\"\n  \"fmt\"\n\n  \"github.com/G-Core/gcore-go\"\n  \"github.com/G-Core/gcore-go/cdn\"\n  \"github.com/G-Core/gcore-go/option\"\n)\n\nfunc main() {\n  client := gcore.NewClient(\n    option.WithAPIKey(\"My API Key\"),\n  )\n  sslRequestStatus, err := client.Cdn.Certificates.GetStatus(\n    context.TODO(),\n    0,\n    cdn.CertificateGetStatusParams{\n\n    },\n  )\n  if err != nil {\n    panic(err.Error())\n  }\n  fmt.Printf(\"%+v\\n\", sslRequestStatus.ID)\n}\n"}]}
  "/cdn/resources/{id}":
    "patch": {"operationId": "issue-lets-encrypt-certificate", "tags": ["Let's Encrypt certificates"], "summary": "Issue Let's Encrypt certificate", "parameters": [{"in": "path", "name": "id", "description": "CDN resource ID.", "required": true, "schema": {"type": "integer"}}], "description": "Issue free Let's Encrypt certificate for the CDN resource.\n\nBefore issuing the certificate, you need to:\n- Delegate your domain to our name servers, if the CDN resource accelerates the entire site.\n- Specify all CNAMEs in the personal zone, if the CDN resource accelerates only static resources.\n- Create a Let's Encrypt certificate as described [here](/docs/api-reference/cdn/ssl-certificates/add-ssl-certificate).\n\nLet's Encrypt certificates will be issued for all CNAMEs of the CDN resource.\nCertificate issuing can take up to fifteen minutes.\n\nBy default, we issue an ECDSA Let's Encrypt certificate.\nIf you need a **RSA** certificate, you can [enable](/docs/api-reference/cdn/cdn-resources/change-cdn-resource) the \"`use_rsa_le_cert`\" option for your CDN resource.\n\n**Notes:**\n\n- When a certificate is issued, it will be applied to the CDN resource and HTTPS will be enabled automatically.\n- Let's Encrypt certificate will be automatically renewed before the expiration date.\n- Let's Encrypt certificate will be automatically updated and applied when deleting or adding additional CNAMEs of the CDN resource.\n\n**Challenge types:**\n\nBy default, we issue Let's Encrypt certificates using the **HTTP-01** challenge.\n\nIf you prefer to use **DNS-01** challenge, you can enable the \"`use_dns01_le_challenge`\" option for your CDN resource.\nRead more about [challenge types][1].\n\nTo issue Let's Encrypt certificate using the **DNS-01** challenge the steps below should be done before request issuance:\n1. The DNS service is activated.\n2. `use_dns01_le_challenge` [option](/docs/api-reference/cdn/cdn-resources/change-cdn-resource) is enabled.\n3. `_acme-challenge` subdomain or resource's domain is delegated to our nameservers.\nTo find out the nameservers for your account, use the GET request `/dns/v2/platform/info`.\nUse retrieved `name_server_1` and `name_server_2` values from the settings object to create NS records.\n[1]: https://letsencrypt.org/docs/challenge-types/", "requestBody": {"required": true, "content": {"application/json": {"schema": {"$ref": "#/components/schemas/AttachLECert"}}}}, "responses": {"200": {"description": "Successful."}, "400": {"description": "Failed to issue the Let's Encrypt certificate.", "content": {"application/json": {"schema": {"anyOf": ["$ref": "#/components/schemas/LetsEncryptCertificateAlreadyAttached", "$ref": "#/components/schemas/WildcardResourceCnameSSLLEError"]}}}}}}
  "/cdn/resources/{res_id}":
    "patch": {"operationId": "revoke-lets-encrypt-certificate", "tags": ["Let's Encrypt certificates"], "summary": "Revoke Let's Encrypt certificate", "description": "Revoke Let's Encrypt certificate for the CDN resource. \n\nA revoked certificate can be reused for a this or another CDN resource.", "parameters": [{"in": "path", "name": "res_id", "description": "CDN resource ID.", "required": true, "schema": {"type": "integer"}}], "requestBody": {"required": true, "content": {"application/json": {"schema": {"$ref": "#/components/schemas/RevokeLECert"}}}}, "responses": {"200": {"description": "Successful."}}}
tags:
- {"name": "CDN service", "description": "Information about the current state of the CDN service in your account.", "x-displayName": "CDN service"}
- {"name": "CDN resources", "x-displayName": "CDN resources"}
- {"name": "Origins", "x-displayName": "Origins"}
- {"name": "Rules", "description": "Rules allow to set up custom settings for certain file types or paths.\nBy default, the rule inherits all options values from the related CDN resource.\n\nEach option in rule settings can be in one of the following states:\n- **Inherit** - Option is not added to the rule. Option inherits its value from the CDN resource settings. In this case, the option value is **null**.\n- **ON** - Option is added to the rule and enabled. Option values configured in the rule will override values from the CDN resource settings.\n- **OFF** - Option is added to the rule and disabled. Option will be turned off.", "x-displayName": "Rules"}
- {"name": "Rule templates", "x-displayName": "Rule templates"}
- {"name": "SSL certificates", "x-displayName": "SSL certificates"}
- {"name": "Let's Encrypt certificates", "x-displayName": "Let's Encrypt certificates"}
- {"name": "CA certificates", "x-displayName": "CA certificates"}
- {"name": "CDN activity logs", "description": "Get the history of users requests to CDN.\nIt contains requests made both via the API and via the control panel.\n\nThe following methods are not tracked in the activity logs:\n- HEAD\n- OPTIONS", "x-displayName": "CDN activity logs"}
- {"name": "Log forwarding", "x-displayName": "Log forwarding"}
- {"name": "Log viewer", "description": "Log viewer provides you with general information about CDN operation. This information does not contain all possible\nsets of fields and restricted by time. To receive full data, use Log forwarding.", "x-displayName": "Log viewer"}
- {"name": "Logs uploader", "description": "Logs uploader allows you to upload logs with desired format to desired storages.\n\nConsists of three main parts:\n- **Policies** - rules that define which logs are uploaded and how they are uploaded.\n- **Targets** - destinations where logs are uploaded.\n- **Configs** - combinations of logs uploader policies, targets and resources to which they are applied.", "x-displayName": "Logs uploader"}
- {"name": "Tools", "x-displayName": "Tools"}
- {"name": "CDN Statistics", "description": "Consumption statistics is updated in near real-time as a standard practice.\nHowever, the frequency of updates can vary, but they are typically available within a 24-hour period.\nExceptions, such as maintenance periods, may delay data beyond 24 hours until servers resume and fill in the missing statistics.", "x-displayName": "Statistics"}
- {"name": "Advanced analytics", "description": "Advanced analytics allows to get statistics about unique visitors, traffic, and requests for countries, directories, browsers, devices, and operation systems for up to 90 days starting from today.\n\nAdvanced analytics API is based on the [GraphQL framework](https://graphql.org/).\n\nAdvanced analytics API has one single endpoint:\n\n https://api.gcore.com/cdn/advanced/v2/query\n\nYou can pass the query parameters as a JSON object in the payload of a POST request to this endpoint.\nYou can use curl to make requests to the Advanced analytics API. Alternatively, you can use a GraphQL client\nto construct queries and pass requests to the Advanced analytics API.\n\nYou can write queries in GraphQL much like in SQL: specify the data set (CDN resource), the metrics\nto retrieve (such as unique visitors and traffic), and filter or group by dimensions (for example, a country).", "x-displayName": "Advanced analytics"}
- {"name": "Origin shielding", "x-displayName": "Origin shielding"}
- {"name": "IP addresses list", "x-displayName": "IP addresses list"}
- {"name": "Purge history", "x-displayName": "Purge history"}
x-tagGroups:
- {"name": "CDN API", "tags": ["CDN service", "CDN resources", "Origins", "Rules", "Rule templates", "SSL certificates", "Let's Encrypt certificates", "CA certificates", "CDN activity logs", "Log forwarding", "Log viewer", "Logs uploader", "Tools", "CDN Statistics", "Advanced analytics", "Origin shielding", "IP addresses list", "Purge history"]}
security: ["APIKey": []]
components:
  parameters:
    limit: {"name": "limit", "in": "query", "schema": {"type": "integer", "x-stainless-skip": ["terraform"]}, "description": "Maximum number of items in response."}
    token_id: {"name": "token_id", "in": "query", "schema": {"type": "integer"}, "description": "Permanent API token ID. Requests made with this token should be displayed."}
    status__in: {"in": "query", "name": "status__in", "schema": {"type": "string"}, "description": "List of status codes in the response. Values should be separated by a comma."}
    resource_id__ne: {"in": "query", "name": "resource_id__ne", "schema": {"type": "integer"}, "description": "ID of the requested CDN resource not equal to the specified value."}
    remote_ip_address: {"name": "remote_ip_address", "in": "query", "schema": {"type": "string"}, "description": "IP address or part of it from which requests are sent."}
    status__eq: {"in": "query", "name": "status__eq", "schema": {"type": "integer"}, "description": "Status code in the response equal to the specified value."}
    cache_status__eq: {"in": "query", "name": "cache_status__eq", "schema": {"type": "string"}, "description": "Caching status. Possible values: 'MISS', 'BYPASS', 'EXPIRED', 'STALE', 'PENDING', 'UPDATING', 'REVALIDATED', 'HIT', '-'."}
    cache_status__not_in: {"in": "query", "name": "cache_status__not_in", "schema": {"type": "string"}, "description": "List of caching statuses not equal to the specified values. Possible values: 'MISS', 'BYPASS', 'EXPIRED', 'STALE', 'PENDING', 'UPDATING', 'REVALIDATED', 'HIT', '-'. Values should be separated by a comma."}
    vp_enabled: {"in": "query", "name": "vp_enabled", "schema": {"type": "boolean"}, "description": "Defines whether the CDN resource is integrated with the Streaming platform.\n\nPossible values:\n- **true** - CDN resource is used for Streaming platform.\n- **false** - CDN resource is not used for Streaming platform."}
    resource_id: {"in": "path", "name": "resource_id", "description": "CDN resource ID.", "required": true, "schema": {"type": "integer"}}
    deleted: {"in": "query", "name": "deleted", "schema": {"type": "boolean"}, "description": "Defines whether a CDN resource has been deleted.\n\nPossible values:\n- **true** - CDN resource has been deleted.\n- **false** - CDN resource has not been deleted."}
    ID: {"name": "log_id", "in": "path", "required": true, "schema": {"$ref": "#/components/schemas/ID"}}
    suspend: {"in": "query", "name": "suspend", "schema": {"type": "boolean"}, "description": "Defines whether the CDN resource was automatically suspended by the system.\n\nPossible values:\n- **true** - CDN resource is selected for automatic suspension in the next 7 days.\n- **false** - CDN resource is not selected for automatic suspension."}
    resource_id__not_in: {"in": "query", "name": "resource_id__not_in", "schema": {"type": "string"}, "description": "List of IDs of the requested CDN resource not equal to the specified values. Values should be separated by a comma."}
    method__in: {"in": "query", "name": "method__in", "schema": {"type": "string"}, "description": "Request HTTP method. Possible values: 'CONNECT', 'DELETE', 'GET', 'HEAD', 'OPTIONS', 'PATCH', 'POST', 'PUT', 'TRACE'. Values should be separated by a comma."}
    datacenter__in: {"in": "query", "name": "datacenter__in", "schema": {"type": "string"}, "description": "List of data centers where request was processed. Values should be separated by a comma."}
    max_created: {"in": "query", "name": "max_created", "schema": {"type": "string"}, "description": "Most recent date of CDN resource creation for which CDN resources should be returned (ISO 8601/RFC 3339 format, UTC.)"}
    rule_id: {"in": "path", "name": "rule_id", "description": "Rule ID.", "required": true, "schema": {"type": "integer"}}
    size__not_in: {"in": "query", "name": "size__not_in", "schema": {"type": "string"}, "description": "List of response sizes in bytes not equal to the specified values. Values should be separated by"}
    status__lte: {"in": "query", "name": "status__lte", "schema": {"type": "integer"}, "description": "Status code in the response less than or equal to the specified value."}
    status__ne: {"in": "query", "name": "status__ne", "schema": {"type": "integer"}, "description": "Status code in the response not equal to the specified value."}
    size__eq: {"in": "query", "name": "size__eq", "schema": {"type": "integer"}, "description": "Response size in bytes equal to the specified value."}
    secondaryHostnames: {"in": "query", "name": "secondaryHostnames", "schema": {"type": "string"}, "description": "Additional delivery domains (CNAMEs) of the CDN resource."}
    status__lt: {"in": "query", "name": "status__lt", "schema": {"type": "integer"}, "description": "Status code in the response less than the specified value."}
    status: {"in": "query", "name": "status", "schema": {"type": "string", "enum": ["active", "processed", "suspended", "deleted"]}, "description": "CDN resource status."}
    max_requested_at: {"name": "max_requested_at", "in": "query", "schema": {"type": "string"}, "description": "End of the requested time period (ISO 8601/RFC 3339 format, UTC.)\n\nYou can specify a date with a time separated by a space, or just a date.\n\nExamples:\n\\* &`max_requested_at`=2021-05-05 12:00:00\n\\* &`max_requested_at`=2021-05-05"}
    method__ne: {"in": "query", "name": "method__ne", "schema": {"type": "string"}, "description": "Request HTTP method. Possible values: 'CONNECT', 'DELETE', 'GET', 'HEAD', 'OPTIONS', 'PATCH', 'POST', 'PUT', 'TRACE'."}
    resource_id__lte: {"in": "query", "name": "resource_id__lte", "schema": {"type": "integer"}, "description": "ID of the requested CDN resource less than or equal to the specified value."}
    user_id: {"name": "user_id", "in": "query", "schema": {"type": "integer"}, "description": "User ID."}
    min_requested_at: {"name": "min_requested_at", "in": "query", "schema": {"type": "string"}, "description": "Beginning of the requested time period (ISO 8601/RFC 3339 format, UTC.) \n\nYou can specify a date with a time separated by a space, or just a date.\n\nExamples:\n\\* &`min_requested_at`=2021-05-05 12:00:00\n\\* &`min_requested_at`=2021-05-05"}
    ordering: {"in": "query", "name": "ordering", "schema": {"type": "string"}, "description": "Sorting rules. \n\nPossible values:\n- **method** - Request HTTP method.\n- **`client_ip`** - IP address of the client who sent the request.\n- **status** - Status code in the response.\n- **size** - Response size in bytes.\n- **cname** - Custom domain of the requested resource.\n- **`resource_id`** - ID of the requested CDN resource.\n- **`cache_status`** - Caching status.\n- **datacenter** - Data center where request was processed.\n- **timestamp** - Date and time when the request was made.\n\nParameter may have multiple values separated by a comma. \n\nBy default, ascending sorting is applied. To sort in descending order, add '-' prefix.\n\nExample:\n\\* &ordering=-timestamp,status"}
    resource_id__gt: {"in": "query", "name": "resource_id__gt", "schema": {"type": "integer"}, "description": "ID of the requested CDN resource greater than the specified value."}
    method: {"name": "method", "in": "query", "schema": {"type": "string"}, "description": "HTTP method type of requests. \n\nUse upper case only.\n\nExample:\n\\* ?method=DELETE"}
    datacenter__not_in: {"in": "query", "name": "datacenter__not_in", "schema": {"type": "string"}, "description": "List of data centers where request was not processed. Values should be separated by a comma."}
    datacenter__eq: {"in": "query", "name": "datacenter__eq", "schema": {"type": "string"}, "description": "Data center where request was processed."}
    resource_id__eq: {"in": "query", "name": "resource_id__eq", "schema": {"type": "integer"}, "description": "ID of the requested CDN resource equal to the specified value."}
    cname__in: {"in": "query", "name": "cname__in", "schema": {"type": "string"}, "description": "List of custom domains of the requested CDN resource. Values should be separated by a comma."}
    sslEnabled: {"in": "query", "name": "sslEnabled", "schema": {"type": "boolean"}, "description": "Defines whether the HTTPS protocol is enabled for content delivery.\n\nPossible values:\n- **true** - HTTPS protocol is enabled for CDN resource.\n- **false** - HTTPS protocol is disabled for CDN resource."}
    size__ne: {"in": "query", "name": "size__ne", "schema": {"type": "integer"}, "description": "Response size in bytes not equal to the specified value."}
    status__gte: {"in": "query", "name": "status__gte", "schema": {"type": "integer"}, "description": "Status code in the response greater than or equal to the specified value."}
    sslData: {"in": "query", "name": "sslData", "schema": {"type": "integer"}, "description": "SSL certificate ID."}
    client_ip__in: {"in": "query", "name": "client_ip__in", "schema": {"type": "string"}, "description": "List of IP addresses of the clients who sent the request."}
    enabled: {"in": "query", "name": "enabled", "schema": {"type": "boolean"}, "description": "Enables or disables a CDN resource change by a user.\n\nPossible values:\n- **true** - CDN resource is enabled.\n- **false** - CDN resource is disabled."}
    client_ip__eq: {"in": "query", "name": "client_ip__eq", "schema": {"type": "string"}, "description": "IP address of the client who sent the request."}
    from: {"in": "query", "name": "from", "schema": {"type": "string"}, "required": true, "description": "Start date and time of the requested time period (ISO 8601/RFC 3339 format, UTC.)\n\nDifference between \"from\" and \"to\" cannot exceed 6 hours.\n\nExamples:\n\\* &from=2021-06-14T00:00:00Z\n\\* &from=2021-06-14T00:00:00.000Z"}
    size__gte: {"in": "query", "name": "size__gte", "schema": {"type": "integer"}, "description": "Response size in bytes greater than or equal to the specified value."}
    size__in: {"in": "query", "name": "size__in", "schema": {"type": "string"}, "description": "List of response sizes in bytes. Values should be separated by a comma."}
    cname__ne: {"in": "query", "name": "cname__ne", "schema": {"type": "string"}, "description": "Custom domain of the requested CDN resource not equal to the specified value."}
    client_ip__not_in: {"in": "query", "name": "client_ip__not_in", "schema": {"type": "string"}, "description": "List of IP addresses of the clients who did not send the request."}
    min_created: {"in": "query", "name": "min_created", "schema": {"type": "string"}, "description": "Earliest date of CDN resource creation for which CDN resources should be returned (ISO 8601/RFC 3339 format, UTC.)"}
    shielded: {"in": "query", "name": "shielded", "schema": {"type": "boolean"}, "description": "Defines whether origin shielding is enabled for the CDN resource.\n\nPossible values:\n- **true** - Origin shielding is enabled for the CDN resource.\n- **false** - Origin shielding is disabled for the CDN resource."}
    to: {"in": "query", "name": "to", "schema": {"type": "string"}, "required": true, "description": "End date and time of the requested time period (ISO 8601/RFC 3339 format, UTC.)\n\nDifference between \"from\" and \"to\" cannot exceed 6 hours.\n\nExamples:\n\\* &to=2021-06-15T00:00:00Z\n\\* &to=2021-06-15T00:00:00.000Z"}
    client_id: {"name": "client_id", "in": "query", "schema": {"type": "integer"}, "description": "Client ID."}
    cname__not_in: {"in": "query", "name": "cname__not_in", "schema": {"type": "string"}, "description": "List of custom domains of the requested CDN resource not equal to the specified values. Values should be separated by a comma."}
    rules: {"in": "query", "name": "rules", "schema": {"type": "string"}, "description": "Rule name or pattern."}
    size__lt: {"in": "query", "name": "size__lt", "schema": {"type": "integer"}, "description": "Response size in bytes less than the specified value."}
    resource_id__lt: {"in": "query", "name": "resource_id__lt", "schema": {"type": "integer"}, "description": "ID of the requested CDN resource less than the specified value."}
    sslData_in: {"in": "query", "name": "sslData_in", "schema": {"type": "integer"}, "description": "SSL certificates IDs.\n\nExample:\n- ?`sslData_in`=1643,1644,1652"}
    cname__eq: {"in": "query", "name": "cname__eq", "schema": {"type": "string"}, "description": "Custom domain of the requested CDN resource."}
    query-limit: {"in": "query", "name": "limit", "schema": {"type": "integer", "default": 100, "minimum": 1, "maximum": 1000, "x-stainless-skip": ["terraform"]}, "description": "Maximum number of log records in the response."}
    client_ip__ne: {"in": "query", "name": "client_ip__ne", "schema": {"type": "string"}, "description": "IP address of the client who did not send the request."}
    datacenter__ne: {"in": "query", "name": "datacenter__ne", "schema": {"type": "string"}, "description": "Data center where request was not processed."}
    status__not_in: {"in": "query", "name": "status__not_in", "schema": {"type": "string"}, "description": "List of status codes not in the response. Values should be separated by a comma."}
    cdn_path: {"name": "path", "in": "query", "schema": {"type": "string"}, "description": "Path that a requested URL should contain."}
    resource_id__in: {"in": "query", "name": "resource_id__in", "schema": {"type": "string"}, "description": "List of IDs of the requested CDN resource. Values should be separated by a comma."}
    size__gt: {"in": "query", "name": "size__gt", "schema": {"type": "integer"}, "description": "Response size in bytes greater than the specified value."}
    rule_template_id: {"in": "path", "name": "rule_template_id", "description": "Rule template ID.", "required": true, "schema": {"type": "integer"}}
    offset: {"name": "offset", "in": "query", "schema": {"type": "integer"}, "description": "Offset relative to the beginning of activity logs."}
    resource_id__gte: {"in": "query", "name": "resource_id__gte", "schema": {"type": "integer"}, "description": "ID of the requested CDN resource greater than or equal to the specified value."}
    shield_dc: {"in": "query", "name": "shield_dc", "schema": {"type": "string"}, "description": "Name of the origin shielding data center location."}
    fields: {"in": "query", "name": "fields", "schema": {"type": "string", "default": "timestamp,path,method,referer,user_agent,client_ip,status,size,cname,resource_id,cache_status,datacenter,sent_http_content_type,tcpinfo_rtt"}, "description": "A comma-separated list of returned fields. \n\nSupported fields are presented in the responses section.\n\nExample:\n\\* &fields=timestamp,path,status"}
    cache_status__in: {"in": "query", "name": "cache_status__in", "schema": {"type": "string"}, "description": "List of caching statuses. Possible values: 'MISS', 'BYPASS', 'EXPIRED', 'STALE', 'PENDING', 'UPDATING', 'REVALIDATED', 'HIT', '-'. Values should be separated by a comma."}
    status_code: {"name": "status_code", "in": "query", "schema": {"type": "integer"}, "description": "Status code returned in the response. \n\nSpecify the first numbers of a status code to get requests for a group of status codes.\n\nTo filter the activity logs by 4xx codes, use:\n\\* &`status_code`=4 -"}
    cname__contains: {"in": "query", "name": "cname__contains", "schema": {"type": "string"}, "description": "Part of the custom domain of the requested CDN resource. Minimum length is 3 characters."}
    query-offset: {"in": "query", "name": "offset", "schema": {"type": "integer", "default": 0}, "description": "Number of log records to skip starting from the beginning of the requested period."}
    size__lte: {"in": "query", "name": "size__lte", "schema": {"type": "integer"}, "description": "Response size in bytes less than or equal to the specified value."}
    cname: {"in": "query", "name": "cname", "schema": {"type": "string"}, "description": "Delivery domain (CNAME) of the CDN resource."}
    originGroup: {"in": "query", "name": "originGroup", "schema": {"type": "integer"}, "description": "Origin group ID."}
    status__gt: {"in": "query", "name": "status__gt", "schema": {"type": "integer"}, "description": "Status code in the response greater than the specified value."}
    cache_status__ne: {"in": "query", "name": "cache_status__ne", "schema": {"type": "string"}, "description": "Caching status not equal to the specified value. Possible values: 'MISS', 'BYPASS', 'EXPIRED', 'STALE', 'PENDING', 'UPDATING', 'REVALIDATED', 'HIT', '-'."}
    method__not_in: {"in": "query", "name": "method__not_in", "schema": {"type": "string"}, "description": "Request HTTP method. Possible values: 'CONNECT', 'DELETE', 'GET', 'HEAD', 'OPTIONS', 'PATCH', 'POST', 'PUT', 'TRACE'. Values should be separated by a comma."}
    method__eq: {"in": "query", "name": "method__eq", "schema": {"type": "string"}, "description": "Request HTTP method. Possible values: 'CONNECT', 'DELETE', 'GET', 'HEAD', 'OPTIONS', 'PATCH', 'POST', 'PUT', 'TRACE'."}
  schemas:
    SecondaryCnameAlreadyExistsError: {"title": "Hostname already exists", "type": "object", "properties": {"errors": {"type": "object", "properties": {"secondaryHostnames": {"type": "string", "description": "The additional CNAME is already used by another resource in our system. Try another additional CNAME or contact support."}}, "example": {"secondaryHostnames": "Hostname cdn1.example.com already exists."}}}}
    IncorrectPathsTypePurgeError: {"title": "Incorrect paths type provided", "type": "object", "properties": {"errors": {"type": "object", "properties": {"paths": {"type": "array", "description": "The field \"paths\" is incorrect. Must be an array of strings.", "items": {"type": "string"}, "example": ["Expected a list of items but got type \"str\"."]}}}}}
    LogsUploaderConfigResponse: {"properties": {"id": {"type": "integer", "readOnly": true}, "client_id": {"type": "integer", "description": "Client that owns the config.", "readOnly": true}, "created": {"type": "string", "format": "date-time", "readOnly": true, "description": "Time when the config was created."}, "updated": {"type": "string", "format": "date-time", "readOnly": true, "description": "Time when the config was updated."}, "enabled": {"type": "boolean", "description": "Enables or disables the config."}, "name": {"type": "string", "description": "Name of the config."}, "policy": {"type": "integer", "description": "ID of the policy that should be assigned to given config."}, "target": {"type": "integer", "description": "ID of the target to which logs should be uploaded."}, "for_all_resources": {"type": "boolean", "description": "If set to true, the config will be applied to all CDN resources.\nIf set to false, the config will be applied to the resources specified in the `resources` field."}, "resources": {"type": "array", "items": {"type": "integer"}, "description": "List of resource IDs to which the config should be applied."}, "status": {"allOf": ["$ref": "#/components/schemas/LogsUploaderValidationResponse", {"type": "object", "description": "Validation status of the logs uploader config."}]}}}
    OriginShielding: {"type": "object", "properties": {"shielding_pop": {"type": "integer", "nullable": true, "description": "Shielding location ID.\n\nIf origin shielding is disabled, the parameter value is **null**."}}, "example": {"shielding_pop": 4}}
    OriginSourceWithoutPathError: {"title": "Origin source contains slash", "type": "object", "properties": {"errors": {"type": "object", "properties": {"sources": {"type": "object", "properties": {"yourwebsite.com/path": {"type": "object", "properties": {"source": {"type": "array", "items": {"type": "string"}, "description": "The specified origin source contains a slash ('/'). Specify the source without slashes and try again.", "example": ["Source should be specified without path"]}}}}}}}}}
    AuthTypeInvalidValueError: {"title": "Auth type must be \"none\" or \"awsSignatureV4\"", "type": "object", "properties": {"errors": {"type": "object", "properties": {"auth_type": {"type": "array", "items": {"type": "string"}, "description": "Auth type must be \"none\" or \"awsSignatureV4\".", "example": ["Invalid value, should be in: ['none', 'awsSignatureV4']"]}}}}}
    CreateSSlPayload: {"title": "Own Certificate", "properties": {"name": {"type": "string", "description": "SSL certificate name. \n\nIt must be unique.", "example": "New certificate"}, "sslCertificate": {"type": "string", "description": "Public part of the SSL certificate. \n\nAll chain of the SSL certificate should be added.", "example": "-----BEGIN CERTIFICATE-----\nMIIFWzCCBEOgAwIBAgISBK6qoNitg//89H/YJamujpWlMA0GCSqGSIb3DQEBCwUA\nMEoxCzAJBgNVBAYTAlVTMRYwFAYDVQQKEw1MZXQncyBFbmNyeXB0MSMwIQYDVQQD\nExpMZXQncyBFbmNyeXB0IEF1dGhvcml0eSBYMzAeFw0xODExMTMxMjQwMDJaFw0x\nOTAyMTExMjQwMDJaMBwxGjAYBgNVBAMTEWNkbjIudG50LWNsdWIuY29tMIIBIjAN\nBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAzaHExDEXNSf6ELS0WUR7qq8gs9cc\nxx99sM2zs3Jld0twPmuldkVNe5xte/Hj03r4SesfOBczR7pn+t60YujPvUQDN8lx\nWYpvRuetOneyf4gNPatwzR/W1GWGlahet1xPVYGrttqL4gCJeShIXvU4aCyzW941\nPt0wCs+bg9u+59fXFkigWrWJPkwbR7bJ14XTStYynMbYLfCg+VPeGWj3d8wOhQcf\nAD86o8TLTbVfK2BDXwS5S8Dgf5u8g+WvmVHYDIkYKCxcLj0jP61Y7uHoFbSg41oN\nA9yPOa+0cYxA7U702V2WjxbfIeATYtNLZvH17lk+DYlQl8q3MLwguqZdgwIDAQAB\niIqI2xquGONtHFDOKJvy1O2qYTVRtNRVZqhc1ol+mw==\n-----END CERTIFICATE-----\n-----BEGIN CERTIFICATE-----\nMIIEkjCCA3qgAwIBAgIQCgFBQgAAAVOFc2oLheynCDANBgkqhkiG9w0BAQsFADA/\nMSQwIgYDVQQKExtEaWdpdGFsIFNpZ25hdHVyZSBUcnVzdCBDby4xFzAVBgNVBAMT\nDkRTVCBSb290IENBIFgzMB4XDTE2MDMxNzE2NDA0NloXDTIxMDMxNzE2NDA0Nlow\nSjELMAkGA1UEBhMCVVMxFjAUBgNVBAoTDUxldCdzIEVuY3J5cHQxIzAhBgNVBAMT\nGkxldCdzIEVuY3J5cHQgQXV0aG9yaXR5IFgzMIIBIjANBgkqhkiG9w0BAQEFAAOC\nAQ8AMIIBCgKCAQEAnNMM8FrlLke3cl03g7NoYzDq1zUmGSXhvb418XCSL7e4S0EF\nq6meNQhY7LEqxGiHC6PjdeTm86dicbp5gWAf15Gan/PQeGdxyGkOlZHP/uaZ6WA8\nSMx+yk13EiSdRxta67nsHjcAHJyse6cF6s5K671B5TaYucv9bTyWaN8jKkKQDIZ0\nKOqkqm57TH2H3eDJAkSnh6/DNFu0Qg==\n-----END CERTIFICATE-----\n"}, "sslPrivateKey": {"type": "string", "description": "Private key of the SSL certificate.", "example": "-----BEGIN PRIVATE KEY-----\nMIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQDZcNCZiNNHfX2O\ndZpf12mv2rAZwqGZBAdpox0wntEPK3JciQ7ZRloLJeHuCNIJs9MidnH7Xk8zveju\nmab6HmfIzvMJAAm88OYWMFQRiYe1ggJEHMe7yYPQbtXwTqWDYdWmjPPma3Ujqqmb\nhmVX2rsYILD7cUjS+e0Ucfqx3QODQj/aujTt1rS0gFhJ0soY5m+C6VimPCx4Bjyw\n5rhtskJDRrfXxrIhVXOvSPFRyxDSfjt3win8vjhhZ3oFPWgrl9lVhn0zaB5hjDsd\n-----END PRIVATE KEY-----\n"}, "validate_root_ca": {"type": "boolean", "description": "Defines whether to check the SSL certificate for a signature from a trusted certificate authority.\n\nPossible values:\n\n- **true** - SSL certificate must be verified to be signed by a trusted certificate authority.\n- **false** - SSL certificate will not be verified to be signed by a trusted certificate authority.", "example": true}}, "required": ["name", "sslCertificate", "sslPrivateKey"]}
    ssl_ca_change: {"type": "object", "properties": {"name": {"type": "string", "description": "CA certificate name. \n\nIt must be unique.", "example": "Example CA cert 2"}}, "required": ["name"]}
    OriginSourceNotResolvedError: {"title": "Origin source must be registered domain", "type": "object", "properties": {"errors": {"type": "object", "properties": {"sources": {"type": "object", "properties": {"your website.com": {"type": "object", "properties": {"source": {"type": "array", "items": {"type": "string"}, "description": "The specified origin source cannot be resolved. Please use a registered domain as the origin source.", "example": ["The domain name cannot be resolved. Please specify a valid domain name."]}}}}}}}}}
    RevokeLECert: {"type": "object", "properties": {"sslData": {"type": "integer", "description": "ID of Let's Encrypt certificate linked to the CDN resource.\n\nIt must be **null** to revoke Let's Encrypt certificate."}, "sslEnabled": {"type": "boolean", "description": "Defines whether the HTTPS protocol is enabled for CDN resource.\n\nPossible values:\n- **true** — HTTPS is enabled for the CDN resource. SSL certificate can be linked.\n- **false** — HTTPS is disabled for the CDN resource. SSL certificate cannot be linked.\n\nIt must be **false** to revoke the Let's Encrypt certificate.", "example": false}}, "required": ["sslData", "sslEnabled"]}
    AttachLECert: {"type": "object", "properties": {"sslData": {"type": "integer", "description": "ID of Let's Encrypt certificate obtained [here](/docs/api-reference/cdn/ssl-certificates/add-ssl-certificate).\n\nIt can be used only with \"sslEnabled\": true.", "example": 192}, "sslEnabled": {"type": "boolean", "description": "Defines whether the HTTPS protocol is enabled for CDN resource.\n\nPossible values:\n- **true** — HTTPS is enabled for the CDN resource. Certificate can be linked.\n- **false** — HTTPS is disabled for the CDN resource. Certificate cannot be linked.", "example": true}}, "required": ["sslData", "sslEnabled"]}
    CreateLogsUploaderConfig: {"properties": {"enabled": {"type": "boolean", "description": "Enables or disables the config.", "default": true}, "name": {"type": "string", "description": "Name of the config."}, "policy": {"type": "integer", "description": "ID of the policy that should be assigned to given config."}, "target": {"type": "integer", "description": "ID of the target to which logs should be uploaded."}, "for_all_resources": {"type": "boolean", "description": "If set to true, the config will be applied to all CDN resources.\nIf set to false, the config will be applied to the resources specified in the `resources` field.", "default": false}, "resources": {"type": "array", "items": {"type": "integer"}, "description": "List of resource IDs to which the config should be applied."}}, "required": ["name", "policy", "target"]}
    ChangeOriginGroupPut: {"anyOf": [{"type": "object", "title": "None Auth", "properties": {"name": {"$ref": "#/components/schemas/name"}, "use_next": {"$ref": "#/components/schemas/use_next"}, "proxy_next_upstream": {"$ref": "#/components/schemas/proxy_next_upstream"}, "auth_type": {"$ref": "#/components/schemas/auth_type_none"}, "sources": {"$ref": "#/components/schemas/sources", "example": [{"enabled": true, "source": "yourdomain.com", "backup": false}]}, "path": {"$ref": "#/components/schemas/path"}}, "required": ["name", "use_next", "sources", "auth_type", "path"]}, {"type": "object", "title": "AWS Signature V4", "properties": {"name": {"$ref": "#/components/schemas/name"}, "use_next": {"$ref": "#/components/schemas/use_next"}, "proxy_next_upstream": {"$ref": "#/components/schemas/proxy_next_upstream"}, "auth_type": {"$ref": "#/components/schemas/auth_type_aws"}, "auth": {"$ref": "#/components/schemas/auth"}, "path": {"$ref": "#/components/schemas/path"}}, "required": ["name", "use_next", "auth_type", "auth", "path"]}]}
    CreateResource: {"type": "object", "properties": {"cname": {"$ref": "#/components/schemas/cname"}, "originGroup": {"$ref": "#/components/schemas/originGroup"}, "origin": {"$ref": "#/components/schemas/origin"}, "active": {"$ref": "#/components/schemas/active"}, "originProtocol": {"$ref": "#/components/schemas/originProtocol"}, "name": {"$ref": "#/components/schemas/schemas-name"}, "description": {"$ref": "#/components/schemas/description"}, "secondaryHostnames": {"$ref": "#/components/schemas/secondaryHostnames"}, "sslEnabled": {"$ref": "#/components/schemas/sslEnabled"}, "sslData": {"$ref": "#/components/schemas/sslData"}, "proxy_ssl_enabled": {"$ref": "#/components/schemas/proxy_ssl_enabled"}, "proxy_ssl_ca": {"$ref": "#/components/schemas/proxy_ssl_ca"}, "proxy_ssl_data": {"$ref": "#/components/schemas/proxy_ssl_data"}, "primary_resource": {"$ref": "#/components/schemas/primary_resource"}, "waap_api_domain_enabled": {"$ref": "#/components/schemas/waap_api_domain_enabled"}, "options": {"type": "object", "$ref": "#/components/schemas/resource_options"}}, "required": ["cname", "originGroup", "origin"]}
    AdvancedMetricsRequest: {"type": "object", "required": ["metrics", "from", "to"], "minProperties": 1, "properties": {"metrics": {"type": "array", "minLength": 1, "example": ["edge_status_2xx", "edge_status_3xx", "edge_status_4xx", "edge_status_5xx"], "items": {"type": "string"}, "description": "Possible values:\n- **`edge_bandwidth`** - Bandwidth from client to CDN (bit/s.)\n- **`edge_requests`** - Number of requests per interval (requests/s.)\n- **`edge_requests_total`** - Total number of requests per interval.\n- **`edge_status_1xx`** - Number of 1xx status codes from edge.\n- **`edge_status_200`** - Number of 200 status codes from edge.\n- **`edge_status_204`** - Number of 204 status codes from edge.\n- **`edge_status_206`** - Number of 206 status codes from edge.\n- **`edge_status_2xx`** - Number of 2xx status codes from edge.\n- **`edge_status_301`** - Number of 301 status codes from edge.\n- **`edge_status_302`** - Number of 302 status codes from edge.\n- **`edge_status_304`** - Number of 304 status codes from edge.\n- **`edge_status_3xx`** - Number of 3xx status codes from edge.\n- **`edge_status_400`** - Number of 400 status codes from edge.\n- **`edge_status_401`** - Number of 401 status codes from edge.\n- **`edge_status_403`** - Number of 403 status codes from edge.\n- **`edge_status_404`** - Number of 404 status codes from edge.\n- **`edge_status_416`** - Number of 416 status codes from edge.\n- **`edge_status_429`** - Number of 429 status codes from edge.\n- **`edge_status_4xx`** - Number of 4xx status codes from edge.\n- **`edge_status_500`** - Number of 500 status codes from edge.\n- **`edge_status_501`** - Number of 501 status codes from edge.\n- **`edge_status_502`** - Number of 502 status codes from edge.\n- **`edge_status_503`** - Number of 503 status codes from edge.\n- **`edge_status_504`** - Number of 504 status codes from edge.\n- **`edge_status_505`** - Number of 505 status codes from edge.\n- **`edge_status_5xx`** - Number of 5xx status codes from edge.\n- **`edge_hit_ratio`** - Percent of cache hits (0.0 - 1.0).\n- **`edge_hit_bytes`** - Number of bytes sent back when cache hits.\n- **`origin_bandwidth`** - Bandwidth from CDN to Origin (bit/s.)\n- **`origin_requests`** - Number of requests per interval (requests/s.)\n- **`origin_status_1xx`** - Number of 1xx status from origin.\n- **`origin_status_200`** - Number of 200 status from origin.\n- **`origin_status_204`** - Number of 204 status from origin.\n- **`origin_status_206`** - Number of 206 status from origin.\n- **`origin_status_2xx`** - Number of 2xx status from origin.\n- **`origin_status_301`** - Number of 301 status from origin.\n- **`origin_status_302`** - Number of 302 status from origin.\n- **`origin_status_304`** - Number of 304 status from origin.\n- **`origin_status_3xx`** - Number of 3xx status from origin.\n- **`origin_status_400`** - Number of 400 status from origin.\n- **`origin_status_401`** - Number of 401 status from origin.\n- **`origin_status_403`** - Number of 403 status from origin.\n- **`origin_status_404`** - Number of 404 status from origin.\n- **`origin_status_416`** - Number of 416 status from origin.\n- **`origin_status_429`** - Number of 426 status from origin.\n- **`origin_status_4xx`** - Number of 4xx status from origin.\n- **`origin_status_500`** - Number of 500 status from origin.\n- **`origin_status_501`** - Number of 501 status from origin.\n- **`origin_status_502`** - Number of 502 status from origin.\n- **`origin_status_503`** - Number of 503 status from origin.\n- **`origin_status_504`** - Number of 504 status from origin.\n- **`origin_status_505`** - Number of 505 status from origin.\n- **`origin_status_5xx`** - Number of 5xx status from origin.\n- **`edge_download_speed`** - Download speed from edge in KB/s (includes only requests that status was in the range [200, 300].)\n- **`origin_download_speed`** - Download speed from origin in KB/s (includes only requests that status was in the range [200, 300].)"}, "from": {"type": "string", "example": "2021-06-14T00:00:00Z", "description": "Beginning period to
            fetch metrics (ISO 8601/RFC 3339 format, UTC.)\n\nExamples:\n\\* 2021-06-14T00:00:00Z\n\\* 2021-06-14T00:00:00.000Z\n\nThe total number of points, which is determined as the difference between \"from\" and \"to\" divided by \"granularity\", cannot exceed 1440.\nException: \"speed\" metrics are limited to 72 points."}, "to": {"type": "string", "example": "2021-06-15T00:00:00Z", "description": "Specifies ending period to fetch metrics (ISO 8601/RFC 3339 format, UTC)\n\nExamples:\n\\* 2021-06-15T00:00:00Z\n\\* 2021-06-15T00:00:00.000Z\n\nThe total number of points, which is determined as the difference between \"from\" and \"to\" divided by \"granularity\", cannot exceed 1440.\nException: \"speed\" metrics are limited to 72 points."}, "group_by": {"type": "array", "example": ["cname"], "items": {"type": "string"}, "description": "Output data grouping. \n\nPossible values:\n- **resource** - Data is grouped by CDN resource.\n- **cname** - Data is grouped by common names.\n- **region** – Data is grouped by regions (continents.) Available for \"speed\" metrics only.\n- **isp** - Data is grouped by ISP names. Available for \"speed\" metrics only."}, "granularity": {"type": "string", "default": "PT1M", "format": "P(n)Y(n)M(n)DT(n)H(n)M)", "example": "P1D", "description": "Duration of the time blocks into which the data is divided. The value must correspond to the ISO 8601 period format.\n\nExamples:\n\\* P1D\n\\* PT5M\n\nNotes:\n- The total number of points, which is determined as the difference between \"from\" and \"to\" divided by \"granularity\", cannot exceed 1440.\nException: \"speed\" metrics are limited to 72 points.\n- For \"speed\" metrics the value must be a multiple of 5."}, "filter_by": {"type": "array", "description": "Each item represents one filter statement.", "items": {"type": "object", "required": ["field", "op", "values"], "properties": {"field": {"type": "string", "example": "resource", "description": "Defines the parameters by that data can be filtered.\n\nPossible values:\n- **resource** - Data is filtered by CDN resource ID.\n- **cname** - Data is filtered by common name.\n- **region** - Data is filtered by region (continent.) Available for \"speed\" metrics only.\n- **isp** - Data is filtered by ISP name. Available for \"speed\" metrics only."}, "op": {"type": "string", "example": "eq", "description": "Comparison operator to be applied.\n\nPossible values:\n- **in** - 'IN' operator.\n- **`not_in`** - 'NOT IN' operator.\n- **gt** - '>' operator.\n- **gte** - '>=' operator.\n- **lt** - '<' operator.\n- **lte** - '<=' operator.\n- **eq** - '==' operator.\n- **ne** - '!=' operator.\n- **like** - 'LIKE' operator.\n- **`not_like`** - 'NOT LIKE' operator."}, "values": {"type": "array", "minLength": 1, "description": "Contains one or more values to be compared against.", "example": [1234], "items": {"anyOf": ["type": "number", "type": "string"]}}}}}}}
    OriginSourceMustBeUniqueError: {"title": "Origin source must be unique", "type": "object", "properties": {"errors": {"type": "object", "properties": {"sources": {"type": "object", "properties": {"yourwebsite.com": {"type": "object", "properties": {"source": {"type": "array", "items": {"type": "string"}, "description": "The specified origin source is already used in this origin group. Make sure that all specified origins have different sources.", "example": ["The field origin source must be unique inside group of origins."]}}}}}}}}}
    AuthS3TypeIsRequiredError: {"title": "Auth must have a s3 type", "type": "object", "properties": {"errors": {"type": "object", "properties": {"auth": {"type": "object", "properties": {"s3_type": {"type": "array", "items": {"type": "string"}, "description": "S3 type is a mandatory field. Please specify it.", "example": ["This field is required."]}}}}}}}
    LogsUploaderTargetListResponse: {"type": "array", "items": {"$ref": "#/components/schemas/LogsUploaderTargetResponse"}}
    ID: {"type": "integer", "description": "Activity logs record ID."}
    OriginGroupIsEmptyError: {"title": "Origin group must contain origins", "type": "object", "properties": {"errors": {"type": "object", "properties": {"source": {"type": "array", "items": {"type": "string"}, "description": "Origin group cannot be created without origins. Please add at least one origin to create the origin group.", "example": ["Origin Group has to have at least one origin source."]}}}}}
    secondaryHostnames: {"type": "array", "description": "Additional delivery domains (CNAMEs) that will be used to deliver content via the CDN. \n\nUp to ten additional CNAMEs are possible.", "items": {"type": "string", "format": "domain"}, "example": ["first.example.com", "second.example.com"]}
    GetPublicNetworkList: {"type": "object", "properties": {"addresses": {"type": "array", "description": "List of IPv4 networks.", "items": {"type": "string"}, "example": ["185.239.155.0/24"]}, "addresses_v6": {"type": "array", "description": "List of IPv6 networks.", "items": {"type": "string"}, "example": ["2a03:90c0:391:2801::/112"]}}}
    GetSSLAnswer: {"type": "object", "properties": {"id": {"type": "integer", "description": "SSL certificate ID.", "example": 42}, "deleted": {"type": "boolean", "description": "Defines whether the certificate has been deleted. Parameter is **deprecated**.\n\nPossible values:\n- **true** - Certificate has been deleted.\n- **false** - Certificate has not been deleted.", "example": false}, "cert_issuer": {"type": "string", "description": "Name of the certification center issued the SSL certificate.", "example": "Some certification center"}, "cert_subject_cn": {"type": "string", "description": "Domain name that the SSL certificate secures.", "example": "mydomain.name"}, "cert_subject_alt": {"type": "string", "description": "Alternative domain names that the SSL certificate secures."}, "validity_not_before": {"type": "string", "description": "Date when certificate become valid (ISO 8601/RFC 3339 format, UTC.)", "example": "2016-09-17T18:06:01Z"}, "validity_not_after": {"type": "string", "description": "Date when certificate become untrusted (ISO 8601/RFC 3339 format, UTC.)", "example": "2017-08-21T11:02:00Z"}, "sslCertificateChain": {"type": "string", "description": "Parameter is **deprecated**."}, "hasRelatedResources": {"type": "boolean", "description": "Defines whether the SSL certificate is used by a CDN resource.\n\nPossible values:\n- **true** - Certificate is used by a CDN resource.\n- **false** - Certificate is not used by a CDN resource.", "example": true}, "name": {"type": "string", "description": "SSL certificate name.", "example": "Some certificate"}, "automated": {"type": "boolean", "description": "How the SSL certificate was issued.\n\nPossible values:\n- **true** - Certificate was issued automatically.\n- **false** - Certificate was added by a use.", "example": false}}}
    sslData: {"type": "integer", "nullable": true, "default": null, "description": "ID of the SSL certificate linked to the CDN resource. \n\nCan be used only with `\"sslEnabled\": true`.", "example": 192}
    RulePatternError: {"title": "Rule template is invalid", "type": "object", "properties": {"errors": {"type": "object", "properties": {"rule": {"type": "array", "description": "The specified pattern is not a valid regular expression. Please, check the specified pattern via https://regex101.com.", "items": {"type": "string"}, "example": ["Rule should be a valid regular expression - check it via https://regex101.com."]}}}}}
    AuthS3SecretAccessKeyIsRequiredError: {"title": "Auth must have a s3 secret access key", "type": "object", "properties": {"errors": {"type": "object", "properties": {"auth": {"type": "object", "properties": {"s3_secret_access_key": {"type": "array", "items": {"type": "string"}, "description": "S3 secret access key is a mandatory field. Please specify it.", "example": ["This field is required."]}}}}}}}
    AuthInvalidValueError: {"title": "Auth must be a dictionary", "type": "object", "properties": {"errors": {"type": "object", "properties": {"auth": {"type": "array", "items": {"type": "string"}, "description": "Auth must be a dictionary.", "example": ["Invalid data. Expected a dictionary, but got list."]}}}}}
    AuthS3AccessKeyIdIsRequiredError: {"title": "Auth must have a s3 access key id", "type": "object", "properties": {"errors": {"type": "object", "properties": {"auth": {"type": "object", "properties": {"s3_access_key_id": {"type": "array", "items": {"type": "string"}, "description": "S3 access key id is a mandatory field. Please specify it.", "example": ["This field is required."]}}}}}}}
    AuthS3AmazonSecretAccessKeyIsInvalidError: {"title": "Auth must have a s3 secret access key with 40 alpha-numeric-plus-slash characters", "type": "object", "properties": {"errors": {"type": "object", "properties": {"auth": {"type": "object", "properties": {"s3_secret_access_key": {"type": "array", "items": {"type": "string"}, "description": "The specified s3 access key id is not equal 40 characters. Please lengthen the name and try again.", "example": ["Only 40 alpha-numeric-plus-slash characters are allowed."]}}}}}}}
    OriginSourceIsRequiredError: {"title": "Origin must have a source", "type": "object", "properties": {"errors": {"type": "object", "properties": {"source": {"type": "array", "items": {"type": "string"}, "description": "Source is a mandatory field. Please specify it.", "example": ["This field is required."]}}}}}
    PathsNotProvidedPurgeError: {"title": "Paths not provided", "type": "object", "properties": {"errors": {"type": "object", "properties": {"paths": {"type": "array", "description": "The field \"paths\" is not set. Define \"paths\" field in request body.", "items": {"type": "string"}, "example": ["This field is required."]}}}}}
    CommonValidationError: {"title": "Other Errors", "type": "object", "properties": {"errors": {"type": "object", "description": "This object contains error descriptions per field from your request.", "properties": {"field_name": {"type": "array", "description": "Error list for specific field.", "items": {"type": "string", "description": "Error description"}, "example": ["Error description."]}}}}}
    PatchLogsUploaderConfig: {"properties": {"enabled": {"type": "boolean", "description": "Enables or disables the config."}, "name": {"type": "string", "description": "Name of the config."}, "policy": {"type": "integer", "description": "ID of the policy that should be assigned to given config."}, "target": {"type": "integer", "description": "ID of the target to which logs should be uploaded."}, "for_all_resources": {"type": "boolean", "description": "If set to true, the config will be applied to all CDN resources.\nIf set to false, the config will be applied to the resources specified in the `resources` field."}, "resources": {"type": "array", "items": {"type": "integer"}, "description": "List of resource IDs to which the config should be applied."}}}
    GetLogsResponse: {"type": "object", "properties": {"data": {"type": "array", "description": "Contains requested logs.", "items": {"type": "object", "properties": {"timestamp": {"type": "integer", "description": "Log timestamp.", "example": 1633914371}, "client_ip": {"type": "string", "description": "IP address from that the request was received.", "example": "1.1.1.1"}, "cname": {"type": "string", "description": "CDN resource custom domain.", "example": "test.domain.com"}, "resource_id": {"type": "integer", "description": "CDN resource ID.", "example": 100}, "path": {"type": "string", "description": "Path requested.", "example": "/awesome-site"}, "method": {"type": "string", "description": "HTTP method used in the request.", "example": "GET"}, "user_agent": {"type": "string", "description": "Value of 'User-Agent' header.", "example": "Mozilla/5.0 (compatible; MSIE 6.0; Windows 95; Trident/3.1)"}, "status": {"type": "integer", "description": "HTTP status code.", "example": 200}, "size": {"type": "integer", "description": "Response size in bytes.", "example": 17340162}, "cache_status": {"type": "string", "description": "Cache status: HIT, MISS, etc.", "example": "HIT"}, "datacenter": {"type": "string", "description": "Data center where the request was processed.", "example": "m9"}, "referer": {"type": "string", "description": "Value of 'Referer' header.", "example": "https://www.test.com/"}, "sent_http_content_type": {"type": "string", "description": "Value of the Content-Type HTTP header, indicating the MIME type of the resource being transmitted.", "example": "image/jpeg"}, "tcpinfo_rtt": {"type": "integer", "description": "Time required to transmit a complete TCP segment: from the first bit to the last.", "example": 70}}}}, "meta": {"type": "object", "description": "Contains meta-information.", "properties": {"count": {"type": "integer", "description": "Total number of records which match given parameters.", "example": 129874732}}}}}
    GetShieldUsageAggregatedStat: {"type": "object", "properties": {"resource": {"type": "object", "description": "Resources IDs by which statistics data is grouped."}, "1 (example)": {"type": "object", "description": "CDN resource ID for which statistics data is shown."}, "metrics": {"type": "object", "description": "Statistics parameters."}, "shield_usage": {"type": "string", "description": "Number of CDN resources that used origin shielding."}}, "example": {"resource": {"1": {"metrics": {"shield_usage": 1}}}}}
    GetAggregatedCDNStatisticsResponse: {"type": "object", "properties": {"resource": {"type": "object", "description": "Resources IDs by which statistics data is grouped."}, "1 (example)": {"type": "object", "description": "CDN resource ID for which statistics data is shown."}, "region": {"type": "object", "description": "Regions by which statistics data is grouped."}, "cis (example)": {"type": "object", "description": "Region by which statistics data is grouped."}, "metrics": {"type": "object", "description": "Statistics parameters."}, "upstream_bytes": {"type": "integer", "description": "Traffic in bytes from the upstream to CDN servers."}, "sent_bytes": {"type": "integer", "description": "Traffic in bytes from CDN servers to clients."}, "total_bytes": {"type": "integer", "description": "Upstream bytes and `sent_bytes` combined."}, "backblaze_bytes": {"type": "integer", "description": "Traffic in bytes from Backblaze origin."}, "requests": {"type": "integer", "description": "Number of requests to edge servers."}, "responses_2xx": {"type": "integer", "description": "Number of 2xx response codes."}, "responses_3xx": {"type": "integer", "description": "Number of 3xx response codes."}, "responses_4xx": {"type": "integer", "description": "Number of 4xx response codes."}, "responses_5xx": {"type": "integer", "description": "Number of 5xx response codes."}, "responses_hit": {"type": "integer", "description": "Number of responses with the header Cache: HIT."}, "responses_miss": {"type": "integer", "description": "Number of responses with the header Cache: MISS."}, "response_types": {"type": "object", "description": "Statistics by content type. It returns a number of responses for content with different MIME types."}, "cache_hit_traffic_ratio": {"type": "integer", "description": "Formula: 1 - `upstream_bytes` / `sent_bytes`. We deduct the non-cached traffic from the total traffic amount"}, "95_percentile": {"type": "integer", "description": "95 percentile bandwidth value"}, "min_bandwidth": {"type": "integer", "description": "Minimum bandwidth"}, "max_bandwidth": {"type": "integer", "description": "Maximum bandwidth"}}, "example": {"resource": {"1": {"region": {"cis": {"metrics": {"95_percentile": 20023536, "cache_hit_traffic_ratio": 0.9958449964158854, "max_bandwidth": 34794756, "min_bandwidth": 379257, "requests": 21575631, "responses_2xx": 21095299, "responses_3xx": 278225, "responses_4xx": 202026, "responses_5xx": 81, "sent_bytes": 22014089592053, "total_bytes": 22105558213209, "backblaze_bytes": 2105658213209, "upstream_bytes": 91468621156, "responses_hit": 63368252, "responses_miss": 866237, "response_types": {"-": 378412, "application/json": 173054, "application/vnd": 7224, "application/zip": 8420, "image/gif": 1349, "image/jpeg": 2775, "image/png": 7536543, "image/webp": 746884}}}, "eu": {"metrics": {"95_percentile": 14324356, "cache_hit_traffic_ratio": 0.9852247660029627, "max_bandwidth": 22215199, "min_bandwidth": 299608, "requests": 64234595, "responses_2xx": 62616980, "responses_3xx": 1196666, "responses_4xx": 420718, "responses_5xx": 216, "sent_bytes": 16552226067556, "backblaze_bytes": 2105658213209, "total_bytes": 16796789080876, "upstream_bytes": 244563013320, "responses_hit": 21235829, "responses_miss": 339566, "response_types": {"-": 478532, "application/json": 172084, "application/vnd": 3324, "application/zip": 8100, "image/gif": 1379, "image/jpeg": 1975, "image/png": 7131343, "image/webp": 643574}}}}}}}}
    path: {"type": "string", "description": "Parameter is **deprecated**.", "example": ""}
    OriginGroupOriginsForbiddenForPrivateOriginError: {"title": "Origin group with private origin must be sole", "type": "object", "properties": {"errors": {"type": "object", "properties": {"sources": {"type": "array", "items": {"type": "string"}, "description": "Origin group with private origin must be sole.", "example": ["You can`t add another origin to a group. Private origin can only be used as the sole origin in the group."]}}}}}
    PatchRuleTemplate: {"type": "object", "properties": {"name": {"$ref": "#/components/schemas/schemas_components-schemas-name"}, "rule": {"$ref": "#/components/schemas/rule"}, "ruleType": {"$ref": "#/components/schemas/ruleType"}, "weight": {"$ref": "#/components/schemas/weight"}, "overrideOriginProtocol": {"$ref": "#/components/schemas/overrideOriginProtocol"}, "options": {"type": "object", "$ref": "#/components/schemas/rule_options"}}}
    OriginGroupIsUsedByResourceError: {"title": "Origin group is used by resources", "type": "object", "properties": {"name": {"type": "array", "items": {"type": "string"}, "description": "The origin group is used by resources and cannot be deleted.", "example": ["There are resources using such group"]}}}
    ssl_ca_list_response: {"type": "array", "items": {"$ref": "#/components/schemas/ssl_ca_response"}}
    AdvancedMetricsErrResponse: {"properties": {"status": {"type": "integer", "description": "Contains HTTP status code."}, "message": {"type": "string", "description": "This message describes error."}}, "example": {"status": 500, "message": "Internal Server Error"}}
    auth: {"description": "Credentials to access the private bucket.", "type": "object", "properties": {"s3_type": {"type": "string", "description": "Storage type compatible with S3.\n\nPossible values:\n- **amazon** – AWS S3 storage.\n- **other** – Other (not AWS) S3 compatible storage."}, "s3_access_key_id": {"type": "string", "description": "Access key ID for the S3 account. \n\nRestrictions:\n- Latin letters (A-Z, a-z), numbers (0-9), colon, dash, and underscore.\n- From 3 to 512 characters."}, "s3_secret_access_key": {"type": "string", "description": "Secret access key for the S3 account. \n\nRestrictions:\n- Latin letters (A-Z, a-z), numbers (0-9), pluses, slashes, dashes, colons and underscores.\n- If \"`s3_type`\": amazon, length should be 40 characters.\n- If \"`s3_type`\": other, length should be from 16 to 255 characters."}, "s3_bucket_name": {"type": "string", "description": "S3 bucket name. \n\nRestrictions:\n- Maximum 128 characters."}, "s3_storage_hostname": {"type": "string", "description": "S3 storage hostname. \n\nThe parameter is required, if \"`s3_type`\": other."}, "s3_region": {"type": "string", "description": "S3 storage region. \n\nThe parameter is required, if \"`s3_type`\": amazon."}}, "required": ["s3_type", "s3_access_key_id", "s3_secret_access_key", "s3_bucket_name"], "example": {"s3_type": "amazon", "s3_access_key_id": "EXAMPLEFODNN7EXAMPLE", "s3_secret_access_key": "wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY", "s3_bucket_name": "bucket_name", "s3_region": "us-east-2"}}
    active: {"type": "boolean", "default": true, "description": "Enables or disables a CDN resource.\n\nPossible values:\n- **true** - CDN resource is active. Content is being delivered.\n- **false** - CDN resource is deactivated. Content is not being delivered.", "example": true}
    OriginSourceWrongPortError: {"title": "Port value is incorrect", "type": "object", "properties": {"errors": {"type": "object", "properties": {"sources": {"type": "object", "properties": {"1.2.3.4:99999": {"type": "object", "properties": {"source": {"type": "array", "items": {"type": "string"}, "description": "The port value specified after ':' is incorrect. It must be a number within the range 1 and 65535. Please specify valid port value.", "example": ["The port value must be a number within the range 1 and 65535"]}}}}}}}}}
    ChangeRuleTemplate: {"type": "object", "properties": {"name": {"$ref": "#/components/schemas/schemas_components-schemas-name"}, "rule": {"$ref": "#/components/schemas/rule"}, "ruleType": {"$ref": "#/components/schemas/ruleType"}, "weight": {"$ref": "#/components/schemas/weight"}, "overrideOriginProtocol": {"$ref": "#/components/schemas/overrideOriginProtocol"}, "options": {"type": "object", "$ref": "#/components/schemas/rule_options"}}, "required": ["rule", "ruleType"]}
    RulePatternAlreadyExistsError: {"title": "Rule with the same pattern already exists", "type": "object", "properties": {"errors": {"type": "object", "properties": {"rule": {"type": "array", "description": "The specified pattern is already used by another rule of the resource. Try another pattern.", "items": {"type": "string"}, "example": ["The field rule_string must be unique."]}}}}}
    AuthS3OtherSecretAccessKeyIsInvalidError: {"title": "Auth must have a s3 secret access key with 20-50 alpha-numeric-plus-slash characters", "type": "object", "properties": {"errors": {"type": "object", "properties": {"auth": {"type": "object", "properties": {"s3_secret_access_key": {"type": "array", "items": {"type": "string"}, "description": "The specified s3 access key id is less 20-50 characters. Please lengthen the name and try again.", "example": ["Only 20-50 alpha-numeric-plus-slash characters are allowed."]}}}}}}}
    LimitsForCreationOriginsGroup: {"title": "Upgrade service", "type": "object", "properties": {"message": {"type": "string", "description": "You have exceeded the number of allowed origin groups. Please upgrade the service to create more origin groups."}}}
    AdvancedMetricsErrBadResponse: {"properties": {"status": {"type": "integer", "description": "Contains HTTP status code."}, "message": {"type": "string", "description": "This message describes error if body in your request is invalid."}}, "example": {"status": 400, "message": "validation failure list:\\ngroup_by.0 in body should be one of [resource cname]"}}
    GetRawLogs: {"type": "object", "properties": {"client": {"type": "integer", "description": "Client ID."}, "enabled": {"type": "boolean", "description": "Enables or disables a log forwarding feature.\n\nPossible values:\n- **true** - log forwarding feature is active.\n- **false** - log forwarding feature is deactivated."}, "ignore_empty_logs": {"type": "boolean", "description": "Enables or disables the forwarding of empty logs.\n\nPossible values:\n- **true** - Empty logs are not sent.\n- **false** - Empty logs are sent."}, "storage_type": {"type": "string", "description": "Storage type. \n\nPossible values:\n- **ftp**\n- **sftp**\n- **s3**"}, "for_all_resources": {"type": "boolean", "description": "Defines whether logs of all CDN resources are delivered to one folder/bucket or to separate ones.\n\nPossible values:\n- **true** - Logs of all CDN resources are delivered to one folder/bucket.\n- **false** - Logs of CDN resources are delivered to separate folders/buckets."}, "all_resources_bucket": {"type": "string", "description": "Name of the S3 bucket to which logs of all CDN resources are delivered.\n\nApplicable for \"`storage_type`\": S3."}, "all_resources_folder": {"type": "string", "description": "Parameter meaning depends on the value of the \"`storage_type`\" value:\n- **s3** - Name of the S3 bucket sub-folder to which logs for all CDN resources are delivered.\n- **ftp/sftp** - Name of the folder (or path) to which logs for all CDN resources are delivered."}, "s3_type": {"type": "string", "description": "Storage type compatible with S3.\n\nPossible values:\n- **amazon** – AWS S3 storage.\n- **other** – Other (not AWS) S3 compatible storage."}, "s3_aws_region": {"type": "string", "description": "Amazon AWS region."}, "s3_hostname": {"type": "string", "description": "S3 storage hostname."}, "s3_host_bucket": {"type": "string", "description": "S3 storage bucket hostname.\n\nRestrictions:\n- Maximum 255 symbols.\n- Latin letters (A-Z, a-z,) digits (0-9,) dots, colons, dashes, and underscores."}, "s3_bucket_location": {"type": "string", "description": "S3 storage location.\n\nRestrictions:\n- Maximum 255 symbols.\n- Latin letters (A-Z, a-z,) digits (0-9,) dots, colons, dashes, and underscores (.:_-)."}, "s3_access_key_id": {"type": "string", "description": "Access key ID for the S3 account.\n\nAccess Key ID is 20 alpha-numeric characters like 022QF06E7MXBSH9DHM02"}, "ftp_hostname": {"type": "string", "description": "FTP storage hostname."}, "ftp_login": {"type": "string", "description": "FTP storage login."}, "ftp_prepend_folder": {"type": "string", "description": "Name of prepend FTP folder for log delivery."}, "sftp_hostname": {"type": "string", "description": "SFTP storage hostname."}, "sftp_login": {"type": "string", "description": "SFTP storage login."}, "sftp_prepend_folder": {"type": "string", "description": "Name of prepend SFTP folder for log delivery."}, "folders": {"type": "array", "items": {"$ref": "#/components/schemas/RawLogsFolder"}, "description": "List of folders/buckets for receiving CDN resources logs."}, "status": {"type": "string", "description": "Log delivery status.\n\nPossible values:\n- **ok** – All/part of attempts to deliver logs were successful.\n- **failed** – All attempts to deliver logs failed.\n- **pending** - No logs delivery attempts yet.\n- **disabled** - Log delivery is disabled."}, "comment": {"type": "string", "readOnly": true, "nullable": true, "description": "System comment on the status of settings, if they are suspended."}, "archive_size_mb": {"type": "integer", "nullable": true, "minimum": 500, "maximum": 2000, "description": "The size of a single piece of the archive in MB.\nIn case of **null** value logs are delivered without slicing."}}}
    CreateRule: {"type": "object", "properties": {"name": {"$ref": "#/components/schemas/components-schemas-name"}, "rule": {"$ref": "#/components/schemas/rule"}, "ruleType": {"$ref": "#/components/schemas/ruleType"}, "active": {"$ref": "#/components/schemas/schemas-active"}, "weight": {"$ref": "#/components/schemas/weight"}, "overrideOriginProtocol": {"$ref": "#/components/schemas/overrideOriginProtocol"}, "originGroup": {"$ref": "#/components/schemas/schemas-originGroup"}, "options": {"type": "object", "$ref": "#/components/schemas/rule_options"}}, "required": ["name", "rule", "ruleType"]}
    originProtocol: {"type": "string", "enum": ["HTTP", "HTTPS", "MATCH"], "default": "HTTP", "description": "Protocol used by CDN servers to request content from an origin source.\n\nPossible values:\n- **HTTPS** - CDN servers will connect to the origin via HTTPS.\n- **HTTP** - CDN servers will connect to the origin via HTTP.\n- **MATCH** - connection protocol will be chosen automatically (content on the origin source should be available for the CDN both through HTTP and HTTPS).\n\nIf protocol is not specified, HTTP is used to connect to an origin server.", "example": "HTTPS"}
    sources: {"description": "List of origin sources in the origin group.", "type": "array", "items": {"$ref": "#/components/schemas/SourceResponse"}, "example": [{"backup": false, "enabled": true, "source": "yourwebsite.com"}, {"backup": true, "enabled": true, "source": "1.2.3.4:5500"}]}
    auth_type_aws: {"type": "string", "description": "Authentication type. \n\n**awsSignatureV4** value is used for S3 storage.", "example": "awsSignatureV4"}
    AuthInvalidWithNoneAuthTypeValueError: {"title": "Origin Group has not to auth with \"none\" auth type", "type": "object", "properties": {"errors": {"type": "object", "properties": {"auth": {"type": "array", "items": {"type": "string"}, "description": "Origin Group has not to auth with \"none\" auth type.", "example": ["Origin Group hasn`t to auth with auth type: `none`."]}}}}}
    ResourcePurge: {"anyOf": [{"type": "object", "title": "Purge by URL", "properties": {"urls": {"type": "array", "items": {"type": "string"}, "description": "**Purge by URL** clears the cache of a specific files. This purge type is recommended.\n\nSpecify file URLs including query strings. URLs should start with / without a domain name. \n\nPurge by URL depends on the following CDN options:\n\n1. \"vary response header\" is used. If your origin serves variants of the same content depending on the Vary HTTP response header, purge by URL will delete only one version of the file.\n2. \"slice\" is used. If you update several files in the origin without clearing the CDN cache, purge by URL will delete only the first slice (with bytes=0… .)\n3. \"ignoreQueryString\" is used. Don’t specify parameters in the purge request.\n4. \"`query_params_blacklist`\" is used. Only files with the listed in the option parameters will be cached as different objects. Files with other parameters will be cached as one object. In this case, specify the listed parameters in the Purge request. Don't specify other parameters.\n5. \"`query_params_whitelist`\" is used. Files with listed in the option parameters will be cached as one object. Files with other parameters will be cached as different objects. In this case, specify other parameters (if any) besides the ones listed in the purge request."}}}, {"type": "object", "title": "Purge by pattern", "properties": {"paths": {"type": "array", "items": {"type": "string"}, "description": "**Purge by pattern** clears the cache that matches the pattern.\n\nUse \\* operator, which replaces any number of symbols in your path. It's important to note that wildcard usage (\\*) is permitted only at the end of a pattern.\n\nQuery string added to any patterns will be ignored, and purge request will be processed as if there weren't any parameters.\n\nPurge by pattern is recursive. Both /path and /path\\* will result in recursive purging, meaning all content under the specified path will be affected. As such, using the pattern /path\\* is functionally equivalent to simply using /path."}}}, {"type": "object", "title": "Purge all cache", "properties": {"paths": {"type": "array", "items": {"type": "string"}, "description": "**Purge all cache** clears the entire cache for the CDN resource.\n\nSpecify an empty array to purge all content for the resource.\n\nWhen you purge all assets, CDN servers request content from your origin server and cause a high load. Therefore, we recommend to use purge by URL for large content quantities."}}}]}
    use_next: {"type": "boolean", "description": "Defines whether to use the next origin from the origin group if origin responds with the cases specified in `proxy_next_upstream`.\nIf you enable it, you must specify cases in `proxy_next_upstream`.\n\nPossible values:\n- **true** - Option is enabled.\n- **false** - Option is disabled.", "example": true}
    GetNetworkCapacity: {"type": "array", "items": {"type": "object", "properties": {"country_code": {"type": "string", "description": "ISO country code."}, "country": {"type": "string", "description": "Country name."}, "capacity": {"type": "number", "description": "Network capacity in Gbit/s."}}}, "example": [{"country_code": "NL", "country": "Netherlands", "capacity": 974.09}, {"country_code": "DE", "country": "Germany", "capacity": 913.05}, {"country_code": "JP", "country": "Japan", "capacity": 851.77}]}
    PatchLogsUploaderPolicy: {"type": "object", "properties": {"include_empty_logs": {"type": "boolean", "description": "Include empty logs in the upload."}, "include_shield_logs": {"type": "boolean", "description": "Include logs from origin shielding in the upload."}, "name": {"type": "string", "description": "Name of the policy.", "maxLength": 255}, "description": {"type": "string", "description": "Description of the policy.", "maxLength": 255}, "retry_interval_minutes": {"type": "integer", "description": "Interval in minutes to retry failed uploads.", "maximum": 60, "minimum": 5}, "rotate_interval_minutes": {"type": "integer", "description": "Interval in minutes to rotate logs.", "maximum": 60, "minimum": 5}, "rotate_threshold_mb": {"type": "integer", "description": "Threshold in MB to rotate logs.", "minimum": 100, "nullable": true}, "rotate_threshold_lines": {"type": "integer", "description": "Threshold in lines to rotate logs.", "maximum": 10000, "minimum": 0}, "date_format": {"type": "string", "description": "Date format for logs.", "maxLength": 255}, "field_delimiter": {"type": "string", "description": "Field delimiter for logs.", "maxLength": 10}, "field_separator": {"type": "string", "description": "Field separator for logs.", "minLength": 1, "maxLength": 10}, "fields": {"type": "array", "items": {"type": "string", "maxLength": 255}, "description": "List of fields to include in logs."}, "file_name_template": {"type": "string", "description": "Template for log file name.", "maxLength": 255}, "format_type": {"type": "string", "description": "Format type for logs.", "maxLength": 255}, "tags": {"type": "object", "description": "Tags allow for dynamic decoration of logs by adding predefined fields to the log format. These tags serve as customizable key-value pairs that can be included in log entries to enhance context and readability.", "additionalProperties": {"type": "string", "maxLength": 50}}}, "example": {"include_empty_logs": true, "include_shield_logs": true, "name": "Policy", "description": "New policy", "retry_interval_minutes": 32, "rotate_interval_minutes": 32, "rotate_threshold_mb": 252, "rotate_threshold_lines": 5000, "date_format": "[02/Jan/2006:15:04:05 -0700]", "field_delimiter": ",", "field_separator": ";", "fields": ["remote_addr", "status"], "file_name_template": "{{YYYY}}_{{MM}}_{{DD}}_{{HH}}_{{mm}}_{{ss}}_access.log.gz", "format_type": "flvproxy", "tags": {}, "related_uploader_configs": [123]}}
    ChangeCDNService: {"type": "object", "properties": {"utilization_level": {"$ref": "#/components/schemas/utilization_level"}}}
    NotLECertificateForceRetryError: {"title": "Not Let's Encrypt certificate selected", "type": "object", "properties": {"errors": {"type": "object", "properties": {"certificate": {"type": "array", "items": {"type": "string"}, "description": "The specified certificate is not Let's Encrypt certificate. Please check the certificate ID.", "example": ["Force retry is not allowed for non-Let's Encrypt certificates."]}}}}}
    AuthS3BucketNameIsRequiredError: {"title": "Auth must have a s3 bucket name", "type": "object", "properties": {"errors": {"type": "object", "properties": {"auth": {"type": "object", "properties": {"s3_bucket_name": {"type": "array", "items": {"type": "string"}, "description": "S3 bucket name is a mandatory field. Please specify it.", "example": ["This field is required."]}}}}}}}
    ClientsMeLimitsResponse: {"type": "object", "properties": {"id": {"type": "integer", "description": "Account ID.", "example": 100}, "resources_limit": {"type": "integer", "description": "Maximum number of CDN resources that can be created on your tariff plan.", "example": 30}, "rules_limit": {"type": "integer", "description": "Maximum number of rules that can be created per CDN resource on your tariff plan.", "example": 5}, "origins_in_group_limit": {"type": "integer", "description": "Maximum number of origins that can be added to the origin group on your tariff plan.", "example": 10}}}
    ruleType: {"type": "integer", "minimum": 0, "maximum": 1, "description": "Rule type. \n\nPossible values:\n- **Type 0** - Regular expression. Must start with '^/' or '/'.\n- **Type 1** - Regular expression. Note that for this rule type we automatically add / to each rule pattern before your regular expression. This type is **legacy**, please use Type 0.", "example": 0}
    LECertificateIsNotAttachedToResourceError: {"title": "Let's Encrypt certificate is not attached to resource", "type": "object", "properties": {"errors": {"type": "object", "properties": {"certificate": {"type": "array", "items": {"type": "string"}, "description": "The specified certificate is not attached to any resource. Please check the certificate ID.", "example": ["Certificate is not attached to a resource."]}}}}}
    LECertificatePreValidationError: {"type": "object", "properties": {"errors": {"type": "array", "items": {"type": "string"}, "description": "Errors occurred during resource pre-validation. Check the response to get more details.", "example": ["An error occurred when connecting to the validation URL. Please ensure that DNS records are pointed to our services, and check whether the rules you created overlap the path \"/.well-known/acme-challenge/\". If you have just created a CDN resource, it may take up to 15 minutes to activate it. In this case, please wait until the CDN resource is activated and try to issue the certificate again."]}}}
    GetAwsRegionsResponse: {"type": "object", "properties": {"id": {"type": "integer", "description": "Region ID."}, "code": {"type": "string", "description": "Region code."}, "name": {"type": "string", "description": "Region name."}}}
    originGroup: {"type": "integer", "description": "Origin group ID with which the CDN resource is associated.\n\nYou can use either the `origin` or `originGroup` parameter in the request.", "example": 132}
    PatchRule: {"type": "object", "properties": {"active": {"$ref": "#/components/schemas/schemas-active"}, "name": {"$ref": "#/components/schemas/components-schemas-name"}, "rule": {"$ref": "#/components/schemas/rule"}, "ruleType": {"$ref": "#/components/schemas/ruleType"}, "weight": {"$ref": "#/components/schemas/weight"}, "overrideOriginProtocol": {"$ref": "#/components/schemas/overrideOriginProtocol"}, "originGroup": {"$ref": "#/components/schemas/schemas-originGroup"}, "options": {"type": "object", "$ref": "#/components/schemas/rule_options"}}}
    RuleResponse: {"type": "object", "properties": {"id": {"$ref": "#/components/schemas/components-schemas-id"}, "name": {"$ref": "#/components/schemas/components-schemas-name"}, "active": {"$ref": "#/components/schemas/schemas-active"}, "deleted": {"$ref": "#/components/schemas/schemas-deleted"}, "originGroup": {"$ref": "#/components/schemas/schemas-originGroup"}, "rule": {"$ref": "#/components/schemas/rule"}, "ruleType": {"$ref": "#/components/schemas/ruleType"}, "weight": {"$ref": "#/components/schemas/weight"}, "originProtocol": {"$ref": "#/components/schemas/schemas-originProtocol"}, "overrideOriginProtocol": {"$ref": "#/components/schemas/overrideOriginProtocol"}, "preset_applied": {"$ref": "#/components/schemas/schemas-preset_applied"}, "primary_rule": {"$ref": "#/components/schemas/primary_rule"}, "options": {"type": "object", "$ref": "#/components/schemas/rule_options"}}}
    OriginSourceForbiddenError: {"title": "Origin source is forbidden", "type": "object", "properties": {"errors": {"type": "object", "properties": {"sources": {"type": "object", "properties": {"forbiddenwebsite.com": {"type": "object", "properties": {"source": {"type": "array", "items": {"type": "string"}, "description": "The specified origin source is blacklisted. It cannot be used to create an origin. Please specify another origin source.", "example": ["That origin source is forbidden"]}}}}}}}}}
    FullCustomResourceDeletionFailed: {"title": "Resource has a custom configuration", "type": "object", "properties": {"errors": {"type": "array", "description": "This resource has a custom configuration and cannot be deleted.\nTo delete the resource, contact technical support.", "items": {"type": "string"}, "example": ["You cannot delete this resource because it has a custom configuration. To delete the resource, contact technical support."]}}}
    waap_api_domain_enabled: {"type": "boolean", "writeOnly": true, "description": "Defines whether the associated WAAP Domain is identified as an API Domain.\n\nPossible values:\n- **true** - The associated WAAP Domain is designated as an API Domain.\n- **false** - The associated WAAP Domain is not designated as an API Domain."}
    ResourcePrefetch: {"type": "object", "properties": {"paths": {"type": "array", "description": "Paths to files that should be pre-populated to the CDN.\n\nPaths to the files should be specified without a domain name.", "items": {"type": "string"}, "example": ["/test.jpg", "test1.jpg"]}}, "required": ["paths"]}
    GetShieldingPOPV2: {"type": "array", "items": {"type": "object", "properties": {"id": {"type": "integer", "description": "Origin shielding location ID."}, "datacenter": {"type": "string", "description": "Name of origin shielding location datacenter."}, "country": {"type": "string", "description": "Country of origin shielding location."}, "city": {"type": "string", "description": "City of origin shielding location."}}}}
    LERequestStatusV2: {"type": "object", "properties": {"id": {"type": "integer", "description": "ID of the attempt to issue a Let's Encrypt certificate.", "example": 1}, "statuses": {"type": "array", "description": "Detailed information about attempts to issue a Let's Encrypt certificate.", "items": {"$ref": "#/components/schemas/LERequestAttemptStatus"}}, "latest_status": {"allOf": ["$ref": "#/components/schemas/LERequestAttemptStatus", "description": "Detailed information about last attempt to issue a Let's Encrypt certificate."]}, "started": {"type": "string", "description": "Date when the process of issuing a Let's Encrypt certificate was started (ISO 8601/RFC 3339 format, UTC).", "example": "2021-10-29T13:20:56.543678Z"}, "finished": {"type": "string", "description": "Date when the process of issuing a Let's Encrypt certificate was finished (ISO 8601/RFC 3339 format, UTC).\n\nThe field is **null** if the issuing process is not finished.", "example": "2021-10-29T13:21:01.550849Z"}, "active": {"type": "boolean", "description": "Defines whether the Let's Encrypt certificate issuing process is active.\n\nPossible values:\n- **true** - Issuing process is active.\n- **false** - Issuing process is completed.", "example": false}, "attempts_count": {"type": "integer", "description": "Number of attempts to issue the Let's Encrypt certificate.", "example": 1}, "next_attempt_time": {"type": "string", "description": "Time of the next scheduled attempt to issue the Let's Encrypt certificate (ISO 8601/RFC 3339 format, UTC)."}, "resource": {"type": "integer", "description": "CDN resource ID.", "example": 1}}}
    AuthS3RegionIsInvalidError: {"title": "Auth must have a known s3 region", "type": "object", "properties": {"errors": {"type": "object", "properties": {"auth": {"type": "object", "properties": {"s3_region": {"type": "array", "items": {"type": "string"}, "description": "The specified s3 region is not supported. Please use other region and try again.", "example": ["Not support {s3 region}"]}}}}}}}
    CDNServiceResponse: {"type": "object", "properties": {"id": {"type": "integer", "description": "Account ID.", "example": 174}, "created": {"type": "string", "description": "Date of the first synchronization with the Platform (ISO 8601/RFC 3339 format, UTC.)"}, "updated": {"type": "string", "description": "Date of the last update of information about CDN service (ISO 8601/RFC 3339 format, UTC.)", "example": "2021-06-24T01:57:01.416157Z"}, "service": {"$ref": "#/components/schemas/service"}, "utilization_level": {"$ref": "#/components/schemas/utilization_level"}, "cname": {"type": "string", "description": "Domain zone to which a CNAME record of your CDN resources should be pointed.", "example": "cl-174-example.cdn.com"}, "use_balancer": {"type": "boolean", "description": "Defines whether custom balancing is used for content delivery.\n\nPossible values:\n- **true** - Custom balancing is used for content delivery.\n- **false** - Custom balancing is not used for content delivery.", "example": true}, "auto_suspend_enabled": {"type": "boolean", "description": "Defines whether resources will be deactivated automatically by inactivity.\n\nPossible values:\n- **true** - Resources will be deactivated.\n- **false** - Resources will not be deactivated.", "example": true}, "cdn_resources_rules_max_count": {"type": "integer", "description": "Limit on the number of rules for each CDN resource.", "example": 10}}}
    RawLogsFolder: {"allOf": ["$ref": "#/components/schemas/RawLogsFolderBase", "properties": {"cdn_resource": {"type": "integer", "description": "CDN resource ID."}}]}
    PrimaryResourceDeletionFailed: {"title": "It's a primary resource", "type": "object", "properties": {"errors": {"type": "array", "description": "This resource is used as primary for common cache feature and cannot be deleted.\nPlease delete linked resources first.", "items": {"type": "string"}, "example": ["The CDN resource is used as primary for common cache feature and can not be deleted. Delete linked resources first [29]"]}}}
    ssl_ca_add: {"type": "object", "properties": {"name": {"type": "string", "description": "CA certificate name. \n\nIt must be unique.", "example": "Example CA cert"}, "sslCertificate": {"type": "string", "description": "Public part of the CA certificate. \n\nIt must be in the PEM format.", "example": "-----BEGIN CERTIFICATE-----\nMIIC0zCCAbugAwIBAgICA+gwDQYJKoZIhvcNAQELBQAwFjEUMBIGA1UEAwwLZXhh\nbXBsZS5jb20wHhcNMjAwNjI2MTIwMzUzWhcNMjEwNjI2MTIwMzUzWjAWMRQwEgYD\nVQQDDAtleGFtcGxlLmNvbTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEB\nAN4nnSfTsMEnfPgL7rkbImxZAQoND+bpPoX8q16iXZz3fFfqdRk+uEIpU3Brleeg\np0zrrT2eI3+c2h/PRod0Fam4TO6EcfwuboUFzV3j6yw6aWdfBjWZsWBR/FoqWLYq\nb3UejN7yiTYNSiIy3zVpi9pnFM8N8qT+VGBrRDGef2v9JCzhsSSU7wAYM5HKZTp+\nWHojjiyB2hOYqft7A2WlTEDmHFa5UcPHMRZKATUYI1T2TRVqLlSiE2mJ3dFRXGM2\nZAS33J0NVUjkx3w8RmJ7DNflEFJt/6IXdfaokVgfza7LFarrQFQP/YURXEeJT7jm\nDvKpZ/a8wu3ve6N4ykC+CBsCAwEAAaMrMCkwDwYDVR0TBAgwBgEB/wIBADAWBgNV\nHREEDzANggtleGFtcGxlLmNvbTANBgkqhkiG9w0BAQsFAAOCAQEAovxY5lm89Eod\nL8CH3dZzIH7nv8MXtwgpv2vth4PDq2btLS8xrqm2SsA/cV+DsbDjh5CxQLoDX+8V\ng8NtY+ipOE0hdJAUo7UVlsxuAY4frkmLL1/RwpjZg+Z2NAxpR7xGWgoMn7CH481w\nAOBypAuCxcfcyyAOttdS+YMRJnpL6z8/C3W0LGkNOs26Qhu1/U8lfz1f9F4XummD\nu2SCmJsAd1PrL1shsyh4HtmFjuY698aTjYUDUleAnx7ytrGlZuLOIeoQi7tcsLJJ\nTPMbxTLgGN2HEkdJerFRBNViuWvqioEyYlzZ3MshOCR2wsL4wrXrCF0Y3cNOYcIh\nZ8z+wUAP2g==\n-----END CERTIFICATE-----\n"}}, "required": ["name", "sslCertificate"]}
    LogsUploaderTargetResponse: {"type": "object", "properties": {"id": {"type": "integer", "readOnly": true}, "client_id": {"type": "integer", "description": "Client that owns the target.", "readOnly": true}, "created": {"type": "string", "format": "date-time", "readOnly": true, "description": "Time when logs uploader target was created."}, "updated": {"type": "string", "format": "date-time", "readOnly": true, "description": "Time when logs uploader target was updated."}, "storage_type": {"type": "string", "enum": ["s3_gcore", "s3_amazon", "s3_oss", "s3_other", "s3_v1", "ftp", "sftp", "http"], "description": "Type of storage for logs."}, "name": {"type": "string", "description": "Name of the target.", "maxLength": 255}, "description": {"type": "string", "description": "Description of the target.", "maxLength": 255}, "related_uploader_configs": {"type": "array", "items": {"type": "integer"}, "description": "List of logs uploader configs that use this target."}, "status": {"allOf": ["$ref": "#/components/schemas/LogsUploaderValidationResponse", {"type": "object", "description": "Validation status of the logs uploader target. Informs if the specified target is reachable."}]}, "config": {"description": "Config for specific storage type.", "anyOf": ["$ref": "#/components/schemas/S3GcoreConfigResponse", "$ref": "#/components/schemas/S3AmazonConfigResponse", "$ref": "#/components/schemas/S3OSSConfigResponse", "$ref": "#/components/schemas/S3OtherConfigResponse", "$ref": "#/components/schemas/S3V1ConfigResponse", "$ref": "#/components/schemas/FTPConfigResponse", "$ref": "#/components/schemas/SFTPConfigResponse", "$ref": "#/components/schemas/HTTPConfigResponse"]}}}
    PatchLogsUploaderTarget: {"type": "object", "properties": {"storage_type": {"type": "string", "enum": ["s3_gcore", "s3_amazon", "s3_oss", "s3_other", "s3_v1", "ftp", "sftp", "http"], "description": "Type of storage for logs."}, "name": {"type": "string", "description": "Name of the target.", "maxLength": 255}, "description": {"type": "string", "description": "Description of the target.", "maxLength": 255}, "config": {"description": "Config for specific storage type.", "anyOf": ["$ref": "#/components/schemas/S3GcoreConfig", "$ref": "#/components/schemas/S3AmazonConfig", "$ref": "#/components/schemas/S3OSSConfig", "$ref": "#/components/schemas/S3OtherConfig", "$ref": "#/components/schemas/S3V1Config", "$ref": "#/components/schemas/FTPConfig", "$ref": "#/components/schemas/SFTPConfig", "$ref": "#/components/schemas/HTTPConfig"]}}}
    RuleTemplateResponse: {"type": "object", "properties": {"id": {"$ref": "#/components/schemas/schemas_components-schemas-id"}, "name": {"$ref": "#/components/schemas/schemas_components-schemas-name"}, "client": {"$ref": "#/components/schemas/schemas-client"}, "deleted": {"$ref": "#/components/schemas/components-schemas-deleted"}, "rule": {"$ref": "#/components/schemas/rule"}, "ruleType": {"$ref": "#/components/schemas/ruleType"}, "weight": {"$ref": "#/components/schemas/weight"}, "template": {"$ref": "#/components/schemas/cdn_template"}, "default": {"$ref": "#/components/schemas/default"}, "overrideOriginProtocol": {"$ref": "#/components/schemas/overrideOriginProtocol"}, "options": {"type": "object", "$ref": "#/components/schemas/rule_options"}}}
    CreateLogsUploaderTarget: {"type": "object", "properties": {"storage_type": {"type": "string", "enum": ["s3_gcore", "s3_amazon", "s3_oss", "s3_other", "s3_v1", "ftp", "sftp", "http"], "description": "Type of storage for logs."}, "name": {"type": "string", "description": "Name of the target.", "maxLength": 255, "default": "Target"}, "description": {"type": "string", "description": "Description of the target.", "maxLength": 255}, "config": {"description": "Config for specific storage type.", "anyOf": ["$ref": "#/components/schemas/S3GcoreConfig", "$ref": "#/components/schemas/S3AmazonConfig", "$ref": "#/components/schemas/S3OSSConfig", "$ref": "#/components/schemas/S3OtherConfig", "$ref": "#/components/schemas/S3V1Config", "$ref": "#/components/schemas/FTPConfig", "$ref": "#/components/schemas/SFTPConfig", "$ref": "#/components/schemas/HTTPConfig"]}}, "required": ["storage_type", "config"]}
    utilization_level: {"type": "integer", "description": "CDN traffic usage limit in gigabytes.\n\nWhen the limit is reached, we will send an email notification.", "example": 1111}
    PatchResource: {"type": "object", "properties": {"active": {"$ref": "#/components/schemas/active"}, "name": {"$ref": "#/components/schemas/schemas-name"}, "description": {"$ref": "#/components/schemas/description"}, "secondaryHostnames": {"$ref": "#/components/schemas/secondaryHostnames"}, "originGroup": {"$ref": "#/components/schemas/originGroup"}, "originProtocol": {"$ref": "#/components/schemas/originProtocol"}, "sslEnabled": {"$ref": "#/components/schemas/sslEnabled"}, "sslData": {"$ref": "#/components/schemas/sslData"}, "proxy_ssl_enabled": {"$ref": "#/components/schemas/proxy_ssl_enabled"}, "proxy_ssl_ca": {"$ref": "#/components/schemas/proxy_ssl_ca"}, "proxy_ssl_data": {"$ref": "#/components/schemas/proxy_ssl_data"}, "options": {"type": "object", "$ref": "#/components/schemas/resource_options"}}}
    SourceResponse: {"type": "object", "properties": {"source": {"$ref": "#/components/schemas/source"}, "backup": {"$ref": "#/components/schemas/backup"}, "enabled": {"$ref": "#/components/schemas/enabled"}}}
    ResourceResponse: {"type": "object", "properties": {"id": {"$ref": "#/components/schemas/schemas-id"}, "cname": {"$ref": "#/components/schemas/cname"}, "active": {"$ref": "#/components/schemas/active"}, "enabled": {"$ref": "#/components/schemas/schemas-enabled"}, "status": {"$ref": "#/components/schemas/status"}, "deleted": {"$ref": "#/components/schemas/deleted"}, "client": {"$ref": "#/components/schemas/cdn_client"}, "name": {"$ref": "#/components/schemas/schemas-name"}, "description": {"$ref": "#/components/schemas/description"}, "created": {"$ref": "#/components/schemas/created"}, "updated": {"$ref": "#/components/schemas/updated"}, "originGroup": {"$ref": "#/components/schemas/originGroup"}, "originGroup_name": {"$ref": "#/components/schemas/originGroup_name"}, "originProtocol": {"$ref": "#/components/schemas/originProtocol"}, "secondaryHostnames": {"$ref": "#/components/schemas/secondaryHostnames"}, "shielded": {"$ref": "#/components/schemas/shielded"}, "shield_dc": {"$ref": "#/components/schemas/shield_dc"}, "shield_enabled": {"$ref": "#/components/schemas/shield_enabled"}, "shield_routing_map": {"$ref": "#/components/schemas/shield_routing_map"}, "sslEnabled": {"$ref": "#/components/schemas/sslEnabled"}, "sslData": {"$ref": "#/components/schemas/sslData"}, "proxy_ssl_enabled": {"$ref": "#/components/schemas/proxy_ssl_enabled"}, "proxy_ssl_ca": {"$ref": "#/components/schemas/proxy_ssl_ca"}, "proxy_ssl_data": {"$ref": "#/components/schemas/proxy_ssl_data"}, "preset_applied": {"$ref": "#/components/schemas/preset_applied"}, "vp_enabled": {"$ref": "#/components/schemas/vp_enabled"}, "full_custom_enabled": {"$ref": "#/components/schemas/full_custom_enabled"}, "can_purge_by_urls": {"$ref": "#/components/schemas/can_purge_by_urls"}, "suspend_date": {"$ref": "#/components/schemas/suspend_date"}, "suspended": {"$ref": "#/components/schemas/suspended"}, "primary_resource": {"$ref": "#/components/schemas/primary_resource"}, "is_primary": {"$ref": "#/components/schemas/is_primary"}, "waap_domain_id": {"$ref": "#/components/schemas/waap_domain_id"}, "rules": {"type": "array", "readOnly": true, "items": {"type": "object", "format": "Rule"}, "description": "Rules configured for the CDN resource.", "example": []}, "options": {"type": "object", "$ref": "#/components/schemas/resource_options"}}}
    RuleTemplateListResponse: {"type": "array", "items": {"$ref": "#/components/schemas/RuleTemplateResponse"}}
    S3V1Config: {"title": "S3 V1 Config", "allOf": ["$ref": "#/components/schemas/S3OtherConfig"]}
    LogsUploaderPolicyListResponse: {"type": "array", "items": {"$ref": "#/components/schemas/LogsUploaderPolicyResponse"}}
    ChangeRule: {"type": "object", "properties": {"active": {"$ref": "#/components/schemas/schemas-active"}, "name": {"$ref": "#/components/schemas/components-schemas-name"}, "rule": {"$ref": "#/components/schemas/rule"}, "ruleType": {"$ref": "#/components/schemas/ruleType"}, "weight": {"$ref": "#/components/schemas/weight"}, "overrideOriginProtocol": {"$ref": "#/components/schemas/overrideOriginProtocol"}, "originGroup": {"$ref": "#/components/schemas/schemas-originGroup"}, "options": {"type": "object", "$ref": "#/components/schemas/rule_options"}}, "required": ["rule", "ruleType"]}
    CreateOriginGroup: {"anyOf": [{"type": "object", "title": "None Auth", "properties": {"name": {"$ref": "#/components/schemas/name"}, "use_next": {"$ref": "#/components/schemas/use_next"}, "proxy_next_upstream": {"$ref": "#/components/schemas/proxy_next_upstream"}, "auth_type": {"$ref": "#/components/schemas/auth_type_none"}, "sources": {"$ref": "#/components/schemas/sources"}}, "required": ["name", "sources"]}, {"type": "object", "title": "AWS Signature V4", "properties": {"name": {"$ref": "#/components/schemas/name"}, "use_next": {"$ref": "#/components/schemas/use_next"}, "proxy_next_upstream": {"$ref": "#/components/schemas/proxy_next_upstream"}, "auth_type": {"$ref": "#/components/schemas/auth_type_aws"}, "auth": {"$ref": "#/components/schemas/auth"}}, "required": ["name", "auth_type", "auth"]}]}
    StreamingResourceDeletionFailed: {"title": "It's a resource for the Streaming service", "type": "object", "properties": {"errors": {"type": "array", "description": "This resource is integrated with the Streaming service and cannot be deleted.\nPlease stop using the resource in the Streaming service before deletion.", "items": {"type": "string"}, "example": ["The CDN resource is integrated with the streaming and can not be deleted."]}}}
    IncorrectPathsItemsPurgeOrPrefetchError: {"title": "Incorrect paths items provided", "type": "object", "properties": {"errors": {"type": "object", "properties": {"paths": {"type": "object", "properties": {"index": {"type": "array", "description": "Some items in \"paths\" is invalid.", "items": {"type": "string"}, "example": ["This field may not be blank."]}}}}}}}
    IncorrectPathsFormatPurgeError: {"title": "Incorrect paths format provided", "type": "object", "properties": {"errors": {"type": "object", "properties": {"paths": {"type": "array", "description": "The field \"paths\" has invalid values.", "items": {"type": "string"}, "example": ["A path should start with /."]}}}}}
    ChangeOriginGroup: {"anyOf": [{"type": "object", "title": "None Auth", "properties": {"name": {"$ref": "#/components/schemas/name"}, "use_next": {"$ref": "#/components/schemas/use_next"}, "proxy_next_upstream": {"$ref": "#/components/schemas/proxy_next_upstream"}, "auth_type": {"$ref": "#/components/schemas/auth_type_none"}, "sources": {"$ref": "#/components/schemas/sources", "example": [{"enabled": true, "source": "yourdomain.com", "backup": false}]}, "path": {"$ref": "#/components/schemas/path"}}, "required": ["name"]}, {"type": "object", "title": "AWS Signature V4", "properties": {"name": {"$ref": "#/components/schemas/name"}, "use_next": {"$ref": "#/components/schemas/use_next"}, "proxy_next_upstream": {"$ref": "#/components/schemas/proxy_next_upstream"}, "auth_type": {"$ref": "#/components/schemas/auth_type_aws"}, "auth": {"$ref": "#/components/schemas/auth"}, "path": {"$ref": "#/components/schemas/path"}}}]}
    OriginSourceInvalidError: {"title": "Port origin source value is incorrect", "type": "object", "properties": {"errors": {"type": "object", "properties": {"sources": {"type": "object", "properties": {":yourwebsite.com:": {"type": "object", "properties": {"source": {"type": "array", "items": {"type": "string"}, "description": "The specified origin source value is incorrect. Origin source must be a valid IP address or valid domain name. Please specify valid source value.", "example": ["The origin source value is invalid. Please specify an IP address or valid domain name."]}}}}}}}}}
    LECertificateIssuingInProgressForceRetryError: {"title": "Let's Encrypt certificate issuance is in progress", "type": "object", "properties": {"errors": {"type": "object", "properties": {"certificate": {"type": "array", "items": {"type": "string"}, "description": "You cannot force retry Let's Encrypt issuing process until the current issuing attempt is in progress.\nPlease wait until the attempt is completed.", "example": ["You cannot force retry Let's Encrypt issuing process until the current issuing attempt is in progress. Please wait until the attempt is completed."]}}}}}
    cname: {"type": "string", "description": "Delivery domains that will be used for content delivery through a CDN. \n\nDelivery domains should be added to your DNS settings.", "example": "cdn.site.com"}
    LECertificateIsIssuingError: {"title": "Let's Encrypt certificate is issuing", "type": "object", "properties": {"errors": {"type": "object", "properties": {"resource": {"type": "array", "items": {"type": "string"}, "description": "You cannot renew Let's Encrypt certificate because a Let's Encrypt certificate issuing is in progress.\nPlease wait until the issuing is completed and try again.", "example": ["Certificate issuing process have already being launched."]}}}}}
    HTTPConfigResponse: {"title": "HTTP Config", "type": "object", "properties": {"upload": {"type": "object", "$ref": "#/components/schemas/BaseHTTPAction"}, "append": {"type": "object", "$ref": "#/components/schemas/BaseHTTPAction"}, "retry": {"type": "object", "$ref": "#/components/schemas/BaseHTTPAction"}, "auth": {"$ref": "#/components/schemas/BaseHTTPAuth"}, "content_type": {"type": "string", "enum": ["json", "text"], "default": "text"}}}
    OriginGroupSourcesLimitEditError: {"title": "Number of allowed sources has been exceeded", "type": "object", "properties": {"errors": {"type": "object", "properties": {"sources": {"type": "array", "items": {"type": "string"}, "description": "You have exceeded the number of allowed sources in the origin group. Please reduce the number of sources or contact support.", "example": ["Impossible to edit origin group with more than {origins_limit} origins and add more origins on your tariff plan."]}}}}}
    proxy_ssl_ca: {"type": "integer", "nullable": true, "description": "ID of the trusted CA certificate used to verify an origin.\n\nIt can be used only with `\"`proxy_ssl_enabled`\": true`.", "example": null}
    OriginSourcePrivateNetworkError: {"title": "Origin source belongs to private network", "type": "object", "properties": {"errors": {"type": "object", "properties": {"sources": {"type": "object", "properties": {"192.168.0.1": {"type": "object", "properties": {"source": {"type": "array", "items": {"type": "string"}, "description": "The specified origin source belongs to a private network. Please specify the origin source that belongs to a public network.", "example": ["The domain name's IP belongs to a private network. Please use another domain name."]}}}}}}}}}
    OriginSourceBadIPError: {"title": "Origin IP cannot be reserved IP address", "type": "object", "properties": {"errors": {"type": "object", "properties": {"sources": {"type": "object", "properties": {"100.64.0.0": {"type": "object", "properties": {"source": {"type": "array", "items": {"type": "string"}, "description": "The specified origin source is a reserved IP address. Please specify the origin source that belongs to a public network.", "example": ["The IP address cannot be used as an origin source. Please try another IP."]}}}}}}}}}
    schemas-enabled: {"type": "boolean", "readOnly": true, "description": "Enables or disables a CDN resource change by a user.\n\nPossible values:\n- **true** - CDN resource is enabled and can be changed. Content can be delivered.\n- **false** - CDN resource is disabled and cannot be changed. Content can not be delivered.", "example": true}
    service: {"description": "Information about the CDN service status.", "type": "object", "properties": {"enabled": {"type": "boolean", "description": "Defines whether the CDN service is activated.\n\nPossible values:\n- **true** - Service is activated.\n- **false** - Service is not activated.", "example": true}, "status": {"type": "string", "description": "CDN service status.\n\nPossible values:\n- **new** - CDN service is not activated.\n- **trial** - Free trial is in progress.\n- **trialend** - Free trial has ended and CDN service is stopped. All CDN resources are suspended.\n- **activating** - CDN service is being activated. It can take up to 15 minutes.\n- **active** - CDN service is active.\n- **paused** - CDN service is stopped. All CDN resources are suspended.\n- **deleted** - CDN service is stopped. All CDN resources are deleted.", "example": "active"}, "updated": {"type": "string", "description": "Date of the last CDN service status update (ISO 8601/RFC 3339 format, UTC.)", "example": "2021-02-19T15:44:44.925201Z"}}}
    ActivityLogsDetails: {"type": "object", "properties": {"id": {"$ref": "#/components/schemas/ID"}, "user_id": {"$ref": "#/components/schemas/UserID"}, "token_id": {"$ref": "#/components/schemas/TokenID"}, "client_id": {"$ref": "#/components/schemas/ClientID"}, "requested_at": {"$ref": "#/components/schemas/RequestedAt"}, "path": {"$ref": "#/components/schemas/Path"}, "remote_ip_address": {"$ref": "#/components/schemas/RemoteIPAddress"}, "host": {"$ref": "#/components/schemas/Host"}, "method": {"$ref": "#/components/schemas/Method"}, "query_params": {"$ref": "#/components/schemas/QueryParams"}, "data": {"$ref": "#/components/schemas/Data"}, "status_code": {"$ref": "#/components/schemas/StatusCode"}, "actions": {"$ref": "#/components/schemas/Actions"}}}
    ChangeOriginShieldingResponse: {"type": "object", "example": {"shielding_pop": 4}}
    schemas-deleted: {"type": "boolean", "readOnly": true, "description": "Defines whether the rule has been deleted.\n\nPossible values:\n- **true** - Rule has been deleted.\n- **false** - Rule has not been deleted.", "example": false}
    Data: {"type": "object", "description": "Request body."}
    primary_rule: {"type": "integer", "readOnly": true, "nullable": true, "description": "ID of the rule with which the current rule is synchronized within the CDN resource shared cache zone feature.", "example": null}
    LogsUploaderConfigListResponse: {"type": "array", "items": {"$ref": "#/components/schemas/LogsUploaderConfigResponse"}}
    GetSeriesResponse: {"type": "object", "properties": {"resource": {"type": "object", "description": "Resources IDs by which statistics data is grouped."}, "1 (example)": {"type": "object", "description": "ID of CDN resource for which statistics data is shown."}, "region": {"type": "object", "description": "Locations (regions) by which the data is grouped.\n\nPossible values:\n- **asia** – Asia\n- **au** – Australia\n- **cis** – CIS (Commonwealth of Independent States)\n- **eu** – Europe\n- **latam** – Latin America\n- **me** – Middle East\n- **na** – North America\n- **africa** – Africa\n- **sa** – South America"}, "metrics": {"type": "object", "description": "Types of statistics data.\n\nPossible values:\n- **`upstream_bytes`** – Traffic in bytes from an origin server to CDN servers or to origin shielding, if used.\n- **`sent_bytes`** – Traffic in bytes from CDN servers to clients.\n- **`shield_bytes`** – Traffic in bytes from origin shielding to CDN servers.\n- **`backblaze_bytes`** - Traffic in bytes from Backblaze origin.\n- **`total_bytes`** – `shield_bytes`, `upstream_bytes` and `sent_bytes` combined.\n- **`cdn_bytes`** – `sent_bytes` and `shield_bytes` combined.\n- **requests** – Number of requests to edge servers.\n- **`responses_2xx`** – Number of 2xx response codes.\n- **`responses_3xx`** – Number of 3xx response codes.\n- **`responses_4xx`** – Number of 4xx response codes.\n- **`responses_5xx`** – Number of 5xx response codes.\n- **`responses_hit`** – Number of responses with the header Cache: HIT.\n- **`responses_miss`** – Number of responses with the header Cache: MISS.\n- **`response_types`** – Statistics by content type. It returns a number of responses for content with different MIME types.\n- **`cache_hit_traffic_ratio`** – Formula: 1 - `upstream_bytes` / `sent_bytes`. We deduct the non-cached traffic from the total traffic value.\n- **`cache_hit_requests_ratio`** – Share of sending cached content. Formula: `responses_hit` / requests.\n- **`shield_traffic_ratio`** – Origin shielding efficiency: how much more traffic is sent from the origin shielding than from the origin. Formula: (`shield_bytes` - `upstream_bytes`) / `shield_bytes`.\n- **`image_processed`** - Number of images transformed on the Image optimization service.\n- **`request_time`** - Time elapsed between the first bytes of a request were processed and logging after the last bytes were sent to a user.\n- **`upstream_response_time`** - Number of milliseconds it took to receive a response from an origin. If upstream `response_time_` contains several indications for one request (when there is more than one origin,) we summarize them. When aggregating several queries, the average is calculated.\n\nMetrics **`upstream_response_time`** and **`request_time`** should be requested separately from other metrics"}, "upstream_bytes": {"type": "array", "items": {"type": "integer"}, "description": "Bytes from the upstream to the CDN servers. \n\nRepresented by two values:\n- 1543622400 — Time in the UNIX timestamp when statistics were received.\n- 17329220573 — Bytes."}, "sent_bytes": {"type": "array", "items": {"type": "integer"}, "description": "Bytes from CDN servers to the end-users. \n\nRepresented by two values:\n- 1543622400 — Time in the UNIX timestamp when statistics were received.\n- 17329220573 — Bytes."}, "total_bytes": {"type": "array", "items": {"type": "integer"}, "description": "Upstream bytes and `sent_bytes` combined. \n\nRepresented by two values:\n- 1543622400 — Time in the UNIX timestamp when statistics were received.\n- 17329220573 — Bytes."}, "backblaze_bytes": {"type": "array", "items": {"type": "integer"}, "description": "BackBlaze bytes from Backblaze origin.\n\nRepresented by two values:\n\\* 1543622400 — Time in the UNIX timestamp when statistics were received.\n\\* 17329220573 — Bytes."}}, "example": {"resource": {"1": {"region": {"asia": {"metrics": {"sent_bytes": [[1543622400, 17329220573]], "total_bytes": [[1543622400, 17384617989]], "backblaze_bytes": [[1543622400, 17384617989]], "upstream_bytes": [[1543622400, 55397416]]}},
              "cis": {"metrics": {"sent_bytes": [[1543622400, 234582406061]], "total_bytes": [[1543622400, 234677982848]], "backblaze_bytes": [[1543622400, 234677982848]], "upstream_bytes": [[1543622400, 95576787]]}}, "eu": {"metrics": {"sent_bytes": [[1543622400, 243212514764]], "total_bytes": [[1543622400, 243297296511]], "backblaze_bytes": [[1543622400, 243297296511]], "upstream_bytes": [[1543622400, 84781747]]}}, "latam": {"metrics": {"sent_bytes": [[1543622400, 59819837564]], "total_bytes": [[1543622400, 59927133387]], "backblaze_bytes": [[1543622400, 59927133387]], "upstream_bytes": [[1543622400, 107295823]]}}, "me": {"metrics": {"sent_bytes": [[1543622400, 13643432427]], "total_bytes": [[1543622400, 13644762375]], "backblaze_bytes": [[1543622400, 13644762375]], "upstream_bytes": [[1543622400, 1329948]]}}, "na": {"metrics": {"sent_bytes": [[1543622400, 234004049506]], "total_bytes": [[1543622400, 234655863540]], "backblaze_bytes": [[1543622400, 234655863540]], "upstream_bytes": [[1543622400, 651814034]]}}}}, "4777": {"region": {"au": {"metrics": {"sent_bytes": [[1543622400, 490800672]]}}}}}}}
    schemas-id: {"type": "integer", "readOnly": true, "description": "CDN resource ID.", "example": 220}
    JSONParseError: {"title": "Invalid request JSON schema", "type": "object", "properties": {"message": {"type": "string", "description": "This message describes error if json schema from your request is invalid.", "example": "JSON parse error - Expecting ',' delimiter: line 3 column 33 (char 77)\n"}}}
    LERequestAttemptStatus: {"type": "object", "properties": {"id": {"type": "integer", "description": "ID of the attempt to issue the Let's Encrypt certificate.", "example": 1}, "status": {"type": "string", "description": "Status of the attempt to issue the Let's Encrypt certificate.\n\nPossible values:\n- **Done** - Attempt is successful. Let's Encrypt certificate was issued.\n- **Failed** - Attempt failed. Let's Encrypt certificate was not issued.\n- **Cancelled** - Attempt is canceled. Let's Encrypt certificate was not issued.", "example": "DONE"}, "error": {"type": "string", "description": "Brief description of the error that occurred when trying to issue a Let's Encrypt certificate.", "example": ""}, "details": {"type": "string", "description": "Detailed description of the error that occurred when trying to issue a Let's Encrypt certificate.", "example": ""}, "created": {"type": "string", "description": "Date and time when the issuing attempt status was created (ISO 8601/RFC 3339 format, UTC).", "example": "2021-10-29T13:21:01.550849Z"}, "retry_after": {"type": "string", "description": "Date indicating when the certificate issuance limit will be lifted (ISO 8601/RFC 3339 format, UTC).\n\nIt is filled in only if error = RateLimited.", "example": "2024-01-01T10:00:00Z"}}}
    OriginGroupNameNotUniqueError: {"title": "Origin group name must be unique", "type": "object", "properties": {"errors": {"type": "object", "properties": {"name": {"type": "array", "items": {"type": "string"}, "description": "The specified origin group name is already used by another origin group. Try another name.", "example": ["Origin Group name should be unique."]}}}}}
    S3AmazonConfigResponse: {"title": "S3 Amazon Config", "properties": {"access_key_id": {"type": "string"}, "region": {"type": "string"}, "bucket_name": {"type": "string"}, "directory": {"type": "string", "nullable": true}}}
    AddSSL: {"anyOf": [{"type": "object", "title": "Own Certificate", "$ref": "#/components/schemas/CreateSSlPayload"}, {"type": "object", "title": "Let's Encrypt Certificate", "properties": {"name": {"type": "string", "description": "SSL certificate name. It must be unique.", "example": "New Let's Encrypt certificate"}, "automated": {"type": "boolean", "description": "Must be **true** to issue certificate automatically.", "example": true}}, "required": ["name", "automated"]}]}
    LogsUploaderPolicyResponse: {"type": "object", "properties": {"id": {"type": "integer", "readOnly": true}, "client_id": {"type": "integer", "description": "Client that owns the policy.", "readOnly": true}, "created": {"type": "string", "format": "date-time", "readOnly": true, "description": "Time when logs uploader policy was created."}, "updated": {"type": "string", "format": "date-time", "readOnly": true, "description": "Time when logs uploader policy was updated."}, "include_empty_logs": {"type": "boolean", "description": "Include empty logs in the upload."}, "include_shield_logs": {"type": "boolean", "description": "Include logs from origin shielding in the upload."}, "name": {"type": "string", "description": "Name of the policy.", "maxLength": 255}, "description": {"type": "string", "description": "Description of the policy.", "maxLength": 255}, "retry_interval_minutes": {"type": "integer", "description": "Interval in minutes to retry failed uploads.", "maximum": 60, "minimum": 5}, "rotate_interval_minutes": {"type": "integer", "description": "Interval in minutes to rotate logs.", "maximum": 60, "minimum": 5}, "rotate_threshold_mb": {"type": "integer", "description": "Threshold in MB to rotate logs.", "maximum": 500, "minimum": 5, "nullable": true}, "rotate_threshold_lines": {"type": "integer", "description": "Threshold in lines to rotate logs.", "maximum": 10000, "minimum": 0}, "date_format": {"type": "string", "description": "Date format for logs.", "maxLength": 255}, "field_delimiter": {"type": "string", "description": "Field delimiter for logs.", "maxLength": 10, "example": ";"}, "field_separator": {"type": "string", "description": "Field separator for logs.", "minLength": 1, "maxLength": 10}, "fields": {"type": "array", "items": {"type": "string", "maxLength": 255}, "description": "List of fields to include in logs."}, "file_name_template": {"type": "string", "description": "Template for log file name.", "maxLength": 255}, "format_type": {"type": "string", "description": "Format type for logs.", "maxLength": 255}, "tags": {"type": "object", "description": "Tags allow for dynamic decoration of logs by adding predefined fields to the log format. These tags serve as customizable key-value pairs that can be included in log entries to enhance context and readability.", "additionalProperties": {"type": "string", "maxLength": 50}}, "related_uploader_configs": {"type": "array", "items": {"type": "integer"}, "description": "List of logs uploader configs that use this policy."}}, "example": {"id": 123, "client_id": 123, "created": "2023-11-07T05:31:56Z", "updated": "2023-11-07T05:31:56Z", "include_empty_logs": true, "include_shield_logs": true, "name": "Policy", "description": "New policy", "retry_interval_minutes": 32, "rotate_interval_minutes": 32, "rotate_threshold_mb": 252, "rotate_threshold_lines": 5000, "date_format": "[02/Jan/2006:15:04:05 -0700]", "field_delimiter": ",", "field_separator": ";", "fields": ["remote_addr", "status"], "file_name_template": "{{YYYY}}_{{MM}}_{{DD}}_{{HH}}_{{mm}}_{{ss}}_access.log.gz", "format_type": "flvproxy", "tags": {}, "related_uploader_configs": [123]}}
    schemas-preset_applied: {"type": "boolean", "readOnly": true, "description": "Defines whether the rule has an applied preset.\n\nPossible values:\n- **true** - Rule has a preset applied.\n- **false** - Rule does not have a preset applied.\n\nIf a preset is applied to the rule, the options included in the preset cannot be edited for the rule.", "example": false}
    default: {"type": "boolean", "readOnly": true, "description": "Defines whether the template is a system template developed for common cases. System templates are available to all customers.\n\nPossible values:\n- **true** - Template is a system template and cannot be changed by a user.\n- **false** - Template is a custom template and can be changed by a user.", "example": false}
    schemas-name: {"type": "string", "nullable": true, "description": "CDN resource name.", "example": "Resource for images"}
    ChangeResource: {"type": "object", "properties": {"active": {"$ref": "#/components/schemas/active"}, "name": {"$ref": "#/components/schemas/schemas-name"}, "description": {"$ref": "#/components/schemas/description"}, "secondaryHostnames": {"$ref": "#/components/schemas/secondaryHostnames"}, "originGroup": {"$ref": "#/components/schemas/originGroup"}, "originProtocol": {"$ref": "#/components/schemas/originProtocol"}, "sslEnabled": {"$ref": "#/components/schemas/sslEnabled"}, "sslData": {"$ref": "#/components/schemas/sslData"}, "proxy_ssl_enabled": {"$ref": "#/components/schemas/proxy_ssl_enabled"}, "proxy_ssl_ca": {"$ref": "#/components/schemas/proxy_ssl_ca"}, "proxy_ssl_data": {"$ref": "#/components/schemas/proxy_ssl_data"}, "waap_api_domain_enabled": {"$ref": "#/components/schemas/waap_api_domain_enabled"}, "options": {"type": "object", "$ref": "#/components/schemas/resource_options"}}, "required": ["originGroup"]}
    LogsUploaderValidationResponse: {"type": "object", "properties": {"status": {"type": "string", "enum": ["in_progress", "successful", "failed"], "description": "Status of the validation."}, "code": {"type": "integer", "description": "Error code indicating the type of validation error."}, "updated": {"type": "string", "format": "date-time", "description": "Time when the validation status was updated."}, "details": {"type": "string", "description": "Error message if the validation failed."}}}
    description: {"type": "string", "description": "Optional comment describing the CDN resource.", "example": "My resource"}
    AuthRequiredWithAwsSignatureV4ValueError: {"title": "Origin Group has to have auth with \"awsSignatureV4\" auth type", "type": "object", "properties": {"errors": {"type": "object", "properties": {"auth": {"type": "array", "items": {"type": "string"}, "description": "Origin Group has to have auth with \"awsSignatureV4\" auth type.", "example": ["Origin Group has to have auth with `awsSignatureV4` auth type."]}}}}}
    resource_options: {"type": "object", "description": "List of options that can be configured for the CDN resource.\n\nIn case of `null` value the option is not added to the CDN resource.\nOption may inherit its value from the global account settings.", "properties": {"allowedHttpMethods": {"$ref": "#/components/schemas/allowedHttpMethods"}, "bot_protection": {"$ref": "#/components/schemas/bot_protection"}, "brotli_compression": {"$ref": "#/components/schemas/brotli_compression"}, "browser_cache_settings": {"$ref": "#/components/schemas/browser_cache_settings"}, "cache_http_headers": {"$ref": "#/components/schemas/cache_http_headers"}, "cors": {"$ref": "#/components/schemas/cors"}, "country_acl": {"$ref": "#/components/schemas/country_acl"}, "disable_cache": {"$ref": "#/components/schemas/disable_cache"}, "disable_proxy_force_ranges": {"$ref": "#/components/schemas/disable_proxy_force_ranges"}, "edge_cache_settings": {"$ref": "#/components/schemas/edge_cache_settings"}, "fastedge": {"$ref": "#/components/schemas/fastedge"}, "fetch_compressed": {"$ref": "#/components/schemas/fetch_compressed"}, "follow_origin_redirect": {"$ref": "#/components/schemas/follow_origin_redirect"}, "force_return": {"$ref": "#/components/schemas/force_return"}, "forward_host_header": {"$ref": "#/components/schemas/forward_host_header"}, "gzipOn": {"$ref": "#/components/schemas/gzipOn"}, "hostHeader": {"$ref": "#/components/schemas/hostHeader"}, "http3_enabled": {"$ref": "#/components/schemas/http3_enabled"}, "ignore_cookie": {"$ref": "#/components/schemas/ignore_cookie"}, "ignoreQueryString": {"$ref": "#/components/schemas/ignoreQueryString"}, "image_stack": {"$ref": "#/components/schemas/image_stack"}, "ip_address_acl": {"$ref": "#/components/schemas/ip_address_acl"}, "limit_bandwidth": {"$ref": "#/components/schemas/limit_bandwidth"}, "proxy_cache_key": {"$ref": "#/components/schemas/proxy_cache_key"}, "proxy_cache_methods_set": {"$ref": "#/components/schemas/proxy_cache_methods_set"}, "proxy_connect_timeout": {"$ref": "#/components/schemas/proxy_connect_timeout"}, "proxy_read_timeout": {"$ref": "#/components/schemas/proxy_read_timeout"}, "query_params_blacklist": {"$ref": "#/components/schemas/query_params_blacklist"}, "query_params_whitelist": {"$ref": "#/components/schemas/query_params_whitelist"}, "query_string_forwarding": {"$ref": "#/components/schemas/query_string_forwarding"}, "redirect_http_to_https": {"$ref": "#/components/schemas/redirect_http_to_https"}, "redirect_https_to_http": {"$ref": "#/components/schemas/redirect_https_to_http"}, "referrer_acl": {"$ref": "#/components/schemas/referrer_acl"}, "request_limiter": {"$ref": "#/components/schemas/request_limiter"}, "response_headers_hiding_policy": {"$ref": "#/components/schemas/response_headers_hiding_policy"}, "rewrite": {"$ref": "#/components/schemas/rewrite"}, "secure_key": {"$ref": "#/components/schemas/secure_key"}, "slice": {"$ref": "#/components/schemas/slice"}, "sni": {"$ref": "#/components/schemas/sni"}, "stale": {"$ref": "#/components/schemas/stale"}, "static_response_headers": {"$ref": "#/components/schemas/static_response_headers"}, "staticHeaders": {"$ref": "#/components/schemas/staticHeaders"}, "staticRequestHeaders": {"$ref": "#/components/schemas/staticRequestHeaders"}, "tls_versions": {"$ref": "#/components/schemas/tls_versions"}, "use_default_le_chain": {"$ref": "#/components/schemas/use_default_le_chain"}, "use_dns01_le_challenge": {"$ref": "#/components/schemas/use_dns01_le_challenge"}, "use_rsa_le_cert": {"$ref": "#/components/schemas/use_rsa_le_cert"}, "user_agent_acl": {"$ref": "#/components/schemas/user_agent_acl"}, "waap": {"$ref": "#/components/schemas/waap"}, "websockets": {"$ref": "#/components/schemas/websockets"}}}
    NotLECertificateSelectedError: {"title": "Not Let's Encrypt certificate selected", "type": "object", "properties": {"errors": {"type": "object", "properties": {"certificate": {"type": "array", "items": {"type": "string"}, "description": "The specified certificate is not Let's Encrypt certificate. Please check the certificate ID.", "example": ["Certificate doesn't support automatic renewal."]}}}}}
    OriginSourceEqualResourceCnameError: {"title": "Origin source is equal to resource's CNAME", "type": "object", "properties": {"errors": {"type": "object", "properties": {"sources": {"type": "object", "properties": {"yourwebsite.com": {"type": "object", "properties": {"source": {"type": "array", "items": {"type": "string"}, "description": "The specified origin source is equal to the linked resource's CNAME. Please use origin sources that are different from the linked resource's CNAME.", "example": ["Origin source is equal to attached resource`s CNAME."]}}}}}}}}}
    ip_address_acl: {"type": "object", "nullable": true, "description": "Controls access to the CDN resource content for specific IP addresses.\n\nIf you want to use IPs from our CDN servers IP list for IP ACL configuration, you have to independently monitor their relevance.\nWe recommend you use a script for automatically update IP ACL. [Read more.](/docs/api-reference/cdn/ip-addresses-list/get-cdn-servers-ip-addresses)", "properties": {"enabled": {"$ref": "#/components/schemas/parameters-enabled"}, "policy_type": {"type": "string", "enum": ["allow", "deny"], "description": "IP access policy type.\n\nPossible values:\n- **allow** - Allow access to all IPs except IPs specified in \"`excepted_values`\" field.\n- **deny** - Deny access to all IPs except IPs specified in \"`excepted_values`\" field."}, "excepted_values": {"type": "array", "uniqueItems": true, "maxItems": 600, "items": {"type": "string", "maxLength": 255, "format": "ipv4net or ipv6net"}, "description": "List of IP addresses with a subnet mask.\n\nThe meaning of the parameter depends on `policy_type` value:\n- **allow** - List of IP addresses for which access is prohibited.\n- **deny** - List of IP addresses for which access is allowed.\n\nExamples:\n- `192.168.3.2/32`\n- `2a03:d000:2980:7::8/128`"}}, "required": ["enabled", "excepted_values", "policy_type"], "example": {"enabled": true, "policy_type": "deny", "excepted_values": ["192.168.1.100/32"]}}
    PurgeStatusesListResponse: {"type": "array", "items": {"$ref": "#/components/schemas/PurgeStatusResponse"}}
    WildcardResourceCnameSSLLEError: {"title": "Wildcard resource's cname", "type": "object", "properties": {"errors": {"type": "object", "properties": {"sslData": {"type": "array", "items": {"type": "string"}, "description": "The resource has a wildcard additional CNAME. In this case, you can use only your own certificate\nfor content delivery via HTTPS.", "example": ["We cannot issue a Let's Encrypt certificate for a resource with a wildcard cname."]}}}}}
    cdn_client: {"type": "integer", "readOnly": true, "description": "ID of an account to which the CDN resource belongs.", "example": 170}
    waap: {"type": "object", "nullable": true, "description": "Allows to enable WAAP (Web Application and API Protection).", "properties": {"enabled": {"$ref": "#/components/schemas/parameters-enabled"}, "value": {"type": "boolean", "description": "Possible values:\n- **true** - Option is enabled.\n- **false** - Option is disabled."}}, "required": ["enabled", "value"], "example": {"enabled": true, "value": true}}
    GetSSLAnswerList: {"type": "array", "items": {"$ref": "#/components/schemas/GetSSLAnswer"}}
    NotLECertificateStatusError: {"title": "Not Let's Encrypt certificate selected", "type": "object", "properties": {"errors": {"type": "object", "properties": {"certificate": {"type": "array", "items": {"type": "string"}, "description": "The specified certificate is not Let's Encrypt certificate. Please check the certificate ID.", "example": ["Status is available for Let's Encrypt certificates only."]}}}}}
    BaseHTTPAuth: {"title": "HTTP Auth", "type": "object", "properties": {"type": {"type": "string", "enum": ["token"]}, "config": {"type": "object", "anyOf": ["$ref": "#/components/schemas/BaseHTTPAuthTokenConfig"]}}}
    S3OSSConfig: {"title": "S3 OSS Config", "allOf": ["$ref": "#/components/schemas/BaseS3Config", {"type": "object", "properties": {"region": {"type": "string", "nullable": true}}, "required": ["access_key_id", "secret_access_key", "bucket_name"]}]}
    hostHeader: {"type": "object", "nullable": true, "description": "Sets the Host header that CDN servers use when request content from an origin server.\nYour server must be able to process requests with the chosen header.\n\nIf the option is `null`, the Host Header value is equal to first CNAME.\n\n`hostHeader` and `forward_host_header` options cannot be enabled simultaneously.", "properties": {"enabled": {"$ref": "#/components/schemas/parameters-enabled"}, "value": {"type": "string", "maxLength": 2048, "pattern": "^[a-z0-9.\\-_:]*$", "description": "Host Header value."}}, "required": ["enabled", "value"], "example": {"enabled": true, "value": "host.com"}}
    OriginSourceForbiddenNetworkError: {"title": "Origin source belongs to forbidden network", "type": "object", "properties": {"errors": {"type": "object", "properties": {"sources": {"type": "object", "properties": {"forbiddenwebsite.com": {"type": "object", "properties": {"source": {"type": "array", "items": {"type": "string"}, "description": "The specified origin source belongs to a forbidden network. Please specify the origin source that belongs to a public network.", "example": ["The domain name's IP belongs to a forbidden network. Please use another domain name."]}}}}}}}}}
    CannotLinkYourSSLCertificate: {"title": "Cannot link your SSL certificate", "type": "object", "properties": {"errors": {"type": "object", "properties": {"sslData": {"type": "array", "items": {"type": "string"}, "description": "You cannot link your SSL certificate because a Let's Encrypt certificate issuing attempt is in progress.\nPlease wait until the attempt is completed and try again.", "example": ["You cannot add a certificate because the current issuing attempt is in progress. Please wait until the attempt is completed and try again."]}}}}}
    enabled: {"type": "boolean", "description": "Enables or disables an origin source in the origin group.\n\nPossible values:\n- **true** - Origin is enabled and the CDN uses it to pull content.\n- **false** - Origin is disabled and the CDN does not use it to pull content.\n\nOrigin group must contain at least one enabled origin.", "example": true}
    StatusCode: {"type": "integer", "description": "Status code that is returned in the response."}
    SourcesShouldBeEnabledError: {"title": "Enable at least one origin source", "type": "object", "properties": {"errors": {"type": "object", "properties": {"sources": {"type": "object", "properties": {"yourwebsite.com": {"type": "object", "properties": {"enabled": {"type": "array", "items": {"type": "string"}, "description": "This active origin group should have one enabled origin source. Please enable one origin source.", "example": ["Origin Group must have at least one active origin sources."]}}}}}}}}}
    GetPublicIPList: {"type": "object", "properties": {"addresses": {"type": "array", "description": "List of IPv4 addresses.", "items": {"type": "string"}, "example": ["92.223.74.19/32"]}, "addresses_v6": {"type": "array", "description": "List of IPv6 addresses.", "items": {"type": "string"}, "example": ["2a03:90c0:191:2801::8/128"]}}}
    ResourceListResponse: {"type": "array", "items": {"$ref": "#/components/schemas/ResourceResponse"}}
    OriginSourceIPv4Error: {"title": "Origin domain IP is not IPv4", "type": "object", "properties": {"errors": {"type": "object", "properties": {"sources": {"type": "object", "properties": {"ipv6domain.com": {"type": "object", "properties": {"source": {"type": "array", "items": {"type": "string"}, "description": "The specified origin domain IP is not IPv4. Please specify a domain that has an IPv4 address.", "example": ["The domain name's IP is not IPv4. Please use another domain name."]}}}}}}}}}
    RuleNameAlreadyExistsError: {"title": "Rule with the same name already exists", "type": "object", "properties": {"errors": {"type": "object", "properties": {"name": {"type": "array", "description": "The specified name is already used by another rule of the resource. Try another name.", "items": {"type": "string"}, "example": ["This field should be unique."]}}}}}
    PurgeStatusResponse: {"type": "object", "properties": {"purge_id": {"$ref": "#/components/schemas/purge_id"}, "status": {"$ref": "#/components/schemas/schemas-status"}, "resource": {"$ref": "#/components/schemas/resource"}, "payload": {"$ref": "#/components/schemas/payload"}, "created": {"$ref": "#/components/schemas/schemas-created"}, "purge_type": {"$ref": "#/components/schemas/purge_type"}}}
    GetRawLogsAggregatedStat: {"type": "object", "properties": {"resource": {"type": "object", "description": "Resources IDs by which statistics data is grouped.."}, "1 (example)": {"type": "object", "description": "CDN resource ID for which statistics data is shown."}, "metrics": {"type": "object", "description": "Statistics parameters."}, "raw_logs_usage": {"type": "string", "description": "Number of resources that used raw logs."}}, "example": {"resource": {"1": {"metrics": {"raw_logs_usage": 1}}}}}
    RawLogsFolderBase: {"type": "object", "properties": {"id": {"type": "integer", "description": "Parameter meaning depends on the value of the \"`storage_type`\" value:\n- **s3** - S3 bucket ID.\n- **ftp/sftp** - FTP/SFTP folder ID."}, "bucket": {"type": "string", "description": "S3 bucket name. \n\nThe field is required if \"`storage_type`\": **s3**."}, "folder": {"type": "string", "description": "Parameter meaning depends on the value of the \"`storage_type`\" value:\n\n- **s3** - S3 bucket sub-folder name (optional.)\n- **ftp/sftp** - FTP/SFTP folder name (required.)"}}}
    CreateLogsUploaderPolicy: {"type": "object", "properties": {"include_empty_logs": {"type": "boolean", "description": "Include empty logs in the upload.", "default": false}, "include_shield_logs": {"type": "boolean", "description": "Include logs from origin shielding in the upload.", "default": false}, "name": {"type": "string", "description": "Name of the policy.", "maxLength": 255, "default": "Policy"}, "description": {"type": "string", "description": "Description of the policy.", "maxLength": 255}, "retry_interval_minutes": {"type": "integer", "description": "Interval in minutes to retry failed uploads.", "maximum": 60, "minimum": 5, "default": 60}, "rotate_interval_minutes": {"type": "integer", "description": "Interval in minutes to rotate logs.", "maximum": 60, "minimum": 5, "default": 5}, "rotate_threshold_mb": {"type": "integer", "description": "Threshold in MB to rotate logs.", "minimum": 100, "maximum": 2147483647, "nullable": true, "default": null}, "rotate_threshold_lines": {"type": "integer", "description": "Threshold in lines to rotate logs.", "maximum": 10000, "minimum": 0, "default": 0}, "date_format": {"type": "string", "description": "Date format for logs.", "maxLength": 255}, "field_delimiter": {"type": "string", "description": "Field delimiter for logs.", "maxLength": 10, "default": "\""}, "field_separator": {"type": "string", "description": "Field separator for logs.", "minLength": 1, "maxLength": 10, "default": " "}, "fields": {"type": "array", "items": {"type": "string", "maxLength": 255}, "description": "List of fields to include in logs.", "default": ["remote_addr", "-", "remote_user", "time_local", "request", "status", "body_bytes_sent", "http_referer", "http_user_agent", "bytes_sent", "hostname", "scheme", "host", "request_time", "upstream_response_time", "request_length", "http_range", "dc", "upstream_cache_status", "upstream_response_length", "upstream_addr", "gcdn_api_client_id", "gcdn_api_resource_id", "uid_got", "uid_set", "geoip2_country_code", "geoip2_city", "shield_type", "real_server_addr", "server_port", "upstream_status", "-", "upstream_connect_time", "upstream_header_time", "shard_addr", "geoip2_data_asnumber", "connection", "connection_requests", "http_traceparent", "http_x_forwarded_proto", "gcdn_internal_status_code", "ssl_cipher", "ssl_session_id", "ssl_session_reused", "sent_http_content_type", "real_tcpinfo_rtt", "server_country_code", "gcdn_tcpinfo_snd_cwnd", "gcdn_tcpinfo_total_retrans", "gcdn_rule_id"]}, "file_name_template": {"type": "string", "description": "Template for log file name.", "maxLength": 255, "default": "{{YYYY}}/{{MM}}/{{DD}}/{{HH}}/{{mm}}/{{ss}}/{{HOST}}_{{CNAME}}_access.log.gz"}, "format_type": {"type": "string", "description": "Format type for logs.", "maxLength": 255}, "tags": {"type": "object", "description": "Tags allow for dynamic decoration of logs by adding predefined fields to the log format. These tags serve as customizable key-value pairs that can be included in log entries to enhance context and readability.", "additionalProperties": {"type": "string", "maxLength": 50}}}, "example": {"include_empty_logs": true, "include_shield_logs": true, "name": "Policy", "description": "New policy", "retry_interval_minutes": 32, "rotate_interval_minutes": 32, "rotate_threshold_mb": 252, "rotate_threshold_lines": 5000, "date_format": "[02/Jan/2006:15:04:05 -0700]", "field_delimiter": ",", "field_separator": ";", "fields": ["remote_addr", "status"], "file_name_template": "{{YYYY}}_{{MM}}_{{DD}}_{{HH}}_{{mm}}_{{ss}}_access.log.gz", "format_type": "flvproxy", "tags": {}, "related_uploader_configs": [123]}}
    websockets: {"type": "object", "nullable": true, "description": "Enables or disables WebSockets connections to an origin server.", "properties": {"enabled": {"$ref": "#/components/schemas/parameters-enabled"}, "value": {"type": "boolean", "description": "Possible values:\n- **true** - Option is enabled.\n- **false** - Option is disabled."}}, "required": ["enabled", "value"], "example": {"enabled": true, "value": true}}
    S3OSSConfigResponse: {"title": "S3 OSS Config", "allOf": ["$ref": "#/components/schemas/S3AmazonConfigResponse", {"type": "object", "properties": {"region": {"type": "string", "nullable": true}}}]}
    schemas_components-schemas-name: {"type": "string", "description": "Rule template name.", "example": "All images template"}
    bot_protection: {"type": "object", "nullable": true, "description": "Allows to prevent online services from overloading and ensure your business workflow running smoothly.", "properties": {"enabled": {"$ref": "#/components/schemas/parameters-enabled"}, "bot_challenge": {"type": "object", "description": "Controls the bot challenge module state.", "properties": {"enabled": {"type": "boolean", "default": false, "description": "Possible values:\n- **true** - Bot challenge is enabled.\n- **false** - Bot challenge is disabled."}}}}, "required": ["enabled", "bot_challenge"], "example": {"enabled": true, "bot_challenge": {"enabled": true}}}
    components-schemas-name: {"type": "string", "maxLength": 255, "description": "Rule name.", "example": "My first rule"}
    sslEnabled: {"type": "boolean", "default": false, "description": "Defines whether the HTTPS protocol enabled for content delivery.\n\nPossible values:\n- **true** - HTTPS is enabled.\n- **false** - HTTPS is disabled.", "example": false}
    S3V1ConfigResponse: {"title": "S3 V1 Config", "allOf": ["$ref": "#/components/schemas/S3GcoreConfigResponse"]}
    cdn_template: {"type": "boolean", "readOnly": true, "description": "Determines whether the rule is a template.", "example": true}
    components-schemas-deleted: {"type": "boolean", "readOnly": true, "description": "Defines whether the template has been deleted.\n\nPossible values:\n- **true** - Template has been deleted.\n- **false** - Template has not been deleted.", "example": false}
    proxy_ssl_data: {"type": "integer", "nullable": true, "description": "ID of the SSL certificate used to verify an origin.\n\nIt can be used only with `\"`proxy_ssl_enabled`\": true`.", "example": null}
    ClientID: {"type": "integer", "description": "ID of the client who made the request."}
    cors: {"type": "object", "nullable": true, "description": "Enables or disables CORS (Cross-Origin Resource Sharing) header support. \n\nCORS header support allows the CDN to add the Access-Control-Allow-Origin header to a response to a browser.", "properties": {"enabled": {"$ref": "#/components/schemas/parameters-enabled"}, "value": {"type": "array", "items": {"type": "string"}, "description": "Value of the Access-Control-Allow-Origin header.\n\nPossible values:\n- **Adds \\* as the Access-Control-Allow-Origin header value** - Content will be uploaded for requests from any domain.\n`\"value\": [\"\\*\"]`\n- **Adds \"$`http_origin`\" as the Access-Control-Allow-Origin header value if the origin matches one of the listed domains** - Content will be uploaded only for requests from the domains specified in the field.\n`\"value\": [\"domain.com\", \"second.dom.com\"]`\n- **Adds \"$`http_origin`\" as the Access-Control-Allow-Origin header value** - Content will be uploaded for requests from any domain, and the domain from which the request was sent will be added to the \"Access-Control-Allow-Origin\" header in the response.\n`\"value\": [\"$`http_origin`\"]`"}, "always": {"type": "boolean", "default": false, "description": "Defines whether the Access-Control-Allow-Origin header should be added to a response from CDN regardless of response code.\n\nPossible values:\n- **true** - Header will be added to a response regardless of response code.\n- **false** - Header will only be added to responses with codes: 200, 201, 204, 206, 301, 302, 303, 304, 307, 308."}}, "required": ["enabled", "value"], "example": {"enabled": true, "value": ["domain.com", "domain2.com"], "always": true}}
    waap_domain_id: {"type": "string", "readOnly": true, "description": "The ID of the associated WAAP domain."}
    fastedge: {"type": "object", "nullable": true, "description": "Allows to configure FastEdge app to be called on different request/response phases.\n\nNote: At least one of `on_request_headers`, `on_request_body`, `on_response_headers`, or `on_response_body` must be specified.", "properties": {"enabled": {"$ref": "#/components/schemas/parameters-enabled"}, "on_request_headers": {"allOf": ["$ref": "#/components/schemas/FastEdgeTriggerSettings", "description": "Allows to configure FastEdge application that will be called to handle request headers as soon as CDN receives incoming HTTP request."]}, "on_request_body": {"allOf": ["$ref": "#/components/schemas/FastEdgeTriggerSettings", "description": "Allows to configure FastEdge application that will be called to handle request body as soon as CDN receives incoming HTTP request."]}, "on_response_headers": {"allOf": ["$ref": "#/components/schemas/FastEdgeTriggerSettings", "description": "Allows to configure FastEdge application that will be called to handle response headers before CDN sends the HTTP response."]}, "on_response_body": {"allOf": ["$ref": "#/components/schemas/FastEdgeTriggerSettings", "description": "Allows to configure FastEdge application that will be called to handle response body before CDN sends the HTTP response."]}}, "required": ["enabled"], "example": {"enabled": true, "on_request_headers": {"enabled": true, "app_id": "1001", "interrupt_on_error": true}}}
    use_dns01_le_challenge: {"type": "object", "nullable": true, "description": "DNS-01 challenge to issue a Let's Encrypt certificate for the resource.\n\nDNS service should be activated to enable this option.", "properties": {"enabled": {"$ref": "#/components/schemas/parameters-enabled"}, "value": {"type": "boolean", "description": "Possible values:\n- **true** - DNS-01 challenge is used to issue Let's Encrypt certificate.\n- **false** - HTTP-01 challenge is used to issue Let's Encrypt certificate."}}, "required": ["enabled", "value"], "example": {"enabled": true, "value": true}}
    fetch_compressed: {"type": "object", "nullable": true, "description": "Makes the CDN request compressed content from the origin.\n\nThe origin server should support compression. CDN servers will not decompress your content even if a user browser does not accept compression. \n\nNotes:\n\n1. `fetch_compressed` is not supported with `gzipON` or `brotli_compression` or `slice` options enabled.\n2. `fetch_compressed` overrides `gzipON` and `brotli_compression` in rule. If you enable it in CDN resource and want to use `gzipON` and `brotli_compression` in a rule, you have to specify `\"`fetch_compressed`\": false` in the rule.", "properties": {"enabled": {"$ref": "#/components/schemas/parameters-enabled"}, "value": {"type": "boolean", "description": "Possible values:\n- **true** - Option is enabled.\n- **false** - Option is disabled."}}, "required": ["enabled", "value"], "example": {"enabled": true, "value": false}}
    schemas-originGroup: {"type": "integer", "nullable": true, "description": "ID of the origin group to which the rule is applied.\n\nIf the origin group is not specified, the rule is applied to the origin group that the CDN resource is associated with.", "example": null}
    S3OtherConfigResponse: {"title": "S3 Other Config", "allOf": ["$ref": "#/components/schemas/S3GcoreConfigResponse"]}
    RemoteIPAddress: {"type": "string", "description": "IP address from which the request was made."}
    weight: {"type": "integer", "minimum": 1, "maximum": 2147483647, "description": "Rule execution order: from lowest (1) to highest.\n\nIf requested URI matches multiple rules, the one higher in the order of the rules will be applied.", "example": 1}
    referrer_acl: {"type": "object", "nullable": true, "description": "Controls access to the CDN resource content for specified domain names.", "properties": {"enabled": {"$ref": "#/components/schemas/parameters-enabled"}, "policy_type": {"type": "string", "enum": ["allow", "deny"], "description": "Policy type.\n\nPossible values:\n- **allow** - Allow access to all domain names except the domain names specified in `excepted_values` field.\n- **deny** - Deny access to all domain names except the domain names specified in `excepted_values` field."}, "excepted_values": {"type": "array", "uniqueItems": true, "maxItems": 600, "items": {"type": "string", "maxLength": 255, "format": "domain or wildcard"}, "description": "List of domain names or wildcard domains (without protocol: `http://` or `https://`.)\n\nThe meaning of the parameter depends on `policy_type` value:\n- **allow** - List of domain names for which access is prohibited.\n- **deny** - List of IP domain names for which access is allowed.\n\nExamples:\n- `example.com`\n- `\\*.example.com`"}}, "required": ["enabled", "excepted_values", "policy_type"], "example": {"enabled": true, "policy_type": "deny", "excepted_values": ["example.com", "*.example.net"]}}
    vp_enabled: {"type": "boolean", "readOnly": true, "description": "Defines whether the CDN resource is integrated with the Streaming Platform.\n\nPossible values:\n- **true** - CDN resource is configured for Streaming Platform. Changing resource settings can affect its operation.\n- **false** - CDN resource is not configured for Streaming Platform.", "example": false}
    S3GcoreConfig: {"title": "S3 Gcore Config", "allOf": ["$ref": "#/components/schemas/BaseS3Config", {"type": "object", "properties": {"endpoint": {"type": "string"}, "use_path_style": {"type": "boolean", "default": true}}, "required": ["access_key_id", "secret_access_key", "bucket_name", "endpoint", "region"]}]}
    forward_host_header: {"type": "object", "nullable": true, "description": "Forwards the Host header from a end-user request to an origin server.\n\n`hostHeader` and `forward_host_header` options cannot be enabled simultaneously.", "properties": {"enabled": {"$ref": "#/components/schemas/parameters-enabled"}, "value": {"type": "boolean", "description": "Possible values:\n- **true** - Option is enabled.\n- **false** - Option is disabled."}}, "required": ["enabled", "value"], "example": {"enabled": false, "value": false}}
    originGroup_name: {"type": "string", "readOnly": true, "description": "Origin group name.", "example": "Resource origin group"}
    staticRequestHeaders: {"type": "object", "nullable": true, "description": "Custom HTTP Headers for a CDN server to add to request. Up to fifty custom HTTP Headers can be specified.", "properties": {"enabled": {"$ref": "#/components/schemas/parameters-enabled"}, "value": {"type": "object", "description": "A MAP for static headers in a format of `header_name: header_value`.\n\nRestrictions:\n- **Header name** - Maximum 255 symbols, may contain Latin letters (A-Z, a-z), numbers (0-9), dashes, and underscores.\n- **Header value** - Maximum 512 symbols, may contain letters (a-z), numbers (0-9), spaces, and symbols (`~!@#%%^&\\*()-_=+ /|\\\";:?.,><{}[]). Must start with a letter, number, asterisk or {.", "additionalProperties": {"type": "string"}}}, "required": ["enabled", "value"], "example": {"enabled": true, "value": {"Header-One": "Value 1", "Header-Two": "Value 2"}}}
    schemas-active: {"type": "boolean", "description": "Enables or disables a rule.\n\nPossible values:\n- **true** - Rule is active, rule settings are applied.\n- **false** - Rule is inactive, rule settings are not applied.", "example": true}
    ignore_cookie: {"type": "object", "nullable": true, "description": "Defines whether the files with the Set-Cookies header are cached as one file or as different ones.", "properties": {"enabled": {"$ref": "#/components/schemas/parameters-enabled"}, "value": {"type": "boolean", "description": "Possible values:\n- **true** - Option is enabled, files with cookies are cached as one file.\n- **false** - Option is disabled, files with cookies are cached as different files."}}, "required": ["enabled", "value"], "example": {"enabled": true, "value": true}}
    query_params_blacklist: {"type": "object", "nullable": true, "description": "Files with the specified query parameters are cached as one object, files with other parameters are cached as different objects.\n\n`ignoreQueryString`, `query_params_whitelist` and `query_params_blacklist` options cannot be enabled simultaneously.", "properties": {"enabled": {"$ref": "#/components/schemas/parameters-enabled"}, "value": {"type": "array", "items": {"type": "string"}, "description": "List of query parameters."}}, "required": ["enabled", "value"], "example": {"enabled": true, "value": ["some", "blacklisted", "query"]}}
    schemas-client: {"type": "integer", "readOnly": true, "description": "Client ID", "example": 7}
    force_return: {"type": "object", "nullable": true, "description": "Applies custom HTTP response codes for CDN content.\n\nThe following codes are reserved by our system and cannot be specified in this option: 408, 444, 477, 494, 495, 496, 497, 499.", "properties": {"enabled": {"$ref": "#/components/schemas/parameters-enabled"}, "code": {"type": "integer", "minimum": 100, "maximum": 599, "description": "Status code value."}, "body": {"type": "string", "maxLength": 255, "description": "URL for redirection or text."}, "time_interval": {"type": "object", "nullable": true, "description": "Controls the time at which a custom HTTP response code should be applied. By default, a custom HTTP response code is applied at any time.", "required": ["start_time", "end_time"], "properties": {"start_time": {"type": "string", "format": "time", "description": "Time from which a custom HTTP response code should be applied. Indicated in 24-hour format."}, "end_time": {"type": "string", "format": "time", "description": "Time until which a custom HTTP response code should be applied. Indicated in 24-hour format."}, "time_zone": {"type": "string", "format": "timezone", "default": "UTC", "example": "Europe/Luxembourg", "description": "Time zone used to calculate time."}}}}, "required": ["enabled", "code", "body"]}
    shielded: {"type": "boolean", "readOnly": true, "description": "Defines whether origin shielding feature is enabled for the resource.\n\nPossible values:\n- **true** - Origin shielding is enabled.\n- **false** - Origin shielding is disabled.", "example": false}
    gzipOn: {"type": "object", "nullable": true, "description": "Compresses content with gzip on the CDN end. CDN servers will request only uncompressed content from the origin.\n\nNotes:\n\n1. Compression with gzip is not supported with `fetch_compressed` or `slice` options enabled.\n2. `fetch_compressed` option in CDN resource settings overrides `gzipON` in rules. If you enable `fetch_compressed` in CDN resource and want to enable `gzipON` in rules, you need to specify `\"`fetch_compressed`\":false` for rules.", "properties": {"enabled": {"$ref": "#/components/schemas/parameters-enabled"}, "value": {"type": "boolean", "description": "Possible values:\n- **true** - Option is enabled.\n- **false** - Option is disabled."}}, "required": ["enabled", "value"], "example": {"enabled": true, "value": true}}
    HTTPConfig: {"title": "HTTP Config", "type": "object", "properties": {"upload": {"type": "object", "$ref": "#/components/schemas/HTTPAction"}, "append": {"allOf": [{"type": "object", "nullable": true}, "$ref": "#/components/schemas/HTTPAction"]}, "retry": {"allOf": [{"type": "object", "nullable": true}, "$ref": "#/components/schemas/HTTPAction"]}, "auth": {"allOf": [{"type": "object", "nullable": true}, "$ref": "#/components/schemas/HTTPAuth"]}, "content_type": {"type": "string", "enum": ["json", "text"], "default": "text"}}, "required": ["upload"]}
    redirect_http_to_https: {"type": "object", "nullable": true, "description": "Enables redirect from HTTP to HTTPS.\n\n`redirect_http_to_https` and `redirect_https_to_http` options cannot be enabled simultaneously.", "properties": {"enabled": {"$ref": "#/components/schemas/parameters-enabled"}, "value": {"type": "boolean", "description": "Possible values:\n- **true** - Option is enabled.\n- **false** - Option is disabled."}}, "required": ["enabled", "value"], "example": {"enabled": true, "value": true}}
    proxy_cache_key: {"type": "object", "nullable": true, "description": "Allows you to modify your cache key. If omitted, the default value is `$request_uri`.\n\nCombine the specified variables to create a key for caching.\n- **$`request_uri`**\n- **$scheme**\n- **$uri** \n\n**Warning**: Enabling and changing this option can invalidate your current cache and affect the cache hit ratio. Furthermore, the \"Purge by pattern\" option will not work.", "properties": {"enabled": {"$ref": "#/components/schemas/parameters-enabled"}, "value": {"type": "string", "maxLength": 255, "description": "Key for caching."}}, "required": ["enabled", "value"], "example": {"enabled": true, "value": "$scheme$uri"}}
    deleted: {"type": "boolean", "readOnly": true, "description": "Defines whether CDN resource has been deleted.\n\nPossible values:\n- **true** - CDN resource is deleted.\n- **false** - CDN resource is not deleted.", "example": false}
    backup: {"type": "boolean", "description": "Defines whether the origin is a backup, meaning that it will not be used until one of active origins become unavailable.\n\nPossible values:\n- **true** - Origin is a backup.\n- **false** - Origin is not a backup.", "example": false}
    stale: {"type": "object", "nullable": true, "description": "Serves stale cached content in case of origin unavailability.", "properties": {"enabled": {"$ref": "#/components/schemas/parameters-enabled"}, "value": {"type": "array", "uniqueItems": true, "items": {"type": "string", "enum": ["error", "http_403", "http_404", "http_429", "http_500", "http_502", "http_503", "http_504", "invalid_header", "timeout", "updating"]}, "description": "Defines list of errors for which \"Always online\" option is applied."}}, "required": ["enabled", "value"], "example": {"enabled": true, "value": ["http_404", "http_500"]}}
    HTTPAuth: {"allOf": ["$ref": "#/components/schemas/BaseHTTPAuth", {"type": "object", "properties": {"config": {"$ref": "#/components/schemas/HTTPAuthTokenConfig"}}, "required": ["type", "config"]}]}
    disable_cache: {"type": "object", "nullable": true, "deprecated": true, "description": "**Legacy option**. Use the `edge_cache_settings` option instead.\n\nAllows the complete disabling of content caching.", "properties": {"enabled": {"$ref": "#/components/schemas/parameters-enabled"}, "value": {"type": "boolean", "description": "Possible values:\n- **true** - content caching is disabled.\n- **false** - content caching is enabled."}}, "required": ["enabled", "value"], "example": {"enabled": true, "value": false}}
    response_headers_hiding_policy: {"type": "object", "nullable": true, "description": "Hides HTTP headers from an origin server in the CDN response.", "properties": {"enabled": {"$ref": "#/components/schemas/parameters-enabled"}, "mode": {"type": "string", "enum": ["hide", "show"], "description": "How HTTP headers are hidden from the response.\n\nPossible values:\n- **show** - Hide only HTTP headers listed in the `excepted` field.\n- **hide** - Hide all HTTP headers except headers listed in the \"excepted\" field."}, "excepted": {"type": "array", "uniqueItems": true, "maxItems": 256, "items": {"type": "string", "maxLength": 128, "format": "http_header"}, "description": "List of HTTP headers.\n\nParameter meaning depends on the value of the `mode` field:\n- **show** - List of HTTP headers to hide from response.\n- **hide** - List of HTTP headers to include in response. Other HTTP headers will be hidden.\n\nThe following headers are required and cannot be hidden from response:\n- `Connection`\n- `Content-Length`\n- `Content-Type`\n- `Date`\n- `Server`"}}, "required": ["enabled", "mode", "excepted"], "example": {"enabled": true, "mode": "hide", "excepted": ["my-header"]}}
    static_response_headers: {"type": "object", "nullable": true, "description": "Custom HTTP Headers that a CDN server adds to a response.", "properties": {"enabled": {"$ref": "#/components/schemas/parameters-enabled"}, "value": {"type": "array", "maxItems": 50, "items": {"type": "object", "properties": {"name": {"type": "string", "maxLength": 128, "pattern": "^[A-Za-z0-9]+([_\\-]*[A-Za-z0-9]+)*$", "description": "HTTP Header name.\n\nRestrictions:\n- Maximum 128 symbols.\n- Latin letters (A-Z, a-z,) numbers (0-9,) dashes, and underscores only."}, "value": {"type": "array", "uniqueItems": true, "maxLength": 512, "items": {"type": "string"}, "description": "Header value.\n\nRestrictions:\n- Maximum 512 symbols.\n- Letters (a-z), numbers (0-9), spaces, and symbols (`~!@#%%^&\\*()-_=+ /|\\\";:?.,><{}[]).\n- Must start with a letter, number, asterisk or {.\n- Multiple values can be added."}, "always": {"type": "boolean", "default": false, "description": "Defines whether the header will be added to a response from CDN regardless of response code.\n\nPossible values:\n- **true** - Header will be added to a response from CDN regardless of response code.\n- **false** - Header will be added only to the following response codes: 200, 201, 204, 206, 301, 302, 303, 304, 307, 308."}}, "required": ["name", "value"]}}}, "required": ["enabled", "value"], "example": {"enabled": true, "value": [{"name": "X-Example", "value": ["Value_1"], "always": true}, {"name": "X-Example-Multiple", "value": ["Value_1", "Value_2", "Value_3"], "always": false}]}}
    proxy_connect_timeout: {"type": "object", "nullable": true, "description": "The time limit for establishing a connection with the origin.", "properties": {"enabled": {"$ref": "#/components/schemas/parameters-enabled"}, "value": {"type": "string", "description": "Timeout value in seconds."}}, "required": ["enabled", "value"], "example": {"enabled": true, "value": "4s"}}
    secure_key: {"type": "object", "nullable": true, "description": "Configures access with tokenized URLs. This makes impossible to access content without a valid (unexpired) token.", "properties": {"enabled": {"$ref": "#/components/schemas/parameters-enabled"}, "key": {"type": "string", "nullable": true, "maxLength": 255, "description": "Key generated on your side that will be used for URL signing."}, "type": {"type": "integer", "enum": [0, 2], "default": 0, "description": "Type of URL signing. \n\nPossible types:\n- **Type 0** - Includes end user IP to secure token generation.\n- **Type 2** - Excludes end user IP from secure token generation."}}, "required": ["enabled", "key"], "example": {"enabled": true, "key": "secretkey", "type": 2}}
    AdvancedMetricsResponse: {"properties": {"data": {"description": "If no grouping was requested then \"data\" holds an array of metric values.\nIf at least one field is specified in \"`group_by`\" then \"data\" is an object whose properties are groups, which may include other groups;\nthe last group will hold array of metrics values.", "anyOf": ["$ref": "#/components/schemas/AdvancedMetricsResponseValues", "$ref": "#/components/schemas/AdvancedMetricsResponseGroups"]}}, "example": {"data": [{"edge_status_2xx": 21095299, "timestamp": 1623159320}, {"edge_download_speed": {"0_250k": "0", "250k_500k": "0", "500k_750k": "0", "750k_1M": "0", "1M_2M": "0.09091", "2M_3M": "0.1818", "3M_4M": "0.1818", "4M+": "0.5455"}, "timestamp": 1623159380}]}}
    NotActiveLECertificateIssueRequestForceRetryError: {"title": "Let's Encrypt certificate issuance is completed", "type": "object", "properties": {"errors": {"type": "object", "properties": {"certificate": {"type": "array", "items": {"type": "string"}, "description": "The certificate issuance process has already been completed.", "example": ["The certificate issuance process has already been completed."]}}}}}
    CreateRuleTemplate: {"type": "object", "properties": {"name": {"$ref": "#/components/schemas/schemas_components-schemas-name"}, "rule": {"$ref": "#/components/schemas/rule"}, "ruleType": {"$ref": "#/components/schemas/ruleType"}, "weight": {"$ref": "#/components/schemas/weight"}, "overrideOriginProtocol": {"$ref": "#/components/schemas/overrideOriginProtocol"}, "options": {"type": "object", "$ref": "#/components/schemas/rule_options"}}, "required": ["rule", "ruleType"]}
    NoPermissionsWithExample: {"title": "No permissions", "type": "object", "properties": {"message": {"type": "string", "description": "You do not have permission to perform this action."}}}
    source: {"type": "string", "description": "IP address or domain name of the origin and the port, if custom port is used.", "example": "yourwebsite.com"}
    AuthS3AccessKeyIdIsInvalidError: {"title": "Auth must have a s3 access key id with 20-25 alpha-numeric characters", "type": "object", "properties": {"errors": {"type": "object", "properties": {"auth": {"type": "object", "properties": {"s3_access_key_id": {"type": "array", "items": {"type": "string"}, "description": "The specified s3 access key id is less than 20 characters. Please lengthen the name and try again.", "example": ["Only 20-25 alpha-numeric characters are allowed."]}}}}}}}
    primary_resource: {"type": "integer", "nullable": true, "description": "ID of the main CDN resource which has a shared caching zone with a reserve CDN resource.\n\nIf the parameter is not empty, then the current CDN resource is the reserve.\nYou cannot change some options, create rules, set up origin shielding, or use the reserve CDN resource for Streaming.", "example": null}
    Host: {"type": "string", "description": "Host from which the request was made."}
    ssl_ca_response: {"type": "object", "properties": {"id": {"type": "integer", "description": "CA certificate ID.", "example": 1}, "name": {"type": "string", "description": "CA certificate name.", "example": "Example CA certificate"}, "deleted": {"type": "boolean", "description": "Defines whether the certificate has been deleted. Parameter is **deprecated**.\n\nPossible values:\n- **true** - Certificate has been deleted.\n- **false** - Certificate has not been deleted.", "example": true}, "cert_issuer": {"type": "string", "description": "Name of the certification center that issued the CA certificate.", "example": "example.com"}, "cert_subject_cn": {"type": "string", "description": "Domain name that the CA certificate secures.", "example": "example.com"}, "cert_subject_alt": {"type": "string", "description": "Alternative domain names that the CA certificate secures.", "example": "DNS:example.com"}, "validity_not_before": {"type": "string", "description": "Date when the CA certificate become valid (ISO 8601/RFC 3339 format, UTC.)", "example": "2020-06-26T12:03:53Z"}, "validity_not_after": {"type": "string", "description": "Date when the CA certificate become untrusted (ISO 8601/RFC 3339 format, UTC.)", "example": "2021-06-26T12:03:53Z"}, "sslCertificateChain": {"type": "string", "description": "Parameter is **deprecated**.", "example": ""}, "hasRelatedResources": {"type": "boolean", "description": "Defines whether the CA certificate is used by a CDN resource.\n\nPossible values:\n- **true** - Certificate is used by a CDN resource.\n- **false** - Certificate is not used by a CDN resource.", "example": false}}}
    proxy_read_timeout: {"type": "object", "nullable": true, "description": "The time limit for receiving a partial response from the origin.\nIf no response is received within this time, the connection will be closed.\n\n**Note:**\nWhen used with a WebSocket connection, this option supports values only in the range 1–20 seconds (instead of the usual 1–30 seconds).", "properties": {"enabled": {"$ref": "#/components/schemas/parameters-enabled"}, "value": {"type": "string", "description": "Timeout value in seconds."}}, "required": ["enabled", "value"], "example": {"enabled": true, "value": "10s"}}
    ignoreQueryString: {"type": "object", "nullable": true, "description": "How a file with different query strings is cached: either as one object (option is enabled) or as different objects (option is disabled.)\n\n`ignoreQueryString`, `query_params_whitelist` and `query_params_blacklist` options cannot be enabled simultaneously.", "properties": {"enabled": {"$ref": "#/components/schemas/parameters-enabled"}, "value": {"type": "boolean", "description": "Possible values:\n- **true** - Option is enabled.\n- **false** - Option is disabled."}}, "required": ["enabled", "value"], "example": {"enabled": true, "value": false}}
    GetPaidFeaturesSeriesStat: {"type": "array", "items": {"type": "object", "properties": {"active_from": {"type": "string", "description": "Date and time when paid feature was enabled (ISO 8601/RFC 3339 format, UTC.)"}, "active_to": {"type": "string", "nullable": true, "description": "Date and time when paid feature was disabled (ISO 8601/RFC 3339 format, UTC.)\n\nIt returns **null** if the paid feature is enabled."}, "client_id": {"type": "integer", "description": "Client ID."}, "resource_id": {"type": "integer", "description": "CDN resource ID."}, "cname": {"type": "string", "description": "CDN resource CNAME."}}}, "example": [{"id": 1, "active_from": "2020-01-21T04:36:35.473Z", "active_to": null, "client_id": 1, "resource_id": 1, "cname": "resource-1.com"}, {"id": 2, "active_from": "2020-03-21T04:36:30.269Z", "active_to": "2020-04-21T04:36:33.062Z", "client_id": 1, "cname": "resource-2.com"}]}
    AuthS3RegionIsRequiredError: {"title": "Auth must have a s3 region", "type": "object", "properties": {"errors": {"type": "object", "properties": {"auth": {"type": "object", "properties": {"s3_region": {"type": "array", "items": {"type": "string"}, "description": "S3 secret access key is a mandatory field. Please specify it.", "example": ["This field is required."]}}}}}}}
    origin: {"type": "string", "description": "IP address or domain name of the origin and the port, if custom port is used.\n\nYou can use either the `origin` or `originGroup` parameter in the request.", "example": "example.com"}
    RuleListResponse: {"type": "array", "items": {"$ref": "#/components/schemas/RuleResponse"}}
    purge_id: {"type": "integer", "description": "Purge ID.", "example": 1}
    LetsEncryptCertificateAlreadyAttached: {"title": "Let's Encrypt certificate is attached to another resource", "type": "object", "properties": {"errors": {"type": "object", "properties": {"sslData": {"type": "array", "items": {"type": "string"}, "description": "Let's Encrypt certificates can't be attached to multiple resources.\nThis error occurred because certificate is already attached to other resource.", "example": ["You cannot attach this Let's Encrypt SSL certificate because it is already attached to another resource."]}}}}}
    components-schemas-id: {"type": "integer", "readOnly": true, "description": "Rule ID.", "example": 5}
    shield_enabled: {"type": "boolean", "readOnly": true, "description": "Defines whether origin shield is active and working for the CDN resource.\n\nPossible values:\n- **true** - Origin shield is active.\n- **false** - Origin shield is not active.", "example": false}
    TokenID: {"type": "integer", "description": "Permanent API token ID with which the request was made."}
    CnameAlreadyExistsError: {"title": "CNAME already exists", "type": "object", "properties": {"errors": {"type": "object", "properties": {"cname": {"type": "array", "description": "The specified CNAME is already used by another resource in our system. Try another CNAME or contact support.", "items": {"type": "string"}, "example": ["CNAME cdn.example.com already exists. Try another CNAME or contact support."]}}}}}
    rule: {"type": "string", "maxLength": 300, "description": "Path to the file or folder for which the rule will be applied.\n\nThe rule is applied if the requested URI matches the rule path.\n\nWe add a leading forward slash to any rule path. Specify a path without a forward slash.", "example": "/folder/images/*.png"}
    payload: {"type": "object", "description": "Purge payload depends on purge type.\n\nPossible values:\n- **urls** - Purge by URL.\n- **paths** - Purge by Pattern and purge All."}
    SetupRawLogs: {"type": "object", "properties": {"enabled": {"$ref": "#/components/schemas/properties-enabled"}, "storage_type": {"type": "string", "description": "Storage type. \n\nPossible values:\n- **ftp**\n- **sftp**\n- **s3**"}, "ignore_empty_logs": {"type": "boolean", "description": "Enables or disables the forwarding of empty logs.\n\nPossible values:\n- **true** - Empty logs are not sent.\n- **false** - Empty logs are sent."}, "for_all_resources": {"type": "boolean", "description": "Defines whether logs of all CDN resources are delivered to one folder/bucket or to separate ones.\n\nPossible values:\n- **true** - Logs of all CDN resources are delivered to one folder/bucket.\n- **false** - Logs of different CDN resources are delivered to separate folders/buckets."}, "all_resources_bucket": {"type": "string", "description": "Name of the S3 bucket to which logs for all CDN resources are delivered."}, "all_resources_folder": {"type": "string", "description": "Parameter meaning depends on the value of the \"`storage_type`\" value:\n\n- If \"`storage_type`\": s3 - Name of the S3 bucket sub-folder to which logs for all CDN resources are delivered.\n- If \"`storage_type`\": ftp/sftp - Name of the folder (or path) to which logs for all CDN resources are delivered."}, "folders": {"type": "array", "items": {"$ref": "#/components/schemas/RawLogsFolder"}, "description": "List of folders/buckets for receiving CDN resources logs."}, "s3_type": {"type": "string", "description": "Storage type compatible with S3.\n\nPossible values:\n- **amazon** – AWS S3 storage.\n- **other** – Other (not AWS) S3 compatible storage."}, "s3_aws_region": {"type": "integer", "description": "Amazon AWS region."}, "s3_access_key_id": {"type": "string", "description": "Access key ID for the S3 account.\n\nAccess Key ID is 20 alpha-numeric characters like 022QF06E7MXBSH9DHM02"}, "s3_secret_key": {"type": "string", "description": "Secret access key for the S3 account.\n\nSecret Access Key is 20-50 alpha-numeric-slash-plus characters like kWcrlUX5JEDGM/LtmEENI/aVmYvHNif5zB+d9+ct"}, "s3_hostname": {"type": "string", "description": "S3 storage hostname.\n\nIt is required if \"`s3_type`\": other."}, "s3_host_bucket": {"type": "string", "description": "S3 bucket hostname.\n\nRestrictions:\n- Maximum of 255 symbols.\n- Latin letters (A-Z, a-z,) digits (0-9,) dots, colons, dashes, and underscores.\n- Required if \"`s3_type`\": other."}, "s3_bucket_location": {"type": "string", "description": "Location of S3 storage.\n\nRestrictions:\n- Maximum of 255 symbols.\n- Latin letters (A-Z, a-z), digits (0-9), dots, colons, dashes, and underscores (.:_-)."}, "ftp_hostname": {"type": "string", "description": "FTP storage hostname."}, "ftp_prepend_folder": {"type": "string", "description": "Name of the FTP prepend folder for log delivery.\n\n**Null** is allowed."}, "ftp_login": {"type": "string", "description": "FTP storage login."}, "ftp_password": {"type": "string", "description": "FTP storage password."}, "sftp_hostname": {"type": "string", "description": "SFTP storage hostname."}, "sftp_prepend_folder": {"type": "string", "description": "Name of the SFTP prepend folder for log delivery.\n\n**Null** is allowed."}, "sftp_login": {"type": "string", "description": "SFTP storage login."}, "sftp_password": {"type": "string", "description": "SFTP storage password.\n\nIt should be empty if \"`sftp_private_key`\" is set."}, "sftp_private_key": {"type": "string", "description": "Private key for SFTP authorization.\n\nPossible values:\n- **RSA**\n- **ED25519**\n\nIt should be empty if \"`sftp_password`\" is set."}, "sftp_key_passphrase": {"type": "string", "description": "Passphrase for SFTP private key. \n\nRestrictions:\n- Should be set if private key encoded with passphrase.\n- Should be empty if \"`sftp_password`\" is set."}, "archive_size_mb": {"type": "integer", "nullable": true, "minimum": 500, "maximum": 2000, "description": "The size of a single piece of the archive in MB.\nIn case of **null** value logs are delivered without slicing."}}, "required": ["storage_type", "for_all_resources",
        "all_resources_bucket", "all_resources_folder", "folders", "s3_type", "s3_access_key_id", "s3_secret_key", "s3_hostname", "ftp_hostname", "ftp_login", "ftp_password", "sftp_hostname", "sftp_login", "sftp_password"]}
    SFTPConfigResponse: {"title": "SFTP Config", "allOf": ["$ref": "#/components/schemas/SFTPConfig"]}
    BaseHTTPAuthTokenConfig: {"title": "HTTP Auth Token Config", "type": "object", "properties": {"header_name": {"type": "string"}, "token": {"type": "string"}}}
    ActiveInstanceDeletionProhibited: {"title": "Cannot delete an active instance.", "type": "object", "properties": {"errors": {"type": "array", "items": {"type": "string"}, "description": "Deletion of an active instance is prohibited. Please deactivate it before attempting deletion.", "example": ["Deletion of this instance is currently not possible as it is in an active state. Please deactivate it before attempting the deletion request again."]}}}
    full_custom_enabled: {"type": "boolean", "readOnly": true, "description": "Defines whether the CDN resource has a custom configuration.\n\nPossible values:\n- **true** - CDN resource has a custom configuration. You cannot change resource settings, except for the SSL certificate. To change other settings, contact technical support.\n- **false** - CDN resource has a regular configuration. You can change CDN resource settings.", "example": false}
    proxy_ssl_enabled: {"type": "boolean", "default": false, "description": "Enables or disables SSL certificate validation of the origin server before completing any connection.\n\nPossible values:\n- **true** - Origin SSL certificate validation is enabled.\n- **false** - Origin SSL certificate validation is disabled.", "example": false}
    GetAlibabaRegionsResponse: {"type": "object", "properties": {"id": {"type": "integer", "description": "Region ID."}, "code": {"type": "string", "description": "Region code."}, "name": {"type": "string", "description": "Region name."}}}
    AuthS3StorageHostnameIsRequiredError: {"title": "Auth must have a s3 storage hostname", "type": "object", "properties": {"errors": {"type": "object", "properties": {"auth": {"type": "object", "properties": {"s3_storage_hostname": {"type": "array", "items": {"type": "string"}, "description": "S3 storage hostname is a mandatory field. Please specify it.", "example": ["This field is required."]}}}}}}}
    suspended: {"type": "boolean", "readOnly": true, "description": "Defines whether the CDN resource has been automatically suspended because there was no traffic on it for 90 days.\n\nPossible values:\n- **true** - CDN resource is currently automatically suspended.\n- **false** - CDN resource is not automatically suspended.\n\nYou can enable CDN resource using the `active` field. If there is no traffic on the CDN resource within seven days following activation, it will be suspended again.\n\nTo avoid CDN resource suspension due to no traffic, contact technical support.", "example": false}
    UtilizationLevelCDNServiceError: {"type": "object", "properties": {"errors": {"type": "object", "properties": {"utilization_level": {"type": "array", "description": "The specified limit has an unacceptable value. The value must be greater than or equal to 0.", "items": {"type": "string"}, "example": ["Ensure this value is greater than or equal to 0."]}}}}}
    OriginGroupSourcesLimitCreateError: {"title": "Number of allowed sources has been exceeded", "type": "object", "properties": {"errors": {"type": "object", "properties": {"sources": {"type": "array", "items": {"type": "string"}, "description": "You have exceeded the number of allowed sources in the origin group. Please reduce the number of sources or contact support.", "example": ["Impossible to add origin group with more than {origins_limit} origins on your tariff plan."]}}}}}
    OriginGroupsListResponse: {"type": "array", "items": {"$ref": "#/components/schemas/OriginGroupsResponse"}}
    disable_proxy_force_ranges: {"type": "object", "nullable": true, "description": "Allows 206 responses regardless of the settings of an origin source.", "properties": {"enabled": {"$ref": "#/components/schemas/parameters-enabled"}, "value": {"type": "boolean", "description": "Possible values:\n- **true** - Option is enabled.\n- **false** - Option is disabled."}}, "required": ["enabled", "value"], "example": {"enabled": true, "value": true}}
    name: {"type": "string", "description": "Origin group name.", "example": "YourOriginGroup"}
    slice: {"type": "object", "nullable": true, "description": "Requests and caches files larger than 10 MB in parts (no larger than 10 MB per part.) This reduces time to first byte. \n\nThe option is based on the [Slice](https://nginx.org/en/docs/http/ngx_http_slice_module.html) module. \n\nNotes:\n\n1. Origin must support HTTP Range requests.\n2. Not supported with `gzipON`, `brotli_compression` or `fetch_compressed` options enabled.", "properties": {"enabled": {"$ref": "#/components/schemas/parameters-enabled"}, "value": {"type": "boolean", "description": "Possible values:\n- **true** - Option is enabled.\n- **false** - Option is disabled."}}, "required": ["enabled", "value"], "example": {"enabled": true, "value": true}}
    OriginLastSourceNotBackupError: {"title": "The single origin cannot be backup", "type": "object", "properties": {"errors": {"type": "object", "properties": {"sources": {"type": "object", "properties": {"yourwebsite.com": {"type": "object", "properties": {"backup": {"type": "array", "items": {"type": "string"}, "description": "This origin is the single in the specified origin group and cannot be used as a backup. Please add another origin before setting this one as a backup.", "example": ["You cannot specify all origin sources as reserve (backup). Add non-reserve origins."]}}}}}}}}}
    user_agent_acl: {"type": "object", "nullable": true, "description": "Controls access to the content for specified User-Agents.", "properties": {"enabled": {"$ref": "#/components/schemas/parameters-enabled"}, "policy_type": {"type": "string", "enum": ["allow", "deny"], "description": "User-Agents policy type.\n\nPossible values:\n- **allow** - Allow access for all User-Agents except specified in `excepted_values` field.\n- **deny** - Deny access for all User-Agents except specified in `excepted_values` field."}, "excepted_values": {"type": "array", "uniqueItems": true, "maxItems": 600, "items": {"type": "string", "maxLength": 255, "format": "user_agent"}, "description": "List of User-Agents that will be allowed/denied.\n\nThe meaning of the parameter depends on `policy_type`:\n- **allow** - List of User-Agents for which access is prohibited.\n- **deny** - List of User-Agents for which access is allowed.\n\nUse an empty string `\"\"` to allow/deny access when the User-Agent header is empty."}}, "required": ["enabled", "excepted_values", "policy_type"], "example": {"enabled": true, "policy_type": "allow", "excepted_values": ["UserAgent Value", ""]}}
    ShieldingPopNotExistsError: {"title": "Shielding pop does not exists", "type": "object", "properties": {"errors": {"type": "object", "properties": {"shielding_pop": {"type": "array", "description": "Probably you made a mistake in a origin shielding location ID.\nFind a request to get available origin shielding location IDs [here](/docs/api-reference/cdn/origin-shielding/get-origin-shielding-locations).", "items": {"type": "string"}, "example": ["Invalid pk \"{}\" - object does not exist."]}}}}}
    limit_bandwidth: {"type": "object", "nullable": true, "description": "Allows to control the download speed per connection.", "properties": {"enabled": {"$ref": "#/components/schemas/parameters-enabled"}, "limit_type": {"type": "string", "enum": ["static", "dynamic"], "description": "Method of controlling the download speed per connection.\n\nPossible values:\n- **static** - Use speed and buffer fields to set the download speed limit.\n- **dynamic** - Use query strings **speed** and **buffer** to set the download speed limit.\n\nFor example, when requesting content at the link\n```\nhttp://cdn.example.com/video.mp4?speed=50k&buffer=500k\n```\nthe download speed will be limited to 50kB/s after 500 kB."}, "speed": {"type": "integer", "minimum": 1, "maximum": 1000000000, "description": "Maximum download speed per connection."}, "buffer": {"type": "integer", "minimum": 0, "maximum": 1000000000, "description": "Amount of downloaded data after which the user will be rate limited."}}, "required": ["enabled", "limit_type"], "example": {"enabled": true, "limit_type": "static", "speed": 100, "buffer": 200}}
    OriginGroupNameMore255Error: {"title": "Origin group name is too long", "type": "object", "properties": {"errors": {"type": "object", "properties": {"name": {"type": "array", "items": {"type": "string"}, "description": "The specified origin group name is longer than 255 characters. Please shorten the name and try again.", "example": ["Ensure this field has no more than 255 characters."]}}}}}
    S3AmazonConfig: {"title": "S3 Amazon Config", "allOf": ["$ref": "#/components/schemas/BaseS3Config", {"type": "object", "required": ["access_key_id", "secret_access_key", "bucket_name", "region"]}]}
    auth_type_none: {"type": "string", "description": "Origin authentication type.\n\nPossible values:\n- **none** - Used for public origins.\n- **awsSignatureV4** - Used for S3 storage.", "example": "none"}
    OriginSourceWithoutSchemaError: {"title": "Origin source contains schema", "type": "object", "properties": {"errors": {"type": "object", "properties": {"sources": {"type": "object", "properties": {"https://yourwebsite.com": {"type": "object", "properties": {"source": {"type": "array", "items": {"type": "string"}, "description": "The specified origin source contains a schema (https:// or http://). Specify the source without schema and try again.", "example": ["Source should be specified without schema"]}}}}}}}}}
    UserID: {"type": "integer", "description": "ID of the user who made the request."}
    ClientsMeFeaturesResponse: {"type": "object", "properties": {"id": {"type": "integer", "description": "Account ID.", "example": 100}, "paid_features": {"type": "array", "description": "Paid features available for your account.", "items": {"$ref": "#/components/schemas/paid_feature_item"}}, "free_features": {"type": "array", "description": "Free features available for your account.", "items": {"$ref": "#/components/schemas/free_feature_item"}}}}
    OriginGroupsResponse: {"anyOf": [{"type": "object", "title": "None Auth", "properties": {"id": {"$ref": "#/components/schemas/id"}, "name": {"$ref": "#/components/schemas/name"}, "use_next": {"$ref": "#/components/schemas/use_next"}, "proxy_next_upstream": {"$ref": "#/components/schemas/proxy_next_upstream"}, "auth_type": {"$ref": "#/components/schemas/auth_type_none"}, "sources": {"$ref": "#/components/schemas/sources"}, "path": {"$ref": "#/components/schemas/path"}, "has_related_resources": {"$ref": "#/components/schemas/has_related_resources"}}}, {"type": "object", "title": "AWS Signature V4", "properties": {"id": {"$ref": "#/components/schemas/id"}, "name": {"$ref": "#/components/schemas/name"}, "use_next": {"$ref": "#/components/schemas/use_next"}, "proxy_next_upstream": {"$ref": "#/components/schemas/proxy_next_upstream"}, "auth_type": {"$ref": "#/components/schemas/auth_type_aws"}, "auth": {"$ref": "#/components/schemas/auth"}, "path": {"$ref": "#/components/schemas/path"}, "has_related_resources": {"$ref": "#/components/schemas/has_related_resources"}}}]}
    LECertificateIssuingNotStartedYetError: {"title": "Let's Encrypt certificate issuing is not started yet", "type": "object", "properties": {"errors": {"type": "object", "properties": {"certificate": {"type": "array", "items": {"type": "string"}, "description": "Let's Encrypt certificate issuing is not started yet.", "example": ["Let's Encrypt certificate issuing is not started yet."]}}}}}
    proxy_next_upstream: {"description": "Defines cases when the request should be passed on to the next origin.\n\nPossible values:\n- **error** - an error occurred while establishing a connection with the origin, passing a request to it, or reading the response header\n- **timeout** - a timeout has occurred while establishing a connection with the origin, passing a request to it, or reading the response header\n- **`invalid_header`** - a origin returned an empty or invalid response\n- **`http_403`** - a origin returned a response with the code 403\n- **`http_404`** - a origin returned a response with the code 404\n- **`http_429`** - a origin returned a response with the code 429\n- **`http_500`** - a origin returned a response with the code 500\n- **`http_502`** - a origin returned a response with the code 502\n- **`http_503`** - a origin returned a response with the code 503\n- **`http_504`** - a origin returned a response with the code 504", "type": "array", "default": ["error", "timeout"], "items": {"type": "string"}, "example": ["error", "timeout", "invalid_header", "http_500", "http_502", "http_503", "http_504"]}
    rule_options: {"type": "object", "description": "List of options that can be configured for the rule.\n\nIn case of `null` value the option is not added to the rule.\nOption inherits its value from the CDN resource settings.", "properties": {"allowedHttpMethods": {"$ref": "#/components/schemas/allowedHttpMethods"}, "bot_protection": {"$ref": "#/components/schemas/bot_protection"}, "brotli_compression": {"$ref": "#/components/schemas/brotli_compression"}, "browser_cache_settings": {"$ref": "#/components/schemas/browser_cache_settings"}, "cache_http_headers": {"$ref": "#/components/schemas/cache_http_headers"}, "cors": {"$ref": "#/components/schemas/cors"}, "country_acl": {"$ref": "#/components/schemas/country_acl"}, "disable_cache": {"$ref": "#/components/schemas/disable_cache"}, "disable_proxy_force_ranges": {"$ref": "#/components/schemas/disable_proxy_force_ranges"}, "edge_cache_settings": {"$ref": "#/components/schemas/edge_cache_settings"}, "fastedge": {"$ref": "#/components/schemas/fastedge"}, "fetch_compressed": {"$ref": "#/components/schemas/fetch_compressed"}, "follow_origin_redirect": {"$ref": "#/components/schemas/follow_origin_redirect"}, "force_return": {"$ref": "#/components/schemas/force_return"}, "forward_host_header": {"$ref": "#/components/schemas/forward_host_header"}, "gzipOn": {"$ref": "#/components/schemas/gzipOn"}, "hostHeader": {"$ref": "#/components/schemas/hostHeader"}, "ignore_cookie": {"$ref": "#/components/schemas/ignore_cookie"}, "ignoreQueryString": {"$ref": "#/components/schemas/ignoreQueryString"}, "image_stack": {"$ref": "#/components/schemas/image_stack"}, "ip_address_acl": {"$ref": "#/components/schemas/ip_address_acl"}, "limit_bandwidth": {"$ref": "#/components/schemas/limit_bandwidth"}, "proxy_cache_key": {"$ref": "#/components/schemas/proxy_cache_key"}, "proxy_cache_methods_set": {"$ref": "#/components/schemas/proxy_cache_methods_set"}, "proxy_connect_timeout": {"$ref": "#/components/schemas/proxy_connect_timeout"}, "proxy_read_timeout": {"$ref": "#/components/schemas/proxy_read_timeout"}, "query_params_blacklist": {"$ref": "#/components/schemas/query_params_blacklist"}, "query_params_whitelist": {"$ref": "#/components/schemas/query_params_whitelist"}, "query_string_forwarding": {"$ref": "#/components/schemas/query_string_forwarding"}, "redirect_http_to_https": {"$ref": "#/components/schemas/redirect_http_to_https"}, "redirect_https_to_http": {"$ref": "#/components/schemas/redirect_https_to_http"}, "referrer_acl": {"$ref": "#/components/schemas/referrer_acl"}, "request_limiter": {"$ref": "#/components/schemas/request_limiter"}, "response_headers_hiding_policy": {"$ref": "#/components/schemas/response_headers_hiding_policy"}, "rewrite": {"$ref": "#/components/schemas/rewrite"}, "secure_key": {"$ref": "#/components/schemas/secure_key"}, "slice": {"$ref": "#/components/schemas/slice"}, "sni": {"$ref": "#/components/schemas/sni"}, "stale": {"$ref": "#/components/schemas/stale"}, "static_response_headers": {"$ref": "#/components/schemas/static_response_headers"}, "staticHeaders": {"$ref": "#/components/schemas/staticHeaders"}, "staticRequestHeaders": {"$ref": "#/components/schemas/staticRequestHeaders"}, "user_agent_acl": {"$ref": "#/components/schemas/user_agent_acl"}, "waap": {"$ref": "#/components/schemas/waap"}, "websockets": {"$ref": "#/components/schemas/websockets"}}}
    OriginSourceShouldNotHavePortError: {"title": "Origin source cannot have port", "type": "object", "properties": {"errors": {"type": "object", "properties": {"sources": {"type": "object", "properties": {"yourwebsite.com:8000": {"type": "object", "properties": {"source": {"type": "array", "items": {"type": "string"}, "description": "Resource linked to the origin group uses 'MATCH' as the originProtocol field value. So the origin source cannot have a port. Please specify the origin source without the port.", "example": ["Origin source shouldn`t have specified port, some resources that linked to origin group {resource_id} have an origin protocol = 'MATCH'."]}}}}}}}}}
    Method: {"type": "string", "description": "Request HTTP method."}
    overrideOriginProtocol: {"type": "string", "nullable": true, "enum": ["HTTPS", "HTTP", "MATCH"], "description": "Sets a protocol other than the one specified in the CDN resource settings to connect to the origin.\n\nPossible values:\n- **HTTPS** - CDN servers connect to origin via HTTPS protocol.\n- **HTTP** - CDN servers connect to origin via HTTP protocol.\n- **MATCH** - Connection protocol is chosen automatically; in this case, content on origin source should be available for the CDN both through HTTP and HTTPS protocols.\n- **null** - `originProtocol` setting is inherited from the CDN resource settings."}
    staticHeaders: {"type": "object", "nullable": true, "deprecated": true, "description": "**Legacy option**. Use the `static_response_headers` option instead.\n\nCustom HTTP Headers that a CDN server adds to response. Up to fifty custom HTTP Headers can be specified. May contain a header with multiple values.", "properties": {"enabled": {"$ref": "#/components/schemas/parameters-enabled"}, "value": {"type": "object", "description": "A MAP for static headers in a format of `header_name: header_value`.\n\nRestrictions:\n- **Header name** - Maximum 128 symbols, may contain Latin letters (A-Z, a-z), numbers (0-9), dashes, and underscores.\n- **Header value** - Maximum 512 symbols, may contain letters (a-z), numbers (0-9), spaces, and symbols (`~!@#%%^&\\*()-_=+ /|\\\";:?.,><{}[]). Must start with a letter, number, asterisk or {.", "additionalProperties": {"type": "string"}}}, "required": ["enabled", "value"]}
    FTPConfig: {"title": "FTP Config", "allOf": ["$ref": "#/components/schemas/BaseFTPConfig", {"type": "object", "properties": {"password": {"type": "string"}}, "required": ["user", "password", "hostname"]}]}
    schemas-originProtocol: {"type": "string", "readOnly": true, "enum": ["HTTPS", "HTTP", "MATCH"], "description": "Protocol used by CDN servers to request content from an origin source.\n\nPossible values:\n- **HTTPS** - CDN servers connect to origin via HTTPS protocol.\n- **HTTP** - CDN servers connect to origin via HTTP protocol.\n- **MATCH** - Connection protocol is chosen automatically; in this case, content on origin source should be available for the CDN both through HTTP and HTTPS protocols.", "example": "HTTPS"}
    BaseS3Config: {"type": "object", "properties": {"access_key_id": {"type": "string"}, "secret_access_key": {"type": "string"}, "region": {"type": "string"}, "bucket_name": {"type": "string"}, "directory": {"type": "string", "nullable": true}}}
    parameters-enabled: {"type": "boolean", "description": "Controls the option state.\n\nPossible values:\n- **true** - Option is enabled.\n- **false** - Option is disabled."}
    created: {"type": "string", "readOnly": true, "description": "Date of CDN resource creation.", "example": "2017-06-10T10:30:04.954354Z"}
    browser_cache_settings: {"type": "object", "nullable": true, "description": "Cache expiration time for users browsers in seconds.\n\nCache expiration time is applied to the following response codes: 200, 201, 204, 206, 301, 302, 303, 304, 307, 308.\n\nResponses with other codes will not be cached.", "properties": {"enabled": {"$ref": "#/components/schemas/parameters-enabled"}, "value": {"type": "string", "description": "Set the cache expiration time to '0s' to disable caching.\n\nThe maximum duration is any equivalent to `1y`.", "format": "nginx time", "pattern": "^\\d+(ms|s|m|h|d|w|M|y)?$"}}, "required": ["enabled", "value"], "example": {"enabled": true, "value": "3600s"}}
    resource: {"type": "object", "properties": {"id": {"type": "integer", "description": "Resource ID.", "example": 1}, "cname": {"type": "string", "description": "CNAME of the resource.", "example": "cdn.site.com"}}}
    Actions: {"type": "array", "description": "State of a requested object before and after the request.", "items": {"type": "object", "properties": {"action_type": {"$ref": "#/components/schemas/cdn_ActionType"}, "state_before_request": {"$ref": "#/components/schemas/StateBeforeRequest"}, "state_after_request": {"$ref": "#/components/schemas/StateAfterRequest"}}}}
    edge_cache_settings: {"type": "object", "nullable": true, "description": "Cache expiration time for CDN servers. \n\n`value` and `default` fields cannot be used simultaneously.", "properties": {"enabled": {"$ref": "#/components/schemas/parameters-enabled"}, "value": {"type": "string", "description": "Caching time.\n\nThe value is applied to the following response codes: 200, 206, 301, 302.\nResponses with codes 4xx, 5xx will not be cached. \n\nUse `0s` to disable caching.\n\nThe maximum duration is any equivalent to `1y`.", "format": "nginx time", "pattern": "^\\d+(ms|s|m|h|d|w|M|y)?$"}, "custom_values": {"type": "object", "additionalProperties": {"type": "string", "format": "nginx time", "pattern": "^\\d+(ms|s|m|h|d|w|M|y)?$"}, "description": "A MAP object representing the caching time in seconds for a response with a specific response code. \n\nThese settings have a higher priority than the `value` field.\n\n- Use `any` key to specify caching time for all response codes.\n- Use `0s` value to disable caching for a specific response code.", "format": "{status_code or any}: {nginx time}"}, "default": {"type": "string", "description": "Enables content caching according to the origin cache settings.\n\nThe value is applied to the following response codes 200, 201, 204, 206, 301, 302, 303, 304, 307, 308, if an origin server does not have caching HTTP headers.\n\nResponses with other codes will not be cached.\n\nThe maximum duration is any equivalent to `1y`.", "format": "nginx time", "pattern": "^\\d+(ms|s|m|h|d|w|M|y)?$"}}, "required": ["enabled"], "example": {"enabled": true, "value": "43200s", "custom_values": {"100": "43200s"}}}
    query_string_forwarding: {"type": "object", "nullable": true, "description": "The Query String Forwarding feature allows for the seamless transfer of parameters embedded in playlist files to the corresponding media chunk files.\nThis functionality ensures that specific attributes, such as authentication tokens or tracking information, are consistently passed along from the playlist manifest to the individual media segments.\nThis is particularly useful for maintaining continuity in security, analytics, and any other parameter-based operations across the entire media delivery workflow.", "properties": {"enabled": {"$ref": "#/components/schemas/parameters-enabled"}, "forward_from_file_types": {"type": "array", "items": {"type": "string"}, "description": "The `forward_from_files_types` field specifies the types of playlist files from which parameters will be extracted and forwarded.\nThis typically includes formats that list multiple media chunk references, such as HLS and DASH playlists.\nParameters associated with these playlist files (like query strings or headers) will be propagated to the chunks they reference."}, "forward_to_file_types": {"type": "array", "items": {"type": "string"}, "description": "The field specifies the types of media chunk files to which parameters, extracted from playlist files, will be forwarded.\nThese refer to the actual segments of media content that are delivered to viewers.\nEnsuring the correct parameters are forwarded to these files is crucial for maintaining the integrity of the streaming session."}, "forward_only_keys": {"type": "array", "items": {"type": "string"}, "description": "The `forward_only_keys` field allows for granular control over which specific parameters are forwarded from playlist files to media chunk files.\nBy specifying certain keys, only those parameters will be propagated, ensuring that only relevant information is passed along.\nThis is particularly useful for security and performance optimization, as it prevents unnecessary or sensitive data from being included in requests for media chunks."}, "forward_except_keys": {"type": "array", "items": {"type": "string"}, "description": "The `forward_except_keys` field provides a mechanism to exclude specific parameters from being forwarded from playlist files to media chunk files.\nBy listing certain keys in this field, you can ensure that these parameters are omitted during the forwarding process.\nThis is particularly useful for preventing sensitive or irrelevant information from being included in requests for media chunks, thereby enhancing security and optimizing performance."}}, "required": ["enabled", "forward_from_file_types", "forward_to_file_types"], "example": {"enabled": true, "forward_from_file_types": ["m3u8", "mpd"], "forward_to_file_types": ["ts", "mp4"], "forward_only_keys": ["auth_token", "session_id"], "forward_except_keys": ["debug_info"]}}
    can_purge_by_urls: {"type": "boolean", "readOnly": true, "description": "Defines whether the CDN resource can be used for purge by URLs feature.\n\nIt's available only in case the CDN resource has enabled `ignore_vary_header` option.", "example": false}
    QueryParams: {"type": "string", "description": "Request parameters."}
    S3GcoreConfigResponse: {"title": "S3 Gcore Config", "properties": {"access_key_id": {"type": "string"}, "region": {"type": "string"}, "bucket_name": {"type": "string"}, "directory": {"type": "string", "nullable": true}, "endpoint": {"type": "string"}, "use_path_style": {"type": "boolean"}}}
    sni: {"type": "object", "nullable": true, "description": "The hostname that is added to SNI requests from CDN servers to the origin server via HTTPS.\n\nSNI is generally only required if your origin uses shared hosting or does not have a dedicated IP address.\nIf the origin server presents multiple certificates, SNI allows the origin server to know which certificate to use for the connection.\n\nThe option works only if `originProtocol` parameter is `HTTPS` or `MATCH`.", "properties": {"enabled": {"$ref": "#/components/schemas/parameters-enabled"}, "sni_type": {"type": "string", "enum": ["dynamic", "custom"], "default": "dynamic", "description": "SNI (Server Name Indication) type.\n\nPossible values:\n- **dynamic** - SNI hostname depends on `hostHeader` and `forward_host_header` options.\nIt has several possible combinations:\n- If the `hostHeader` option is enabled and specified, SNI hostname matches the Host header.\n- If the `forward_host_header` option is enabled and has true value, SNI hostname matches the Host header used in the request made to a CDN.\n- If the `hostHeader` and `forward_host_header` options are disabled, SNI hostname matches the primary CNAME.\n- **custom** - custom SNI hostname is in use."}, "custom_hostname": {"type": "string", "maxLength": 255, "format": "domain", "description": "Custom SNI hostname.\n\nIt is required if `sni_type` is set to custom."}}, "required": ["custom_hostname", "enabled"], "example": {"enabled": true, "sni_type": "custom", "custom_hostname": "custom.example.com"}}
    suspend_date: {"type": "string", "readOnly": true, "nullable": true, "description": "Date when the CDN resource was suspended automatically if there is no traffic on it for 90 days. \n\nNot specified if the resource was not stopped due to lack of traffic.", "example": null}
    shield_dc: {"type": "string", "nullable": true, "readOnly": true, "description": "Name of the origin shielding location data center.\n\nParameter returns **null** if origin shielding is disabled.", "example": null}
    is_primary: {"type": "boolean", "readOnly": true, "nullable": true, "description": "Defines whether a CDN resource has a cache zone shared with other CDN resources.\n\nPossible values:\n- **true** - CDN resource is main and has a shared caching zone with other CDN resources, which are called reserve.\n- **false** - CDN resource is reserve and it has a shared caching zone with the main CDN resource. You cannot change some options, create rules, set up origin shielding and use the reserve resource for Streaming.\n- **null** - CDN resource does not have a shared cache zone.\n\nThe main CDN resource is specified in the `primary_resource` field. It cannot be suspended unless all related reserve CDN resources are suspended.", "example": null}
    S3OtherConfig: {"title": "S3 Other Config", "allOf": ["$ref": "#/components/schemas/S3GcoreConfig", {"type": "object", "properties": {"use_path_style": {"type": "boolean", "default": false}}}]}
    schemas-status: {"type": "string", "description": "Purge status.\n\nPossible values:\n- **In progress** - Purge is in progress.\n- **Successful** - Purge was successful.\n- **Failed** - Purge failed.", "enum": ["In progress", "Successful", "Failed"]}
    SFTPConfig: {"title": "SFTP Config", "allOf": ["$ref": "#/components/schemas/BaseFTPConfig", {"type": "object", "properties": {"password": {"type": "string", "nullable": true}, "private_key": {"type": "string", "nullable": true}, "key_passphrase": {"type": "string", "nullable": true}}, "required": ["user", "hostname"]}]}
    shield_routing_map: {"type": "integer", "readOnly": true, "nullable": true, "description": "Defines whether the origin shield with a dynamic location is enabled for the CDN resource.\n\nTo manage origin shielding, you must contact customer support.", "example": null}
    image_stack: {"type": "object", "nullable": true, "description": "Transforms JPG and PNG images (for example, resize or crop) and automatically converts them to WebP or AVIF format.", "properties": {"enabled": {"$ref": "#/components/schemas/parameters-enabled"}, "avif_enabled": {"type": "boolean", "default": false, "description": "Enables or disables automatic conversion of JPEG and PNG images to AVI format."}, "webp_enabled": {"type": "boolean", "default": false, "description": "Enables or disables automatic conversion of JPEG and PNG images to WebP format."}, "quality": {"type": "integer", "maximum": 100, "minimum": 1, "default": 95, "description": "Defines quality settings for JPG and PNG images. The higher the value, the better the image quality, and the larger the file size after conversion."}, "png_lossless": {"type": "boolean", "default": false, "description": "Enables or disables compression without quality loss for PNG format."}}, "required": ["enabled"], "example": {"enabled": true, "avif_enabled": true, "webp_enabled": false, "quality": 80, "png_lossless": true}}
    tls_versions: {"type": "object", "nullable": true, "description": "List of SSL/TLS protocol versions allowed for HTTPS connections from end users to the domain.\n\nWhen the option is disabled, all protocols versions are allowed.", "properties": {"enabled": {"$ref": "#/components/schemas/parameters-enabled"}, "value": {"type": "array", "uniqueItems": true, "items": {"type": "string", "enum": ["SSLv3", "TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]}, "description": "List of SSL/TLS protocol versions (case sensitive)."}}, "required": ["enabled", "value"], "example": {"enabled": true, "value": ["SSLv3", "TLSv1.3"]}}
    preset_applied: {"type": "boolean", "readOnly": true, "description": "Defines whether the CDN resource has a preset applied.\n\nPossible values:\n- **true** - CDN resource has a preset applied. CDN resource options included in the preset cannot be edited.\n- **false** - CDN resource does not have a preset applied.", "example": false}
    free_feature_item: {"title": "Free feature item", "type": "object", "properties": {"feature_id": {"type": "integer", "description": "Feature ID.", "example": 22}, "name": {"type": "string", "description": "Feature name.", "example": "Additional stats"}, "free_feature_id": {"type": "integer", "description": "Internal feature activation ID.", "example": 127}, "create_date": {"type": "string", "description": "Date and time when the feature was activated (ISO 8601/RFC 3339 format, UTC.)", "example": "2021-01-09T08:22:13.143273Z"}}}
    allowedHttpMethods: {"type": "object", "nullable": true, "description": "HTTP methods allowed for content requests from the CDN.", "properties": {"enabled": {"$ref": "#/components/schemas/parameters-enabled"}, "value": {"type": "array", "uniqueItems": true, "items": {"type": "string", "enum": ["GET", "HEAD", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"]}}}, "required": ["enabled", "value"], "example": {"enabled": true, "value": ["GET", "POST"]}}
    ActivityLogsPaginatedList: {"type": "object", "properties": {"count": {"$ref": "#/components/schemas/cdn_Count"}, "next": {"$ref": "#/components/schemas/Next"}, "previous": {"$ref": "#/components/schemas/Previous"}, "results": {"$ref": "#/components/schemas/Results"}}}
    country_acl: {"type": "object", "nullable": true, "description": "Enables control access to content for specified countries.", "properties": {"enabled": {"$ref": "#/components/schemas/parameters-enabled"}, "policy_type": {"type": "string", "enum": ["allow", "deny"], "description": "Defines the type of CDN resource access policy.\n\nPossible values:\n- **allow** - Access is allowed for all the countries except for those specified in `excepted_values` field.\n- **deny** - Access is denied for all the countries except for those specified in `excepted_values` field."}, "excepted_values": {"type": "array", "uniqueItems": true, "maxItems": 600, "items": {"type": "string", "maxLength": 255, "format": "country-code"}, "description": "List of countries according to ISO-3166-1.\n\nThe meaning of the parameter depends on `policy_type` value:\n- **allow** - List of countries for which access is prohibited.\n- **deny** - List of countries for which access is allowed."}}, "required": ["enabled", "policy_type", "excepted_values"], "example": {"enabled": true, "policy_type": "allow", "excepted_values": ["GB", "DE"]}}
    use_rsa_le_cert: {"type": "object", "nullable": true, "description": "RSA Let's Encrypt certificate type for the CDN resource.\n\nThe specified value will be used during the next Let's Encrypt certificate issue or renewal.", "properties": {"enabled": {"$ref": "#/components/schemas/parameters-enabled"}, "value": {"type": "boolean", "description": "Possible values:\n- **true** - RSA Let's Encrypt certificate.\n- **false** - ECDSA Let's Encrypt certificate."}}, "required": ["enabled", "value"], "example": {"enabled": true, "value": true}}
    query_params_whitelist: {"type": "object", "nullable": true, "description": "Files with the specified query parameters are cached as different objects, files with other parameters are cached as one object.\n\n`ignoreQueryString`, `query_params_whitelist` and `query_params_blacklist` options cannot be enabled simultaneously.", "properties": {"enabled": {"$ref": "#/components/schemas/parameters-enabled"}, "value": {"type": "array", "items": {"type": "string"}, "description": "List of query parameters."}}, "required": ["enabled", "value"], "example": {"enabled": true, "value": ["some", "whitelisted", "query"]}}
    use_default_le_chain: {"type": "object", "nullable": true, "description": "Let's Encrypt certificate chain.\n\nThe specified chain will be used during the next Let's Encrypt certificate issue or renewal.", "properties": {"enabled": {"$ref": "#/components/schemas/parameters-enabled"}, "value": {"type": "boolean", "description": "Possible values:\n- **true** - Default Let's Encrypt certificate chain. This is a deprecated version, use it only for compatibilities with Android devices 7.1.1 or lower.\n- **false** - Alternative Let's Encrypt certificate chain."}}, "required": ["enabled", "value"], "example": {"enabled": true, "value": true}}
    schemas_components-schemas-id: {"type": "integer", "readOnly": true, "description": "Rule template ID.", "example": 5}
    paid_feature_item: {"title": "Paid feature item", "type": "object", "properties": {"feature_id": {"type": "integer", "description": "Feature ID.", "example": 2}, "name": {"type": "string", "description": "Feature name.", "example": "Origin shield"}, "paid_feature_id": {"type": "integer", "description": "Internal feature activation ID.", "example": 100}, "create_date": {"type": "string", "description": "Date and time when the feature was activated (ISO 8601/RFC 3339 format, UTC.)", "example": "2021-01-29T15:21:05.165473Z"}}}
    status: {"type": "string", "enum": ["active", "suspended", "processed", "deleted"], "readOnly": true, "description": "CDN resource status.\n\nPossible values:\n- **active** - CDN resource is active. Content is available to users.\n- **suspended** - CDN resource is suspended. Content is not available to users.\n- **processed** - CDN resource has recently been created and is currently being processed. It will take about fifteen minutes to propagate it to all locations.\n- **deleted** - CDN resource is deleted.", "example": "active"}
    follow_origin_redirect: {"type": "object", "nullable": true, "description": "Enables redirection from origin.\nIf the origin server returns a redirect, the option allows the CDN to pull the requested content from the origin server that was returned in the redirect.", "properties": {"enabled": {"$ref": "#/components/schemas/parameters-enabled"}, "codes": {"type": "array", "uniqueItems": true, "minItems": 1, "items": {"type": "integer", "enum": [301, 302, 303, 307, 308]}, "description": "Redirect status code that the origin server returns.\n\nTo serve up to date content to end users, you will need to purge the cache after managing the option."}}, "required": ["enabled", "codes"], "example": {"enabled": true, "codes": [302, 308]}}
    schemas-created: {"type": "string", "description": "Date and time when the purge was created (ISO 8601/RFC 3339 format, UTC).", "example": "2021-10-29T13:21:01.550849Z"}
    redirect_https_to_http: {"type": "object", "nullable": true, "description": "Enables redirect from HTTPS to HTTP.\n\n`redirect_http_to_https` and `redirect_https_to_http` options cannot be enabled simultaneously.", "properties": {"enabled": {"$ref": "#/components/schemas/parameters-enabled"}, "value": {"type": "boolean", "description": "Possible values:\n- **true** - Option is enabled.\n- **false** - Option is disabled."}}, "required": ["enabled", "value"], "example": {"enabled": false, "value": true}}
    request_limiter: {"type": "object", "nullable": true, "description": "Option allows to limit the amount of HTTP requests.", "properties": {"enabled": {"$ref": "#/components/schemas/parameters-enabled"}, "rate": {"type": "integer", "minimum": 1, "description": "Maximum request rate."}, "rate_unit": {"type": "string", "enum": ["r/s", "r/m"], "default": "r/s", "description": "Units of measurement for the `rate` field.\n\nPossible values:\n- **r/s** - Requests per second.\n- **r/m** - Requests per minute.\n\nIf the rate is less than one request per second, it is specified in request per minute (r/m.)"}, "burst": {"type": "integer", "readOnly": true}, "delay": {"type": "integer", "readOnly": true}}, "required": ["enabled", "rate"], "example": {"enabled": true, "rate_unit": "r/s", "rate": 5, "burst": 5, "delay": 0}}
    HTTPAuthTokenConfig: {"allOf": ["$ref": "#/components/schemas/BaseHTTPAuthTokenConfig", {"type": "object", "required": ["header_name", "token"]}]}
    RequestedAt: {"type": "string", "description": "Date and time when the request was made."}
    updated: {"type": "string", "readOnly": true, "description": "Date of the last CDN resource update.", "example": "2017-06-14T05:05:42.065221Z"}
    cache_http_headers: {"type": "object", "nullable": true, "deprecated": true, "description": "**Legacy option**. Use the `response_headers_hiding_policy` option instead.\n\nHTTP Headers that must be included in the response.", "properties": {"enabled": {"$ref": "#/components/schemas/parameters-enabled"}, "value": {"type": "array", "uniqueItems": true, "items": {"type": "string", "maxLength": 1024}}}, "required": ["enabled", "value"], "example": {"enabled": false, "value": ["vary", "content-length", "last-modified", "connection", "accept-ranges", "content-type", "content-encoding", "etag", "cache-control", "expires", "keep-alive", "server"]}}
    FTPConfigResponse: {"title": "FTP Config", "allOf": ["$ref": "#/components/schemas/BaseFTPConfig"]}
    BaseHTTPAction: {"title": "HTTP Action", "type": "object", "properties": {"method": {"type": "string", "enum": ["POST", "PUT"], "default": "POST"}, "url": {"type": "string"}, "headers": {"type": "object", "additionalProperties": {"type": "string"}}, "timeout_seconds": {"type": "integer", "default": 30}, "use_compression": {"type": "boolean"}, "response_actions": {"type": "array", "items": {"type": "object", "properties": {"match_status_code": {"type": "integer"}, "match_payload": {"type": "string"}, "description": {"type": "string"}, "action": {"type": "string", "enum": ["drop", "retry", "append"]}}}}}}
    Path: {"type": "string", "description": "Request URL."}
    BaseFTPConfig: {"type": "object", "properties": {"user": {"type": "string"}, "hostname": {"type": "string"}, "timeout_seconds": {"type": "integer", "minimum": 0, "maximum": 300}, "directory": {"type": "string", "nullable": true}}}
    proxy_cache_methods_set: {"type": "object", "nullable": true, "description": "Caching for POST requests along with default GET and HEAD.", "properties": {"enabled": {"$ref": "#/components/schemas/parameters-enabled"}, "value": {"type": "boolean", "description": "Possible values:\n- **true** - Option is enabled.\n- **false** - Option is disabled."}}, "required": ["enabled", "value"], "example": {"enabled": true, "value": false}}
    http3_enabled: {"type": "object", "nullable": true, "description": "Enables HTTP/3 protocol for content delivery.\n\n`http3_enabled` option works only with `\"sslEnabled\": true`.", "properties": {"enabled": {"$ref": "#/components/schemas/parameters-enabled"}, "value": {"type": "boolean", "description": "Possible values:\n- **true** - Option is enabled.\n- **false** - Option is disabled."}}, "required": ["enabled", "value"], "example": {"enabled": true, "value": true}}
    rewrite: {"type": "object", "nullable": true, "description": "Changes and redirects requests from the CDN to the origin. It operates according to the [Nginx](https://nginx.org/en/docs/http/ngx_http_rewrite_module.html#rewrite) configuration.", "properties": {"enabled": {"$ref": "#/components/schemas/parameters-enabled"}, "flag": {"type": "string", "enum": ["break", "last", "redirect", "permanent"], "default": "break", "description": "Flag for the Rewrite option.\n\nPossible values:\n- **last** - Stop processing the current set of `ngx_http_rewrite_module` directives and start a search for a new location matching changed URI.\n- **break** - Stop processing the current set of the Rewrite option.\n- **redirect** - Return a temporary redirect with the 302 code; used when a replacement string does not start with `http://`, `https://`, or `$scheme`.\n- **permanent** - Return a permanent redirect with the 301 code."}, "body": {"type": "string", "maxLength": 255, "description": "Path for the Rewrite option. \n\nExample:\n- `/(.\\*) /media/$1`"}}, "required": ["enabled", "body"], "example": {"enabled": true, "body": "/(.*) /additional_path/$1", "flag": "break"}}
    brotli_compression: {"type": "object", "nullable": true, "description": "Compresses content with Brotli on the CDN side. CDN servers will request only uncompressed content from the origin. \n\nNotes: \n\n1. CDN only supports \"Brotli compression\" when the \"origin shielding\" feature is activated.\n2. If a precache server is not active for a CDN resource, no compression occurs, even if the option is enabled.\n3. `brotli_compression` is not supported with `fetch_compressed` or `slice` options enabled.\n4. `fetch_compressed` option in CDN resource settings overrides `brotli_compression` in rules. If you enabled `fetch_compressed` in CDN resource and want to enable `brotli_compression` in a rule, you must specify `fetch_compressed:false` in the rule.", "properties": {"enabled": {"$ref": "#/components/schemas/parameters-enabled"}, "value": {"type": "array", "description": "Allows to select the content types you want to compress.\n\n`text/html` is a mandatory content type.", "uniqueItems": true, "items": {"type": "string", "enum": ["application/javascript", "application/json", "application/vnd.ms-fontobject", "application/wasm", "application/x-font-ttf", "application/x-javascript", "application/xml", "application/xml+rss", "image/svg+xml", "image/x-icon", "text/css", "text/html", "text/javascript", "text/plain", "text/xml"]}}}, "required": ["enabled", "value"], "example": {"enabled": true, "value": ["text/html", "text/plain"]}}
    StateBeforeRequest: {"type": "object", "description": "JSON representation of object before the request."}
    purge_type: {"type": "string", "description": "Contains the name of the purge request type.\n\nPossible values:\n- **`purge_by_pattern`** - Purge by Pattern.\n- **`purge_by_url`** - Purge by URL.\n- **`purge_all`** - Purge All.", "example": "purge_by_url"}
    has_related_resources: {"type": "boolean", "description": "Defines whether the origin group has related CDN resources.\n\nPossible values:\n- **true** - Origin group has related CDN resources.\n- **false** - Origin group does not have related CDN resources.", "example": true}
    AdvancedMetricsResponseValues: {"type": "array", "description": "List of requested metrics sorted by timestamp in ascending order.", "items": {"minProperties": 2, "properties": {"timestamp": {"type": "integer", "format": "int64", "description": "Start timestamp of interval."}, "metric": {"type": "number", "description": "Metrics value."}}}, "example": [{"edge_status_2xx": 21095299, "timestamp": 1623159320}, {"edge_status_2xx": 62616980, "timestamp": 1623159380}]}
    FastEdgeTriggerSettings: {"type": "object", "properties": {"enabled": {"type": "boolean", "example": true, "default": true, "description": "Determines if the FastEdge application should be called whenever HTTP request headers are received."}, "app_id": {"type": "string", "example": "1001", "description": "The ID of the application in FastEdge."}, "interrupt_on_error": {"type": "boolean", "default": true, "example": true, "description": "Determines if the request execution should be interrupted when an error occurs."}, "execute_on_edge": {"type": "boolean", "default": true, "example": true, "description": "Determines if the request should be executed at the edge nodes."}, "execute_on_shield": {"type": "boolean", "default": false, "example": false, "description": "Determines if the request should be executed at the shield nodes."}}, "required": ["app_id"]}
    Next: {"type": "string", "description": "URL to the next activity logs records slice."}
    AdvancedMetricsResponseGroups: {"type": "object", "minProperties": 1, "properties": {"group": {"description": "Grouped metrics in accordance to \"`group_by`\" parameter.", "anyOf": ["$ref": "#/components/schemas/AdvancedMetricsResponseValues"]}}, "example": {"data": {"test.domain.com": [{"edge_status_2xx": 21095299, "timestamp": 1623159320}, {"edge_status_2xx": 62616980, "timestamp": 1623159380}]}}}
    HTTPAction: {"allOf": ["$ref": "#/components/schemas/BaseHTTPAction", {"type": "object", "properties": {"use_compression": {"type": "boolean", "default": false}, "response_actions": {"type": "array", "items": {"type": "object", "properties": {"match_status_code": {"type": "integer", "default": 0}, "match_payload": {"type": "string", "default": ""}, "description": {"type": "string", "default": ""}, "action": {"type": "string", "enum": ["drop", "retry", "append"]}}, "required": ["action"]}}}, "required": ["url"]}]}
    properties-enabled: {"type": "boolean", "description": "Enables or disables a log forwarding feature.\n\nPossible values:\n- **true** - log forwarding feature is active.\n- **false** - log forwarding feature is deactivated."}
    cdn_Count: {"type": "integer", "description": "Total number of activity logs records."}
    Results: {"type": "array", "items": {"$ref": "#/components/schemas/ActivityLogsDetails"}, "description": "Activity logs records."}
    StateAfterRequest: {"type": "object", "description": "JSON representation of object after the request."}
    id: {"type": "integer", "description": "Origin group ID.", "example": 1}
    cdn_ActionType: {"type": "string", "description": "Type of change.\n\nPossible values:\n- **D** - Object is deleted.\n- **C** - Object is created.\n- **U** - Object is updated."}
    Previous: {"type": "string", "description": "URL to the previous activity logs records slice."}
  responses:
    ResourceNotFound: {"description": "The specified CDN resource is not found in the current account."}
    List: {"description": "Successful.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ActivityLogsPaginatedList"}, "example": {"count": 1, "next": "https://api.gcore.com/cdn/activity_log/requests?offset=20&limit=10", "previous": "https://api.gcore.com/cdn/activity_log/requests?offset=10&limit=10", "results": [{"id": 1, "user_id": 174, "token_id": 3, "client_id": 174, "requested_at": "2021-07-07T09:02:29.871030Z", "path": "/resources/1/purge", "remote_ip_address": "1.2.3.4", "host": "api.gcore.com", "method": "POST", "query_params": "{}", "data": {"paths": ["/url-path-1", "/url-path-2"]}, "status_code": 201, "actions": []}]}}}}
    Details: {"description": "Successful.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ActivityLogsDetails"}, "example": {"id": 1, "user_id": 174, "token_id": 3, "client_id": 174, "requested_at": "2021-07-07T09:02:29.871030Z", "path": "/resources/1/purge", "remote_ip_address": "1.2.3.4", "host": "api.gcore.com", "method": "POST", "query_params": "{}", "data": {"paths": ["/url-path-1", "/url-path-2"]}, "status_code": 201, "actions": []}}}}
    NoPermissions: {"description": "You do not have permission to perform this action."}
    OriginGroupNotFound: {"description": "Origin group is not found in the current account."}
  securitySchemes:
    APIKey:
      description: "API key for authentication. Make sure to include the word `apikey`, followed by a single space and then your token.\nExample: `apikey 1234$abcdef`"
      type: apiKey
      in: header
      name: Authorization
